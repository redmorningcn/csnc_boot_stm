###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_tmr.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_tmr.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_tmr.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_tmr.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_tmr.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIMER MANAGEMENT
     10          *
     11          * File    : OS_TMR.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_tmr__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_TMR_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                                     CONSTANTS
     45          ************************************************************************************************************************
     46          */
     47          
     48          #define  OS_OPT_LINK_DLY       (OS_OPT)(0u)
     49          #define  OS_OPT_LINK_PERIODIC  (OS_OPT)(1u)
     50          
     51          /*$PAGE*/
     52          /*
     53          ************************************************************************************************************************
     54          *                                                   CREATE A TIMER
     55          *
     56          * Description: This function is called by your application code to create a timer.
     57          *
     58          * Arguments  : p_tmr           Is a pointer to a timer control block
     59          *
     60          *              p_name          Is a pointer to an ASCII string that is used to name the timer.  Names are useful for
     61          *                              debugging.
     62          *
     63          *              dly             Initial delay.
     64          *                              If the timer is configured for ONE-SHOT mode, this is the timeout used
     65          *                              If the timer is configured for PERIODIC mode, this is the first timeout to wait for
     66          *                              before the timer starts entering periodic mode
     67          *
     68          *              period          The 'period' being repeated for the timer.
     69          *                              If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer expires, it will
     70          *                              automatically restart with the same period.
     71          *
     72          *              opt             Specifies either:
     73          *
     74          *                                  OS_OPT_TMR_ONE_SHOT       The timer counts down only once
     75          *                                  OS_OPT_TMR_PERIODIC       The timer counts down and then reloads itself
     76          *
     77          *              p_callback      Is a pointer to a callback function that will be called when the timer expires.  The
     78          *                              callback function must be declared as follows:
     79          *
     80          *                                  void  MyCallback (OS_TMR *p_tmr, void *p_arg);
     81          *
     82          *              p_callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
     83          *
     84          *              p_err           Is a pointer to an error code.  '*p_err' will contain one of the following:
     85          *
     86          *                                 OS_ERR_NONE
     87          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the timer after you called
     88          *                                                                  OSSafetyCriticalStart().
     89          *                                 OS_ERR_OBJ_CREATED             if the timer has already been created
     90          *                                 OS_ERR_OBJ_PTR_NULL            is 'p_tmr' is a NULL pointer
     91          *                                 OS_ERR_OBJ_TYPE                if the object type is invalid
     92          *                                 OS_ERR_OPT_INVALID             you specified an invalid option
     93          *                                 OS_ERR_TMR_INVALID_DLY         you specified an invalid delay
     94          *                                 OS_ERR_TMR_INVALID_PERIOD      you specified an invalid period
     95          *                                 OS_ERR_TMR_ISR                 if the call was made from an ISR
     96          *
     97          * Returns    : none
     98          *
     99          * Note(s)    : 1) This function only creates the timer.  In other words, the timer is not started when created.  To
    100          *                 start the timer, call OSTmrStart().
    101          ************************************************************************************************************************
    102          */
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void  OSTmrCreate (OS_TMR               *p_tmr,
    105                             CPU_CHAR             *p_name,
    106                             OS_TICK               dly,
    107                             OS_TICK               period,
    108                             OS_OPT                opt,
    109                             OS_TMR_CALLBACK_PTR   p_callback,
    110                             void                 *p_callback_arg,
    111                             OS_ERR               *p_err)
    112          {
   \                     OSTmrCreate: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   \   0000000A   0x9C0A             LDR      R4,[SP, #+40]
   \   0000000C   0xF8DD 0x802C      LDR      R8,[SP, #+44]
   \   00000010   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   00000014   0xF8DD 0xA034      LDR      R10,[SP, #+52]
    113              CPU_SR_ALLOC();
   \   00000018   0xF05F 0x0B00      MOVS     R11,#+0
    114          
    115          
    116          
    117          #ifdef OS_SAFETY_CRITICAL
    118              if (p_err == (OS_ERR *)0) {
    119                  OS_SAFETY_CRITICAL_EXCEPTION();
    120                  return;
    121              }
    122          #endif
    123          
    124          #ifdef OS_SAFETY_CRITICAL_IEC61508
    125              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    126                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    127                  return;
    128              }
    129          #endif
    130          
    131          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    132              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??OSTmrCreate_0
    133                 *p_err = OS_ERR_TMR_ISR;
   \   00000026   0xF247 0x3043      MOVW     R0,#+29507
   \   0000002A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    134                  return;
   \   0000002E   0xE075             B.N      ??OSTmrCreate_1
    135              }
    136          #endif
    137          
    138          #if OS_CFG_ARG_CHK_EN > 0u
    139              if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
   \                     ??OSTmrCreate_0: (+1)
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD104             BNE.N    ??OSTmrCreate_2
    140                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    141                  return;
   \   0000003C   0xE06E             B.N      ??OSTmrCreate_1
    142              }
    143          
    144              switch (opt) {
   \                     ??OSTmrCreate_2: (+1)
   \   0000003E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD009             BEQ.N    ??OSTmrCreate_3
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD10F             BNE.N    ??OSTmrCreate_4
    145                  case OS_OPT_TMR_PERIODIC:
    146                       if (period == (OS_TICK)0) {
   \                     ??OSTmrCreate_5: (+1)
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xD104             BNE.N    ??OSTmrCreate_6
    147                          *p_err = OS_ERR_TMR_INVALID_PERIOD;
   \   0000004E   0xF247 0x3040      MOVW     R0,#+29504
   \   00000052   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    148                           return;
   \   00000056   0xE061             B.N      ??OSTmrCreate_1
    149                       }
    150                       break;
   \                     ??OSTmrCreate_6: (+1)
   \   00000058   0xE00C             B.N      ??OSTmrCreate_7
    151          
    152                  case OS_OPT_TMR_ONE_SHOT:
    153                       if (dly == (OS_TICK)0) {
   \                     ??OSTmrCreate_3: (+1)
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD104             BNE.N    ??OSTmrCreate_8
    154                          *p_err = OS_ERR_TMR_INVALID_DLY;
   \   0000005E   0xF247 0x303F      MOVW     R0,#+29503
   \   00000062   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    155                           return;
   \   00000066   0xE059             B.N      ??OSTmrCreate_1
    156                       }
    157                       break;
   \                     ??OSTmrCreate_8: (+1)
   \   00000068   0xE004             B.N      ??OSTmrCreate_7
    158          
    159                  default:
    160                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTmrCreate_4: (+1)
   \   0000006A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    161                       return;
   \   00000072   0xE053             B.N      ??OSTmrCreate_1
    162              }
    163          #endif
    164          
    165              OS_CRITICAL_ENTER();
   \                     ??OSTmrCreate_7: (+1)
   \   00000074   0x.... 0x....      BL       CPU_SR_Save
   \   00000078   0x4683             MOV      R11,R0
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD101             BNE.N    ??OSTmrCreate_9
   \   00000096   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTmrCreate_9: (+1)
   \   0000009A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009E   0x4658             MOV      R0,R11
   \   000000A0   0x.... 0x....      BL       CPU_SR_Restore
    166              p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xF885 0x002A      STRB     R0,[R5, #+42]
    167              p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x20524d54
   \   000000AE   0x6028             STR      R0,[R5, #+0]
    168              p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
   \   000000B0   0x9800             LDR      R0,[SP, #+0]
   \   000000B2   0x6068             STR      R0,[R5, #+4]
    169              p_tmr->Dly            = (OS_TICK            )dly;
   \   000000B4   0x622E             STR      R6,[R5, #+32]
    170              p_tmr->Match          = (OS_TICK            )0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x61A8             STR      R0,[R5, #+24]
    171              p_tmr->Remain         = (OS_TICK            )0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x61E8             STR      R0,[R5, #+28]
    172              p_tmr->Period         = (OS_TICK            )period;
   \   000000BE   0x626F             STR      R7,[R5, #+36]
    173              p_tmr->Opt            = (OS_OPT             )opt;
   \   000000C0   0x852C             STRH     R4,[R5, #+40]
    174              p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
   \   000000C2   0xF8C5 0x8008      STR      R8,[R5, #+8]
    175              p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
   \   000000C6   0xF8C5 0x900C      STR      R9,[R5, #+12]
    176              p_tmr->NextPtr        = (OS_TMR            *)0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x6128             STR      R0,[R5, #+16]
    177              p_tmr->PrevPtr        = (OS_TMR            *)0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x6168             STR      R0,[R5, #+20]
    178          
    179          #if OS_CFG_DBG_EN > 0u
    180              OS_TmrDbgListAdd(p_tmr);
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0x.... 0x....      BL       OS_TmrDbgListAdd
    181          #endif
    182              OSTmrQty++;                                             /* Keep track of the number of timers created             */
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   000000DC   0x8800             LDRH     R0,[R0, #+0]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000000E4   0x8008             STRH     R0,[R1, #+0]
    183          
    184              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000E6   0x.... 0x....      BL       CPU_SR_Save
   \   000000EA   0x4683             MOV      R11,R0
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x1E40             SUBS     R0,R0,#+1
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   000000FC   0x7008             STRB     R0,[R1, #+0]
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD101             BNE.N    ??OSTmrCreate_10
   \   00000108   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTmrCreate_10: (+1)
   \   0000010C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000110   0x4658             MOV      R0,R11
   \   00000112   0x.... 0x....      BL       CPU_SR_Restore
    185             *p_err = OS_ERR_NONE;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    186          }
   \                     ??OSTmrCreate_1: (+1)
   \   0000011C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    187          
    188          /*$PAGE*/
    189          /*
    190          ************************************************************************************************************************
    191          *                                                   DELETE A TIMER
    192          *
    193          * Description: This function is called by your application code to delete a timer.
    194          *
    195          * Arguments  : p_tmr          Is a pointer to the timer to stop and delete.
    196          *
    197          *              p_err          Is a pointer to an error code.  '*p_err' will contain one of the following:
    198          *
    199          *                                 OS_ERR_NONE
    200          *                                 OS_ERR_OBJ_TYPE             'p_tmr' is not pointing to a timer
    201          *                                 OS_ERR_TMR_INVALID          'p_tmr' is a NULL pointer
    202          *                                 OS_ERR_TMR_ISR              if the function was called from an ISR
    203          *                                 OS_ERR_TMR_INACTIVE         if the timer was not created
    204          *                                 OS_ERR_TMR_INVALID_STATE    the timer is in an invalid state
    205          *
    206          * Returns    : DEF_TRUE   if the timer was deleted
    207          *              DEF_FALSE  if not or upon an error
    208          ************************************************************************************************************************
    209          */
    210          
    211          #if OS_CFG_TMR_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    212          CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
    213                                 OS_ERR  *p_err)
    214          {
   \                     OSTmrDel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    215              OS_ERR       err;
    216              CPU_BOOLEAN  success;
    217          
    218          
    219          
    220          #ifdef OS_SAFETY_CRITICAL
    221              if (p_err == (OS_ERR *)0) {
    222                  OS_SAFETY_CRITICAL_EXCEPTION();
    223                  return (DEF_FALSE);
    224              }
    225          #endif
    226          
    227          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    228              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTmrDel_0
    229                 *p_err  = OS_ERR_TMR_ISR;
   \   00000012   0xF247 0x3043      MOVW     R0,#+29507
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    230                  return (DEF_FALSE);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE053             B.N      ??OSTmrDel_1
    231              }
    232          #endif
    233          
    234          #if OS_CFG_ARG_CHK_EN > 0u
    235              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrDel_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSTmrDel_2
    236                 *p_err = OS_ERR_TMR_INVALID;
   \   00000020   0xF247 0x3042      MOVW     R0,#+29506
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    237                  return (DEF_FALSE);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE04C             B.N      ??OSTmrDel_1
    238              }
    239          #endif
    240          
    241          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    242              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
   \                     ??OSTmrDel_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x20524d54
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??OSTmrDel_3
    243                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000034   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    244                  return (DEF_FALSE);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE042             B.N      ??OSTmrDel_1
    245              }
    246          #endif
    247          
    248              OSSchedLock(&err);
   \                     ??OSTmrDel_3: (+1)
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x.... 0x....      BL       OSSchedLock
    249          #if OS_CFG_DBG_EN > 0u
    250              OS_TmrDbgListRemove(p_tmr);
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       OS_TmrDbgListRemove
    251          #endif
    252              OSTmrQty--;                                             /* One less timer                                         */
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000004E   0x8800             LDRH     R0,[R0, #+0]
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000056   0x8008             STRH     R0,[R1, #+0]
    253          
    254              switch (p_tmr->State) {
   \   00000058   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD01E             BEQ.N    ??OSTmrDel_4
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD003             BEQ.N    ??OSTmrDel_5
   \   00000064   0xD310             BCC.N    ??OSTmrDel_6
   \   00000066   0x2803             CMP      R0,#+3
   \   00000068   0xD00E             BEQ.N    ??OSTmrDel_6
   \   0000006A   0xE021             B.N      ??OSTmrDel_7
    255                  case OS_TMR_STATE_RUNNING:
    256                       OS_TmrUnlink(p_tmr);                           /* Remove from current wheel spoke                        */
   \                     ??OSTmrDel_5: (+1)
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       OS_TmrUnlink
    257                       OS_TmrClr(p_tmr);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       OS_TmrClr
    258                       OSSchedUnlock(&err);
   \   00000078   0x4668             MOV      R0,SP
   \   0000007A   0x.... 0x....      BL       OSSchedUnlock
    259                      *p_err   = OS_ERR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x8028             STRH     R0,[R5, #+0]
    260                       success = DEF_TRUE;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x0006             MOVS     R6,R0
    261                       break;
   \   00000086   0xE01B             B.N      ??OSTmrDel_8
    262          
    263                  case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
    264                  case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
    265                       OS_TmrClr(p_tmr);                              /* Clear timer fields                                     */
   \                     ??OSTmrDel_6: (+1)
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       OS_TmrClr
    266                       OSSchedUnlock(&err);
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x.... 0x....      BL       OSSchedUnlock
    267                      *p_err   = OS_ERR_NONE;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x8028             STRH     R0,[R5, #+0]
    268                       success = DEF_TRUE;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0006             MOVS     R6,R0
    269                       break;
   \   0000009C   0xE010             B.N      ??OSTmrDel_8
    270                       
    271                  case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
    272                       OSSchedUnlock(&err);
   \                     ??OSTmrDel_4: (+1)
   \   0000009E   0x4668             MOV      R0,SP
   \   000000A0   0x.... 0x....      BL       OSSchedUnlock
    273                      *p_err   = OS_ERR_TMR_INACTIVE;
   \   000000A4   0xF247 0x303D      MOVW     R0,#+29501
   \   000000A8   0x8028             STRH     R0,[R5, #+0]
    274                       success = DEF_FALSE;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x0006             MOVS     R6,R0
    275                       break;
   \   000000AE   0xE007             B.N      ??OSTmrDel_8
    276          
    277                  default:
    278                       OSSchedUnlock(&err);
   \                     ??OSTmrDel_7: (+1)
   \   000000B0   0x4668             MOV      R0,SP
   \   000000B2   0x.... 0x....      BL       OSSchedUnlock
    279                      *p_err   = OS_ERR_TMR_INVALID_STATE;
   \   000000B6   0xF247 0x3041      MOVW     R0,#+29505
   \   000000BA   0x8028             STRH     R0,[R5, #+0]
    280                       success = DEF_FALSE;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x0006             MOVS     R6,R0
    281                       break;
    282              }
    283              return (success);
   \                     ??OSTmrDel_8: (+1)
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrDel_1: (+1)
   \   000000C4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    284          }
    285          #endif
    286          
    287          /*$PAGE*/
    288          /*
    289          ************************************************************************************************************************
    290          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
    291          *
    292          * Description: This function is called to get the number of ticks before a timer times out.
    293          *
    294          * Arguments  : p_tmr    Is a pointer to the timer to obtain the remaining time from.
    295          *
    296          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    297          *
    298          *                           OS_ERR_NONE
    299          *                           OS_ERR_OBJ_TYPE           'p_tmr' is not pointing to a timer
    300          *                           OS_ERR_TMR_INVALID        'p_tmr' is a NULL pointer
    301          *                           OS_ERR_TMR_ISR            if the call was made from an ISR
    302          *                           OS_ERR_TMR_INACTIVE       'p_tmr' points to a timer that is not active
    303          *                           OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
    304          *
    305          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments.  In other words, if
    306          *              OS_TmrTask() is signaled every 1/10 of a second then the returned value represents the number of 1/10 of
    307          *              a second remaining before the timer expires.
    308          ************************************************************************************************************************
    309          */
    310          

   \                                 In section .text, align 2, keep-with-next
    311          OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
    312                                   OS_ERR  *p_err)
    313          {
   \                     OSTmrRemainGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    314              OS_TICK  remain;
    315              OS_ERR   err;
    316          
    317          
    318          
    319          #ifdef OS_SAFETY_CRITICAL
    320              if (p_err == (OS_ERR *)0) {
    321                  OS_SAFETY_CRITICAL_EXCEPTION();
    322                  return ((OS_TICK)0);
    323              }
    324          #endif
    325          
    326          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    327              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTmrRemainGet_0
    328                 *p_err = OS_ERR_TMR_ISR;
   \   00000012   0xF247 0x3043      MOVW     R0,#+29507
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    329                  return ((OS_TICK)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE059             B.N      ??OSTmrRemainGet_1
    330              }
    331          #endif
    332          
    333          #if OS_CFG_ARG_CHK_EN > 0u
    334              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrRemainGet_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSTmrRemainGet_2
    335                 *p_err = OS_ERR_TMR_INVALID;
   \   00000020   0xF247 0x3042      MOVW     R0,#+29506
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    336                  return ((OS_TICK)0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE052             B.N      ??OSTmrRemainGet_1
    337              }
    338          #endif
    339          
    340          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    341              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
   \                     ??OSTmrRemainGet_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x20524d54
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??OSTmrRemainGet_3
    342                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000034   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    343                  return ((OS_TICK)0);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE048             B.N      ??OSTmrRemainGet_1
    344              }
    345          #endif
    346          
    347              OSSchedLock(&err);
   \                     ??OSTmrRemainGet_3: (+1)
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x.... 0x....      BL       OSSchedLock
    348              switch (p_tmr->State) {
   \   00000044   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD02F             BEQ.N    ??OSTmrRemainGet_4
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD003             BEQ.N    ??OSTmrRemainGet_5
   \   00000050   0xD30F             BCC.N    ??OSTmrRemainGet_6
   \   00000052   0x2803             CMP      R0,#+3
   \   00000054   0xD022             BEQ.N    ??OSTmrRemainGet_7
   \   00000056   0xE032             B.N      ??OSTmrRemainGet_8
    349                  case OS_TMR_STATE_RUNNING:
    350                       remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
    351                                     - OSTmrTickCtr;
   \                     ??OSTmrRemainGet_5: (+1)
   \   00000058   0x69A0             LDR      R0,[R4, #+24]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x1A40             SUBS     R0,R0,R1
   \   00000062   0x0006             MOVS     R6,R0
    352                       p_tmr->Remain = remain;
   \   00000064   0x61E6             STR      R6,[R4, #+28]
    353                       OSSchedUnlock(&err);
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x.... 0x....      BL       OSSchedUnlock
    354                      *p_err         = OS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8028             STRH     R0,[R5, #+0]
    355                       break;
   \   00000070   0xE02D             B.N      ??OSTmrRemainGet_9
    356          
    357                  case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
    358                       if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
   \                     ??OSTmrRemainGet_6: (+1)
   \   00000072   0x8D20             LDRH     R0,[R4, #+40]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD108             BNE.N    ??OSTmrRemainGet_10
    359                           if (p_tmr->Dly == 0u) {
   \   00000078   0x6A20             LDR      R0,[R4, #+32]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD102             BNE.N    ??OSTmrRemainGet_11
    360                               remain = p_tmr->Period;
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x0006             MOVS     R6,R0
   \   00000082   0xE004             B.N      ??OSTmrRemainGet_12
    361                           } else {
    362                               remain = p_tmr->Dly;
   \                     ??OSTmrRemainGet_11: (+1)
   \   00000084   0x6A20             LDR      R0,[R4, #+32]
   \   00000086   0x0006             MOVS     R6,R0
   \   00000088   0xE001             B.N      ??OSTmrRemainGet_12
    363                           }
    364                       } else {
    365                           remain = p_tmr->Dly;
   \                     ??OSTmrRemainGet_10: (+1)
   \   0000008A   0x6A20             LDR      R0,[R4, #+32]
   \   0000008C   0x0006             MOVS     R6,R0
    366                       }
    367                       p_tmr->Remain = remain;
   \                     ??OSTmrRemainGet_12: (+1)
   \   0000008E   0x61E6             STR      R6,[R4, #+28]
    368                       OSSchedUnlock(&err);
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x.... 0x....      BL       OSSchedUnlock
    369                      *p_err         = OS_ERR_NONE;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x8028             STRH     R0,[R5, #+0]
    370                       break;
   \   0000009A   0xE018             B.N      ??OSTmrRemainGet_9
    371          
    372                  case OS_TMR_STATE_COMPLETED:                        /* Only ONE-SHOT that timed out can be in this state      */
    373                       OSSchedUnlock(&err);
   \                     ??OSTmrRemainGet_7: (+1)
   \   0000009C   0x4668             MOV      R0,SP
   \   0000009E   0x.... 0x....      BL       OSSchedUnlock
    374                      *p_err  = OS_ERR_NONE;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x8028             STRH     R0,[R5, #+0]
    375                       remain = (OS_TICK)0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x0006             MOVS     R6,R0
    376                       break;
   \   000000AA   0xE010             B.N      ??OSTmrRemainGet_9
    377          
    378                  case OS_TMR_STATE_UNUSED:
    379                       OSSchedUnlock(&err);
   \                     ??OSTmrRemainGet_4: (+1)
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x.... 0x....      BL       OSSchedUnlock
    380                      *p_err  = OS_ERR_TMR_INACTIVE;
   \   000000B2   0xF247 0x303D      MOVW     R0,#+29501
   \   000000B6   0x8028             STRH     R0,[R5, #+0]
    381                       remain = (OS_TICK)0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x0006             MOVS     R6,R0
    382                       break;
   \   000000BC   0xE007             B.N      ??OSTmrRemainGet_9
    383          
    384                  default:
    385                       OSSchedUnlock(&err);
   \                     ??OSTmrRemainGet_8: (+1)
   \   000000BE   0x4668             MOV      R0,SP
   \   000000C0   0x.... 0x....      BL       OSSchedUnlock
    386                      *p_err = OS_ERR_TMR_INVALID_STATE;
   \   000000C4   0xF247 0x3041      MOVW     R0,#+29505
   \   000000C8   0x8028             STRH     R0,[R5, #+0]
    387                       remain = (OS_TICK)0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0006             MOVS     R6,R0
    388                       break;
    389              }
    390              return (remain);
   \                     ??OSTmrRemainGet_9: (+1)
   \   000000CE   0x0030             MOVS     R0,R6
   \                     ??OSTmrRemainGet_1: (+1)
   \   000000D0   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    391          }
    392          
    393          /*$PAGE*/
    394          /*
    395          ************************************************************************************************************************
    396          *                                                   START A TIMER
    397          *
    398          * Description: This function is called by your application code to start a timer.
    399          *
    400          * Arguments  : p_tmr    Is a pointer to an OS_TMR
    401          *
    402          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    403          *
    404          *                           OS_ERR_NONE
    405          *                           OS_ERR_OBJ_TYPE            if 'p_tmr' is not pointing to a timer
    406          *                           OS_ERR_TMR_INVALID
    407          *                           OS_ERR_TMR_INACTIVE        if the timer was not created
    408          *                           OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
    409          *                           OS_ERR_TMR_ISR             if the call was made from an ISR
    410          *
    411          * Returns    : DEF_TRUE      is the timer was started
    412          *              DEF_FALSE     if not or upon an error
    413          *
    414          * Note(s)    : 1) When starting/restarting a timer, regardless if it is in PERIODIC or ONE-SHOT mode, the timer is 
    415          *                 linked to the timer wheel with the OS_OPT_LINK_DLY option. This option sets the initial expiration 
    416          *                 time for the timer. For timers in PERIODIC mode, subsequent expiration times are handled by 
    417          *                 the OS_TmrTask().
    418          ************************************************************************************************************************
    419          */
    420          

   \                                 In section .text, align 2, keep-with-next
    421          CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
    422                                   OS_ERR  *p_err)
    423          {
   \                     OSTmrStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    424              OS_ERR       err;
    425              CPU_BOOLEAN  success;
    426          
    427          
    428          
    429          #ifdef OS_SAFETY_CRITICAL
    430              if (p_err == (OS_ERR *)0) {
    431                  OS_SAFETY_CRITICAL_EXCEPTION();
    432                  return (DEF_FALSE);
    433              }
    434          #endif
    435          
    436          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    437              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTmrStart_0
    438                 *p_err = OS_ERR_TMR_ISR;
   \   00000012   0xF247 0x3043      MOVW     R0,#+29507
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    439                  return (DEF_FALSE);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE04B             B.N      ??OSTmrStart_1
    440              }
    441          #endif
    442          
    443          #if OS_CFG_ARG_CHK_EN > 0u
    444              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrStart_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSTmrStart_2
    445                 *p_err = OS_ERR_TMR_INVALID;
   \   00000020   0xF247 0x3042      MOVW     R0,#+29506
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    446                  return (DEF_FALSE);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE044             B.N      ??OSTmrStart_1
    447              }
    448          #endif
    449          
    450          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    451              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
   \                     ??OSTmrStart_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x20524d54
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??OSTmrStart_3
    452                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000034   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    453                  return (DEF_FALSE);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE03A             B.N      ??OSTmrStart_1
    454              }
    455          #endif
    456          
    457              OSSchedLock(&err);
   \                     ??OSTmrStart_3: (+1)
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x.... 0x....      BL       OSSchedLock
    458              switch (p_tmr->State) {
   \   00000044   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD020             BEQ.N    ??OSTmrStart_4
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD003             BEQ.N    ??OSTmrStart_5
   \   00000050   0xD311             BCC.N    ??OSTmrStart_6
   \   00000052   0x2803             CMP      R0,#+3
   \   00000054   0xD00F             BEQ.N    ??OSTmrStart_6
   \   00000056   0xE023             B.N      ??OSTmrStart_7
    459                  case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
    460                       OS_TmrUnlink(p_tmr);                           /* ... Stop the timer                                     */
   \                     ??OSTmrStart_5: (+1)
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       OS_TmrUnlink
    461                       OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       OS_TmrLink
    462                       OSSchedUnlock(&err);
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x.... 0x....      BL       OSSchedUnlock
    463                      *p_err   = OS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8028             STRH     R0,[R5, #+0]
    464                       success = DEF_TRUE;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x0006             MOVS     R6,R0
    465                       break;
   \   00000074   0xE01C             B.N      ??OSTmrStart_8
    466          
    467                  case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
    468                  case OS_TMR_STATE_COMPLETED:
    469                       OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
   \                     ??OSTmrStart_6: (+1)
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       OS_TmrLink
    470                       OSSchedUnlock(&err);
   \   0000007E   0x4668             MOV      R0,SP
   \   00000080   0x.... 0x....      BL       OSSchedUnlock
    471                      *p_err   = OS_ERR_NONE;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x8028             STRH     R0,[R5, #+0]
    472                       success = DEF_TRUE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x0006             MOVS     R6,R0
    473                       break;
   \   0000008C   0xE010             B.N      ??OSTmrStart_8
    474          
    475                  case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
    476                       OSSchedUnlock(&err);
   \                     ??OSTmrStart_4: (+1)
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x.... 0x....      BL       OSSchedUnlock
    477                      *p_err   = OS_ERR_TMR_INACTIVE;
   \   00000094   0xF247 0x303D      MOVW     R0,#+29501
   \   00000098   0x8028             STRH     R0,[R5, #+0]
    478                       success = DEF_FALSE;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x0006             MOVS     R6,R0
    479                       break;
   \   0000009E   0xE007             B.N      ??OSTmrStart_8
    480          
    481                  default:
    482                       OSSchedUnlock(&err);
   \                     ??OSTmrStart_7: (+1)
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x.... 0x....      BL       OSSchedUnlock
    483                      *p_err = OS_ERR_TMR_INVALID_STATE;
   \   000000A6   0xF247 0x3041      MOVW     R0,#+29505
   \   000000AA   0x8028             STRH     R0,[R5, #+0]
    484                       success = DEF_FALSE;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x0006             MOVS     R6,R0
    485                       break;
    486              }
    487              return (success);
   \                     ??OSTmrStart_8: (+1)
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStart_1: (+1)
   \   000000B4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    488          }
    489          
    490          /*$PAGE*/
    491          /*
    492          ************************************************************************************************************************
    493          *                                           FIND OUT WHAT STATE A TIMER IS IN
    494          *
    495          * Description: This function is called to determine what state the timer is in:
    496          *
    497          *                  OS_TMR_STATE_UNUSED     the timer has not been created
    498          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
    499          *                  OS_TMR_COMPLETED        the timer is in ONE-SHOT mode and has completed it's timeout
    500          *                  OS_TMR_RUNNING          the timer is currently running
    501          *
    502          * Arguments  : p_tmr    Is a pointer to the desired timer
    503          *
    504          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    505          *
    506          *                           OS_ERR_NONE
    507          *                           OS_ERR_OBJ_TYPE            if 'p_tmr' is not pointing to a timer
    508          *                           OS_ERR_TMR_INVALID        'p_tmr' is a NULL pointer
    509          *                           OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
    510          *                           OS_ERR_TMR_ISR            if the call was made from an ISR
    511          *
    512          * Returns    : The current state of the timer (see description).
    513          ************************************************************************************************************************
    514          */
    515          

   \                                 In section .text, align 2, keep-with-next
    516          OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
    517                                   OS_ERR  *p_err)
    518          {
   \                     OSTmrStateGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    519              OS_STATE  state;
    520              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    521          
    522          
    523          
    524          #ifdef OS_SAFETY_CRITICAL
    525              if (p_err == (OS_ERR *)0) {
    526                  OS_SAFETY_CRITICAL_EXCEPTION();
    527                  return (OS_TMR_STATE_UNUSED);
    528              }
    529          #endif
    530          
    531          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    532              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTmrStateGet_0
    533                 *p_err = OS_ERR_TMR_ISR;
   \   00000012   0xF247 0x3043      MOVW     R0,#+29507
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    534                  return (OS_TMR_STATE_UNUSED);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE02A             B.N      ??OSTmrStateGet_1
    535              }
    536          #endif
    537          
    538          #if OS_CFG_ARG_CHK_EN > 0u
    539              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrStateGet_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSTmrStateGet_2
    540                 *p_err = OS_ERR_TMR_INVALID;
   \   00000020   0xF247 0x3042      MOVW     R0,#+29506
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    541                  return (OS_TMR_STATE_UNUSED);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE023             B.N      ??OSTmrStateGet_1
    542              }
    543          #endif
    544          
    545          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    546              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
   \                     ??OSTmrStateGet_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x20524d54
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??OSTmrStateGet_3
    547                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000034   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    548                  return (OS_TMR_STATE_UNUSED);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE019             B.N      ??OSTmrStateGet_1
    549              }
    550          #endif
    551          
    552              CPU_CRITICAL_ENTER();
   \                     ??OSTmrStateGet_3: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0007             MOVS     R7,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
    553              state = p_tmr->State;
   \   00000048   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   0000004C   0x0006             MOVS     R6,R0
    554              switch (state) {
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD802             BHI.N    ??OSTmrStateGet_4
    555                  case OS_TMR_STATE_UNUSED:
    556                  case OS_TMR_STATE_STOPPED:
    557                  case OS_TMR_STATE_COMPLETED:
    558                  case OS_TMR_STATE_RUNNING:
    559                      *p_err = OS_ERR_NONE;
   \                     ??OSTmrStateGet_5: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x8028             STRH     R0,[R5, #+0]
    560                       break;
   \   0000005C   0xE002             B.N      ??OSTmrStateGet_6
    561          
    562                  default:
    563                      *p_err = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrStateGet_4: (+1)
   \   0000005E   0xF247 0x3041      MOVW     R0,#+29505
   \   00000062   0x8028             STRH     R0,[R5, #+0]
    564                       break;
    565              }
    566              CPU_CRITICAL_EXIT();
   \                     ??OSTmrStateGet_6: (+1)
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    567              return (state);
   \   0000006E   0x0030             MOVS     R0,R6
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStateGet_1: (+1)
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    568          }
    569          
    570          /*$PAGE*/
    571          /*
    572          ************************************************************************************************************************
    573          *                                                    STOP A TIMER
    574          *
    575          * Description: This function is called by your application code to stop a timer.
    576          *
    577          * Arguments  : p_tmr          Is a pointer to the timer to stop.
    578          *
    579          *              opt           Allows you to specify an option to this functions which can be:
    580          *
    581          *                               OS_OPT_TMR_NONE            Do nothing special but stop the timer
    582          *                               OS_OPT_TMR_CALLBACK        Execute the callback function, pass it the callback argument
    583          *                                                          specified when the timer was created.
    584          *                               OS_OPT_TMR_CALLBACK_ARG    Execute the callback function, pass it the callback argument
    585          *                                                          specified in THIS function call
    586          *
    587          *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback function
    588          *                               instead of the timer's callback argument.  In other words, use 'callback_arg' passed in
    589          *                               THIS function INSTEAD of p_tmr->OSTmrCallbackArg
    590          *
    591          *              p_err          Is a pointer to an error code.  '*p_err' will contain one of the following:
    592          *                               OS_ERR_NONE
    593          *                               OS_ERR_OBJ_TYPE            if 'p_tmr' is not pointing to a timer
    594          *                               OS_ERR_OPT_INVALID         if you specified an invalid option for 'opt'
    595          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
    596          *                               OS_ERR_TMR_INVALID         'p_tmr' is a NULL pointer
    597          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
    598          *                               OS_ERR_TMR_ISR             if the function was called from an ISR
    599          *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
    600          *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
    601          *
    602          * Returns    : DEF_TRUE       If we stopped the timer (if the timer is already stopped, we also return DEF_TRUE)
    603          *              DEF_FALSE      If not
    604          ************************************************************************************************************************
    605          */
    606          

   \                                 In section .text, align 2, keep-with-next
    607          CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
    608                                  OS_OPT   opt,
    609                                  void    *p_callback_arg,
    610                                  OS_ERR  *p_err)
    611          {
   \                     OSTmrStop: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    612              OS_TMR_CALLBACK_PTR  p_fnct;
    613              OS_ERR               err;
    614              CPU_BOOLEAN          success;
    615          
    616          
    617          
    618          #ifdef OS_SAFETY_CRITICAL
    619              if (p_err == (OS_ERR *)0) {
    620                  OS_SAFETY_CRITICAL_EXCEPTION();
    621                  return (DEF_FALSE);
    622              }
    623          #endif
    624          
    625          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    626              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSTmrStop_0
    627                 *p_err = OS_ERR_TMR_ISR;
   \   00000016   0xF247 0x3043      MOVW     R0,#+29507
   \   0000001A   0x8038             STRH     R0,[R7, #+0]
    628                  return (DEF_FALSE);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE070             B.N      ??OSTmrStop_1
    629              }
    630          #endif
    631          
    632          #if OS_CFG_ARG_CHK_EN > 0u
    633              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrStop_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSTmrStop_2
    634                 *p_err = OS_ERR_TMR_INVALID;
   \   00000024   0xF247 0x3042      MOVW     R0,#+29506
   \   00000028   0x8038             STRH     R0,[R7, #+0]
    635                  return (DEF_FALSE);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE069             B.N      ??OSTmrStop_1
    636              }
    637          #endif
    638          
    639          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    640              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                             /* Make sure timer was created                  */
   \                     ??OSTmrStop_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x20524d54
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD004             BEQ.N    ??OSTmrStop_3
    641                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000038   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000003C   0x8038             STRH     R0,[R7, #+0]
    642                  return (DEF_FALSE);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE05F             B.N      ??OSTmrStop_1
    643              }
    644          #endif
    645          
    646              OSSchedLock(&err);
   \                     ??OSTmrStop_3: (+1)
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x.... 0x....      BL       OSSchedLock
    647              switch (p_tmr->State) {
   \   00000048   0xF894 0x002A      LDRB     R0,[R4, #+42]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD045             BEQ.N    ??OSTmrStop_4
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD003             BEQ.N    ??OSTmrStop_5
   \   00000054   0xD339             BCC.N    ??OSTmrStop_6
   \   00000056   0x2803             CMP      R0,#+3
   \   00000058   0xD037             BEQ.N    ??OSTmrStop_6
   \   0000005A   0xE048             B.N      ??OSTmrStop_7
    648                  case OS_TMR_STATE_RUNNING:
    649                       OS_TmrUnlink(p_tmr);                                     /* Remove from current wheel spoke              */
   \                     ??OSTmrStop_5: (+1)
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       OS_TmrUnlink
    650                      *p_err = OS_ERR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x8038             STRH     R0,[R7, #+0]
    651                       switch (opt) {
   \   00000066   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD01E             BEQ.N    ??OSTmrStop_8
   \   0000006E   0x2803             CMP      R0,#+3
   \   00000070   0xD002             BEQ.N    ??OSTmrStop_9
   \   00000072   0x2804             CMP      R0,#+4
   \   00000074   0xD00D             BEQ.N    ??OSTmrStop_10
   \   00000076   0xE01A             B.N      ??OSTmrStop_11
    652                           case OS_OPT_TMR_CALLBACK:
    653                                p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
   \                     ??OSTmrStop_9: (+1)
   \   00000078   0x68A0             LDR      R0,[R4, #+8]
   \   0000007A   0x4680             MOV      R8,R0
    654                                if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD003             BEQ.N    ??OSTmrStop_12
    655                                  (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
   \   00000082   0x68E1             LDR      R1,[R4, #+12]
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x47C0             BLX      R8
   \   00000088   0xE002             B.N      ??OSTmrStop_13
    656                                } else {
    657                                   *p_err = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_12: (+1)
   \   0000008A   0xF247 0x3044      MOVW     R0,#+29508
   \   0000008E   0x8038             STRH     R0,[R7, #+0]
    658                                }
    659                                break;
   \                     ??OSTmrStop_13: (+1)
   \   00000090   0xE015             B.N      ??OSTmrStop_14
    660          
    661                           case OS_OPT_TMR_CALLBACK_ARG:
    662                                p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available ...   */
   \                     ??OSTmrStop_10: (+1)
   \   00000092   0x68A0             LDR      R0,[R4, #+8]
   \   00000094   0x4680             MOV      R8,R0
    663                                if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD003             BEQ.N    ??OSTmrStop_15
    664                                  (*p_fnct)((void *)p_tmr, p_callback_arg);     /* .. using the 'callback_arg' provided in call */
   \   0000009C   0x0031             MOVS     R1,R6
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x47C0             BLX      R8
   \   000000A2   0xE002             B.N      ??OSTmrStop_16
    665                                } else {
    666                                   *p_err = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_15: (+1)
   \   000000A4   0xF247 0x3044      MOVW     R0,#+29508
   \   000000A8   0x8038             STRH     R0,[R7, #+0]
    667                                }
    668                                break;
   \                     ??OSTmrStop_16: (+1)
   \   000000AA   0xE008             B.N      ??OSTmrStop_14
    669          
    670                           case OS_OPT_TMR_NONE:
    671                                break;
   \                     ??OSTmrStop_8: (+1)
   \   000000AC   0xE007             B.N      ??OSTmrStop_14
    672          
    673                           default:
    674                               OSSchedUnlock(&err);
   \                     ??OSTmrStop_11: (+1)
   \   000000AE   0x4668             MOV      R0,SP
   \   000000B0   0x.... 0x....      BL       OSSchedUnlock
    675                              *p_err = OS_ERR_OPT_INVALID;
   \   000000B4   0xF645 0x6025      MOVW     R0,#+24101
   \   000000B8   0x8038             STRH     R0,[R7, #+0]
    676                               return (DEF_FALSE);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE021             B.N      ??OSTmrStop_1
    677                       }
    678                       OSSchedUnlock(&err);
   \                     ??OSTmrStop_14: (+1)
   \   000000BE   0x4668             MOV      R0,SP
   \   000000C0   0x.... 0x....      BL       OSSchedUnlock
    679                       success = DEF_TRUE;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x4681             MOV      R9,R0
    680                       break;
   \   000000C8   0xE019             B.N      ??OSTmrStop_17
    681          
    682                  case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
    683                  case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
    684                       OSSchedUnlock(&err);
   \                     ??OSTmrStop_6: (+1)
   \   000000CA   0x4668             MOV      R0,SP
   \   000000CC   0x.... 0x....      BL       OSSchedUnlock
    685                      *p_err   = OS_ERR_TMR_STOPPED;
   \   000000D0   0xF247 0x3049      MOVW     R0,#+29513
   \   000000D4   0x8038             STRH     R0,[R7, #+0]
    686                       success = DEF_TRUE;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x4681             MOV      R9,R0
    687                       break;
   \   000000DA   0xE010             B.N      ??OSTmrStop_17
    688          
    689                  case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
    690                       OSSchedUnlock(&err);
   \                     ??OSTmrStop_4: (+1)
   \   000000DC   0x4668             MOV      R0,SP
   \   000000DE   0x.... 0x....      BL       OSSchedUnlock
    691                      *p_err   = OS_ERR_TMR_INACTIVE;
   \   000000E2   0xF247 0x303D      MOVW     R0,#+29501
   \   000000E6   0x8038             STRH     R0,[R7, #+0]
    692                       success = DEF_FALSE;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x4681             MOV      R9,R0
    693                       break;
   \   000000EC   0xE007             B.N      ??OSTmrStop_17
    694          
    695                  default:
    696                       OSSchedUnlock(&err);
   \                     ??OSTmrStop_7: (+1)
   \   000000EE   0x4668             MOV      R0,SP
   \   000000F0   0x.... 0x....      BL       OSSchedUnlock
    697                      *p_err   = OS_ERR_TMR_INVALID_STATE;
   \   000000F4   0xF247 0x3041      MOVW     R0,#+29505
   \   000000F8   0x8038             STRH     R0,[R7, #+0]
    698                       success = DEF_FALSE;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x4681             MOV      R9,R0
    699                       break;
    700              }
    701              return (success);
   \                     ??OSTmrStop_17: (+1)
   \   000000FE   0x4648             MOV      R0,R9
   \   00000100   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStop_1: (+1)
   \   00000102   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    702          }
    703          
    704          /*$PAGE*/
    705          /*
    706          ************************************************************************************************************************
    707          *                                                 CLEAR TIMER FIELDS
    708          *
    709          * Description: This function is called to clear all timer fields.
    710          *
    711          * Argument(s): p_tmr    is a pointer to the timer to clear
    712          *              -----
    713          *
    714          * Returns    : none
    715          *
    716          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    717          ************************************************************************************************************************
    718          */
    719          

   \                                 In section .text, align 2, keep-with-next
    720          void  OS_TmrClr (OS_TMR  *p_tmr)
    721          {
    722              p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
   \                     OS_TmrClr: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x102A      STRB     R1,[R0, #+42]
    723              p_tmr->Type           = OS_OBJ_TYPE_NONE;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x454e4f4e
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    724              p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable13_6
   \   00000010   0x6041             STR      R1,[R0, #+4]
    725              p_tmr->Dly            = (OS_TICK            )0;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6201             STR      R1,[R0, #+32]
    726              p_tmr->Match          = (OS_TICK            )0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6181             STR      R1,[R0, #+24]
    727              p_tmr->Remain         = (OS_TICK            )0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
    728              p_tmr->Period         = (OS_TICK            )0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6241             STR      R1,[R0, #+36]
    729              p_tmr->Opt            = (OS_OPT             )0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x8501             STRH     R1,[R0, #+40]
    730              p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x6081             STR      R1,[R0, #+8]
    731              p_tmr->CallbackPtrArg = (void              *)0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
    732              p_tmr->NextPtr        = (OS_TMR            *)0;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6101             STR      R1,[R0, #+16]
    733              p_tmr->PrevPtr        = (OS_TMR            *)0;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6141             STR      R1,[R0, #+20]
    734          }
   \   00000036   0x4770             BX       LR               ;; return
    735          
    736          /*$PAGE*/
    737          /*
    738          ************************************************************************************************************************
    739          *                                         ADD/REMOVE TIMER TO/FROM DEBUG TABLE
    740          *
    741          * Description: These functions are called by uC/OS-III to add or remove a timer to/from a timer debug table.
    742          *
    743          * Arguments  : p_tmr     is a pointer to the timer to add/remove
    744          *
    745          * Returns    : none
    746          *
    747          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    748          ************************************************************************************************************************
    749          */
    750          
    751          
    752          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    753          void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
    754          {
    755              p_tmr->DbgPrevPtr               = (OS_TMR *)0;
   \                     OS_TmrDbgListAdd: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x62C1             STR      R1,[R0, #+44]
    756              if (OSTmrDbgListPtr == (OS_TMR *)0) {
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD102             BNE.N    ??OS_TmrDbgListAdd_0
    757                  p_tmr->DbgNextPtr           = (OS_TMR *)0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6301             STR      R1,[R0, #+48]
   \   00000012   0xE007             B.N      ??OS_TmrDbgListAdd_1
    758              } else {
    759                  p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
   \                     ??OS_TmrDbgListAdd_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6301             STR      R1,[R0, #+48]
    760                  OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x62C8             STR      R0,[R1, #+44]
    761              }
    762              OSTmrDbgListPtr                 =  p_tmr;
   \                     ??OS_TmrDbgListAdd_1: (+1)
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
    763          }
   \   0000002A   0x4770             BX       LR               ;; return
    764          
    765          
    766          

   \                                 In section .text, align 2, keep-with-next
    767          void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
    768          {
    769              OS_TMR  *p_tmr_next;
    770              OS_TMR  *p_tmr_prev;
    771          
    772          
    773              p_tmr_prev = p_tmr->DbgPrevPtr;
   \                     OS_TmrDbgListRemove: (+1)
   \   00000000   0x6AC3             LDR      R3,[R0, #+44]
   \   00000002   0x001A             MOVS     R2,R3
    774              p_tmr_next = p_tmr->DbgNextPtr;
   \   00000004   0x6B03             LDR      R3,[R0, #+48]
   \   00000006   0x0019             MOVS     R1,R3
    775          
    776              if (p_tmr_prev == (OS_TMR *)0) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD109             BNE.N    ??OS_TmrDbgListRemove_0
    777                  OSTmrDbgListPtr = p_tmr_next;
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable13_7
   \   00000010   0x6019             STR      R1,[R3, #+0]
    778                  if (p_tmr_next != (OS_TMR *)0) {
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ.N    ??OS_TmrDbgListRemove_1
    779                      p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x62CB             STR      R3,[R1, #+44]
    780                  }
    781                  p_tmr->DbgNextPtr = (OS_TMR *)0;
   \                     ??OS_TmrDbgListRemove_1: (+1)
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x6303             STR      R3,[R0, #+48]
   \   0000001E   0xE00C             B.N      ??OS_TmrDbgListRemove_2
    782          
    783              } else if (p_tmr_next == (OS_TMR *)0) {
   \                     ??OS_TmrDbgListRemove_0: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD104             BNE.N    ??OS_TmrDbgListRemove_3
    784                  p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x6313             STR      R3,[R2, #+48]
    785                  p_tmr->DbgPrevPtr      = (OS_TMR *)0;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x62C3             STR      R3,[R0, #+44]
   \   0000002C   0xE005             B.N      ??OS_TmrDbgListRemove_2
    786          
    787              } else {
    788                  p_tmr_prev->DbgNextPtr =  p_tmr_next;
   \                     ??OS_TmrDbgListRemove_3: (+1)
   \   0000002E   0x6311             STR      R1,[R2, #+48]
    789                  p_tmr_next->DbgPrevPtr =  p_tmr_prev;
   \   00000030   0x62CA             STR      R2,[R1, #+44]
    790                  p_tmr->DbgNextPtr      = (OS_TMR *)0;
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x6303             STR      R3,[R0, #+48]
    791                  p_tmr->DbgPrevPtr      = (OS_TMR *)0;
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0x62C3             STR      R3,[R0, #+44]
    792              }
    793          }
   \                     ??OS_TmrDbgListRemove_2: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
    794          #endif
    795          
    796          /*$PAGE*/
    797          /*
    798          ************************************************************************************************************************
    799          *                                             INITIALIZE THE TIMER MANAGER
    800          *
    801          * Description: This function is called by OSInit() to initialize the timer manager module.
    802          *
    803          * Argument(s): p_err    is a pointer to a variable that will contain an error code returned by this function.
    804          *
    805          *                           OS_ERR_NONE
    806          *                           OS_ERR_TMR_STK_INVALID       if you didn't specify a stack for the timer task
    807          *                           OS_ERR_TMR_STK_SIZE_INVALID  if you didn't allocate enough space for the timer stack
    808          *                           OS_ERR_PRIO_INVALID          if you specified the same priority as the idle task
    809          *                           OS_ERR_xxx                   any error code returned by OSTaskCreate()
    810          *
    811          * Returns    : none
    812          *
    813          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    814          ************************************************************************************************************************
    815          */
    816          

   \                                 In section .text, align 2, keep-with-next
    817          void  OS_TmrInit (OS_ERR  *p_err)
    818          {
   \                     OS_TmrInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    819              OS_TMR_SPOKE_IX   i;
    820              OS_TMR_SPOKE     *p_spoke;
    821          
    822          
    823          
    824          #ifdef OS_SAFETY_CRITICAL
    825              if (p_err == (OS_ERR *)0) {
    826                  OS_SAFETY_CRITICAL_EXCEPTION();
    827                  return;
    828              }
    829          #endif
    830          
    831          #if OS_CFG_DBG_EN > 0u
    832              OSTmrDbgListPtr = (OS_TMR *)0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable13_7
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    833          #endif
    834          
    835              if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
   \   0000000C   0x....             LDR.N    R0,??DataTable13_8
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ.N    ??OS_TmrInit_0
    836                  OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
   \   00000014   0x....             LDR.N    R0,??DataTable13_9
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable13_8
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000020   0x....             LDR.N    R1,??DataTable13_10
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE006             B.N      ??OS_TmrInit_1
    837              } else {
    838                  OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
   \                     ??OS_TmrInit_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable13_9
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x210A             MOVS     R1,#+10
   \   0000002C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000030   0x....             LDR.N    R1,??DataTable13_10
   \   00000032   0x6008             STR      R0,[R1, #+0]
    839              }
    840              OSTmrUpdateCtr   = OSTmrUpdateCnt;
   \                     ??OS_TmrInit_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable13_10
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x....             LDR.N    R1,??DataTable13_11
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    841          
    842              OSTmrTickCtr     = (OS_TICK)0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable13_4
   \   00000040   0x6008             STR      R0,[R1, #+0]
    843          
    844              OSTmrTaskTimeMax = (CPU_TS)0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable13_12
   \   00000046   0x6008             STR      R0,[R1, #+0]
    845          
    846              for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0005             MOVS     R5,R0
   \                     ??OS_TmrInit_2: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable13_13
   \   0000004E   0x8800             LDRH     R0,[R0, #+0]
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD20C             BCS.N    ??OS_TmrInit_3
    847                  p_spoke                = &OSCfg_TmrWheel[i];
   \   00000056   0x....             LDR.N    R0,??DataTable13_14
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000005E   0x0006             MOVS     R6,R0
    848                  p_spoke->NbrEntries    = (OS_OBJ_QTY)0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x80B0             STRH     R0,[R6, #+4]
    849                  p_spoke->NbrEntriesMax = (OS_OBJ_QTY)0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x80F0             STRH     R0,[R6, #+6]
    850                  p_spoke->FirstPtr      = (OS_TMR   *)0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x6030             STR      R0,[R6, #+0]
    851              }
   \   0000006C   0x1C6D             ADDS     R5,R5,#+1
   \   0000006E   0xE7ED             B.N      ??OS_TmrInit_2
    852          
    853                                                                      /* ---------------- CREATE THE TIMER TASK --------------- */
    854              if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
   \                     ??OS_TmrInit_3: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable13_15
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD103             BNE.N    ??OS_TmrInit_4
    855                 *p_err = OS_ERR_TMR_STK_INVALID;
   \   00000078   0xF247 0x3047      MOVW     R0,#+29511
   \   0000007C   0x8020             STRH     R0,[R4, #+0]
    856                  return;
   \   0000007E   0xE02D             B.N      ??OS_TmrInit_5
    857              }
    858          
    859              if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
   \                     ??OS_TmrInit_4: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable13_16
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x....             LDR.N    R1,??DataTable13_17
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xD203             BCS.N    ??OS_TmrInit_6
    860                 *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
   \   0000008C   0xF247 0x3048      MOVW     R0,#+29512
   \   00000090   0x8020             STRH     R0,[R4, #+0]
    861                  return;
   \   00000092   0xE023             B.N      ??OS_TmrInit_5
    862              }
    863          
    864              if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OS_TmrInit_6: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable13_18
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x281F             CMP      R0,#+31
   \   0000009A   0xD303             BCC.N    ??OS_TmrInit_7
    865                 *p_err = OS_ERR_TMR_PRIO_INVALID;
   \   0000009C   0xF247 0x3046      MOVW     R0,#+29510
   \   000000A0   0x8020             STRH     R0,[R4, #+0]
    866                  return;
   \   000000A2   0xE01B             B.N      ??OS_TmrInit_5
    867              }
    868          
    869              OSTaskCreate((OS_TCB     *)&OSTmrTaskTCB,
    870                           (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
    871                           (OS_TASK_PTR )OS_TmrTask,
    872                           (void       *)0,
    873                           (OS_PRIO     )OSCfg_TmrTaskPrio,
    874                           (CPU_STK    *)OSCfg_TmrTaskStkBasePtr,
    875                           (CPU_STK_SIZE)OSCfg_TmrTaskStkLimit,
    876                           (CPU_STK_SIZE)OSCfg_TmrTaskStkSize,
    877                           (OS_MSG_QTY  )0,
    878                           (OS_TICK     )0,
    879                           (void       *)0,
    880                           (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    881                           (OS_ERR     *)p_err);
   \                     ??OS_TmrInit_7: (+1)
   \   000000A4   0x9408             STR      R4,[SP, #+32]
   \   000000A6   0x200B             MOVS     R0,#+11
   \   000000A8   0x9007             STR      R0,[SP, #+28]
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x9006             STR      R0,[SP, #+24]
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x9005             STR      R0,[SP, #+20]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x9004             STR      R0,[SP, #+16]
   \   000000B6   0x....             LDR.N    R0,??DataTable13_16
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x9003             STR      R0,[SP, #+12]
   \   000000BC   0x....             LDR.N    R0,??DataTable13_19
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x9002             STR      R0,[SP, #+8]
   \   000000C2   0x....             LDR.N    R0,??DataTable13_15
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x9001             STR      R0,[SP, #+4]
   \   000000C8   0x....             LDR.N    R0,??DataTable13_18
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x9000             STR      R0,[SP, #+0]
   \   000000CE   0x2300             MOVS     R3,#+0
   \   000000D0   0x.... 0x....      ADR.W    R2,OS_TmrTask
   \   000000D4   0x....             LDR.N    R1,??DataTable13_20
   \   000000D6   0x....             LDR.N    R0,??DataTable13_21
   \   000000D8   0x.... 0x....      BL       OSTaskCreate
    882          }
   \                     ??OS_TmrInit_5: (+1)
   \   000000DC   0xB00A             ADD      SP,SP,#+40
   \   000000DE   0xBD70             POP      {R4-R6,PC}       ;; return
    883          
    884          /*$PAGE*/
    885          /*
    886          ************************************************************************************************************************
    887          *                                         INSERT A TIMER INTO THE TIMER WHEEL
    888          *
    889          * Description: This function is called to insert the timer into the timer wheel.  The timer is always inserted at the
    890          *              beginning of the list.
    891          *
    892          * Arguments  : p_tmr          Is a pointer to the timer to insert.
    893          *              -----
    894          *
    895          *              opt            Is either:
    896          *
    897          *                               OS_OPT_LINK_PERIODIC    Means to re-insert the timer after a period expired
    898          *                               OS_OPT_LINK_DLY         Means to insert    the timer the first time
    899          *
    900          * Returns    : none
    901          *
    902          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    903          ************************************************************************************************************************
    904          */
    905          

   \                                 In section .text, align 2, keep-with-next
    906          void  OS_TmrLink (OS_TMR  *p_tmr,
    907                            OS_OPT   opt)
    908          {
   \                     OS_TmrLink: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    909              OS_TMR_SPOKE     *p_spoke;
    910              OS_TMR           *p_tmr0;
    911              OS_TMR           *p_tmr1;
    912              OS_TMR_SPOKE_IX   spoke;
    913          
    914          
    915          
    916              p_tmr->State = OS_TMR_STATE_RUNNING;
   \   00000002   0x2602             MOVS     R6,#+2
   \   00000004   0xF880 0x602A      STRB     R6,[R0, #+42]
    917              if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
   \   00000008   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD105             BNE.N    ??OS_TmrLink_0
    918                  p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
   \   0000000E   0x6A46             LDR      R6,[R0, #+36]
   \   00000010   0x....             LDR.N    R7,??DataTable13_4
   \   00000012   0x683F             LDR      R7,[R7, #+0]
   \   00000014   0x19BE             ADDS     R6,R7,R6
   \   00000016   0x6186             STR      R6,[R0, #+24]
   \   00000018   0xE00D             B.N      ??OS_TmrLink_1
    919              } else {
    920                  if (p_tmr->Dly == (OS_TICK)0) {
   \                     ??OS_TmrLink_0: (+1)
   \   0000001A   0x6A06             LDR      R6,[R0, #+32]
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD105             BNE.N    ??OS_TmrLink_2
    921                      p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
   \   00000020   0x6A46             LDR      R6,[R0, #+36]
   \   00000022   0x....             LDR.N    R7,??DataTable13_4
   \   00000024   0x683F             LDR      R7,[R7, #+0]
   \   00000026   0x19BE             ADDS     R6,R7,R6
   \   00000028   0x6186             STR      R6,[R0, #+24]
   \   0000002A   0xE004             B.N      ??OS_TmrLink_1
    922                  } else {
    923                      p_tmr->Match = p_tmr->Dly    + OSTmrTickCtr;
   \                     ??OS_TmrLink_2: (+1)
   \   0000002C   0x6A06             LDR      R6,[R0, #+32]
   \   0000002E   0x....             LDR.N    R7,??DataTable13_4
   \   00000030   0x683F             LDR      R7,[R7, #+0]
   \   00000032   0x19BE             ADDS     R6,R7,R6
   \   00000034   0x6186             STR      R6,[R0, #+24]
    924                  }
    925              }
    926              spoke  = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
   \                     ??OS_TmrLink_1: (+1)
   \   00000036   0x6986             LDR      R6,[R0, #+24]
   \   00000038   0x....             LDR.N    R7,??DataTable13_13
   \   0000003A   0x883F             LDRH     R7,[R7, #+0]
   \   0000003C   0xFBB6 0xFCF7      UDIV     R12,R6,R7
   \   00000040   0xFB07 0x661C      MLS      R6,R7,R12,R6
   \   00000044   0x0035             MOVS     R5,R6
    927              p_spoke = &OSCfg_TmrWheel[spoke];
   \   00000046   0x....             LDR.N    R6,??DataTable13_14
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xEB16 0x06C5      ADDS     R6,R6,R5, LSL #+3
   \   0000004E   0x0032             MOVS     R2,R6
    928          
    929              if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
   \   00000050   0x6816             LDR      R6,[R2, #+0]
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD107             BNE.N    ??OS_TmrLink_3
    930                  p_tmr->NextPtr      = (OS_TMR *)0;
   \   00000056   0x2600             MOVS     R6,#+0
   \   00000058   0x6106             STR      R6,[R0, #+16]
    931                  p_tmr->PrevPtr      = (OS_TMR *)0;
   \   0000005A   0x2600             MOVS     R6,#+0
   \   0000005C   0x6146             STR      R6,[R0, #+20]
    932                  p_spoke->FirstPtr   = p_tmr;
   \   0000005E   0x6010             STR      R0,[R2, #+0]
    933                  p_spoke->NbrEntries = 1u;
   \   00000060   0x2601             MOVS     R6,#+1
   \   00000062   0x8096             STRH     R6,[R2, #+4]
   \   00000064   0xE032             B.N      ??OS_TmrLink_4
    934              } else {
    935                  p_tmr->Remain  = p_tmr->Match                       /* Compute remaining time for timer                       */
    936                                 - OSTmrTickCtr;
   \                     ??OS_TmrLink_3: (+1)
   \   00000066   0x6986             LDR      R6,[R0, #+24]
   \   00000068   0x....             LDR.N    R7,??DataTable13_4
   \   0000006A   0x683F             LDR      R7,[R7, #+0]
   \   0000006C   0x1BF6             SUBS     R6,R6,R7
   \   0000006E   0x61C6             STR      R6,[R0, #+28]
    937                  p_tmr1         = p_spoke->FirstPtr;                 /* Point to current first timer in the list               */
   \   00000070   0x6816             LDR      R6,[R2, #+0]
   \   00000072   0x0034             MOVS     R4,R6
    938                  while (p_tmr1 != (OS_TMR *)0) {
   \                     ??OS_TmrLink_5: (+1)
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD026             BEQ.N    ??OS_TmrLink_6
    939                      p_tmr1->Remain = p_tmr1->Match                  /* Compute time remaining of current timer in list        */
    940                                     - OSTmrTickCtr;
   \   00000078   0x69A6             LDR      R6,[R4, #+24]
   \   0000007A   0x....             LDR.N    R7,??DataTable13_4
   \   0000007C   0x683F             LDR      R7,[R7, #+0]
   \   0000007E   0x1BF6             SUBS     R6,R6,R7
   \   00000080   0x61E6             STR      R6,[R4, #+28]
    941                      if (p_tmr->Remain > p_tmr1->Remain) {           /* Do we need to insert AFTER current timer in list?      */
   \   00000082   0x69E6             LDR      R6,[R4, #+28]
   \   00000084   0x69C7             LDR      R7,[R0, #+28]
   \   00000086   0x42BE             CMP      R6,R7
   \   00000088   0xD20B             BCS.N    ??OS_TmrLink_7
    942                          if (p_tmr1->NextPtr  != (OS_TMR *)0) {      /* Yes, are we pointing at the last timer in the list?    */
   \   0000008A   0x6926             LDR      R6,[R4, #+16]
   \   0000008C   0x2E00             CMP      R6,#+0
   \   0000008E   0xD001             BEQ.N    ??OS_TmrLink_8
    943                              p_tmr1            = p_tmr1->NextPtr;    /* No,  Point to next timer in the list                   */
   \   00000090   0x6924             LDR      R4,[R4, #+16]
   \   00000092   0xE7EF             B.N      ??OS_TmrLink_5
    944                          } else {
    945                              p_tmr->NextPtr    = (OS_TMR *)0;
   \                     ??OS_TmrLink_8: (+1)
   \   00000094   0x2600             MOVS     R6,#+0
   \   00000096   0x6106             STR      R6,[R0, #+16]
    946                              p_tmr->PrevPtr    =  p_tmr1;
   \   00000098   0x6144             STR      R4,[R0, #+20]
    947                              p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
   \   0000009A   0x6120             STR      R0,[R4, #+16]
    948                              p_tmr1            = (OS_TMR *)0;        /* Break loop                                             */
   \   0000009C   0x2600             MOVS     R6,#+0
   \   0000009E   0x0034             MOVS     R4,R6
   \   000000A0   0xE7E8             B.N      ??OS_TmrLink_5
    949                          }
    950                      } else {                                        /* Insert before the current timer                        */
    951                          if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
   \                     ??OS_TmrLink_7: (+1)
   \   000000A2   0x6966             LDR      R6,[R4, #+20]
   \   000000A4   0x2E00             CMP      R6,#+0
   \   000000A6   0xD105             BNE.N    ??OS_TmrLink_9
    952                              p_tmr->PrevPtr    = (OS_TMR *)0;
   \   000000A8   0x2600             MOVS     R6,#+0
   \   000000AA   0x6146             STR      R6,[R0, #+20]
    953                              p_tmr->NextPtr    = p_tmr1;
   \   000000AC   0x6104             STR      R4,[R0, #+16]
    954                              p_tmr1->PrevPtr   = p_tmr;
   \   000000AE   0x6160             STR      R0,[R4, #+20]
    955                              p_spoke->FirstPtr = p_tmr;
   \   000000B0   0x6010             STR      R0,[R2, #+0]
   \   000000B2   0xE005             B.N      ??OS_TmrLink_10
    956                          } else {                                    /* Insert in between 2 timers already in the list         */
    957                              p_tmr0            = p_tmr1->PrevPtr;
   \                     ??OS_TmrLink_9: (+1)
   \   000000B4   0x6966             LDR      R6,[R4, #+20]
   \   000000B6   0x0033             MOVS     R3,R6
    958                              p_tmr->PrevPtr    = p_tmr0;
   \   000000B8   0x6143             STR      R3,[R0, #+20]
    959                              p_tmr->NextPtr    = p_tmr1;
   \   000000BA   0x6104             STR      R4,[R0, #+16]
    960                              p_tmr0->NextPtr   = p_tmr;
   \   000000BC   0x6118             STR      R0,[R3, #+16]
    961                              p_tmr1->PrevPtr   = p_tmr;
   \   000000BE   0x6160             STR      R0,[R4, #+20]
    962                          }
    963                          p_tmr1 = (OS_TMR *)0;                       /* Break loop                                             */
   \                     ??OS_TmrLink_10: (+1)
   \   000000C0   0x2600             MOVS     R6,#+0
   \   000000C2   0x0034             MOVS     R4,R6
   \   000000C4   0xE7D6             B.N      ??OS_TmrLink_5
    964                      }
    965                  }
    966                  p_spoke->NbrEntries++;
   \                     ??OS_TmrLink_6: (+1)
   \   000000C6   0x8896             LDRH     R6,[R2, #+4]
   \   000000C8   0x1C76             ADDS     R6,R6,#+1
   \   000000CA   0x8096             STRH     R6,[R2, #+4]
    967              }
    968              if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {     /* Keep track of maximum number of entries in each spoke  */
   \                     ??OS_TmrLink_4: (+1)
   \   000000CC   0x88D6             LDRH     R6,[R2, #+6]
   \   000000CE   0x8897             LDRH     R7,[R2, #+4]
   \   000000D0   0x42BE             CMP      R6,R7
   \   000000D2   0xD201             BCS.N    ??OS_TmrLink_11
    969                  p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
   \   000000D4   0x8896             LDRH     R6,[R2, #+4]
   \   000000D6   0x80D6             STRH     R6,[R2, #+6]
    970              }
    971          }
   \                     ??OS_TmrLink_11: (+1)
   \   000000D8   0xBCF0             POP      {R4-R7}
   \   000000DA   0x4770             BX       LR               ;; return
    972          
    973          /*$PAGE*/
    974          /*
    975          ************************************************************************************************************************
    976          *                                              RESET TIMER LIST PEAK DETECTOR
    977          *
    978          * Description: This function is used to reset the peak detector for the number of entries in each spoke.
    979          *
    980          * Arguments  : void
    981          *
    982          * Returns    : none
    983          *
    984          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    985          ************************************************************************************************************************
    986          */
    987          

   \                                 In section .text, align 2, keep-with-next
    988          void  OS_TmrResetPeak (void)
    989          {
    990              OS_TMR_SPOKE     *p_spoke;
    991              OS_TMR_SPOKE_IX   i;
    992          
    993          
    994          
    995              for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
   \                     OS_TmrResetPeak: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x0011             MOVS     R1,R2
   \                     ??OS_TmrResetPeak_0: (+1)
   \   00000004   0x....             LDR.N    R2,??DataTable13_13
   \   00000006   0x8812             LDRH     R2,[R2, #+0]
   \   00000008   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD208             BCS.N    ??OS_TmrResetPeak_1
    996                  p_spoke                = (OS_TMR_SPOKE *)&OSCfg_TmrWheel[i];
   \   0000000E   0x....             LDR.N    R2,??DataTable13_14
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0xEB12 0x02C1      ADDS     R2,R2,R1, LSL #+3
   \   00000016   0x0010             MOVS     R0,R2
    997                  p_spoke->NbrEntriesMax = (OS_OBJ_QTY    )0u;
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x80C2             STRH     R2,[R0, #+6]
    998              }
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0xE7F1             B.N      ??OS_TmrResetPeak_0
    999          }
   \                     ??OS_TmrResetPeak_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1000          
   1001          /*$PAGE*/
   1002          /*
   1003          ************************************************************************************************************************
   1004          *                                         REMOVE A TIMER FROM THE TIMER WHEEL
   1005          *
   1006          * Description: This function is called to remove the timer from the timer wheel.
   1007          *
   1008          * Arguments  : p_tmr          Is a pointer to the timer to remove.
   1009          *              -----
   1010          *
   1011          * Returns    : none
   1012          *
   1013          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1014          ************************************************************************************************************************
   1015          */
   1016          

   \                                 In section .text, align 2, keep-with-next
   1017          void  OS_TmrUnlink (OS_TMR  *p_tmr)
   1018          {
   \                     OS_TmrUnlink: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1019              OS_TMR_SPOKE    *p_spoke;
   1020              OS_TMR          *p_tmr1;
   1021              OS_TMR          *p_tmr2;
   1022              OS_TMR_SPOKE_IX  spoke;
   1023          
   1024          
   1025          
   1026              spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
   \   00000002   0x6985             LDR      R5,[R0, #+24]
   \   00000004   0x....             LDR.N    R6,??DataTable13_13
   \   00000006   0x8836             LDRH     R6,[R6, #+0]
   \   00000008   0xFBB5 0xF7F6      UDIV     R7,R5,R6
   \   0000000C   0xFB06 0x5517      MLS      R5,R6,R7,R5
   \   00000010   0x002C             MOVS     R4,R5
   1027              p_spoke = &OSCfg_TmrWheel[spoke];
   \   00000012   0x....             LDR.N    R5,??DataTable13_14
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0xEB15 0x05C4      ADDS     R5,R5,R4, LSL #+3
   \   0000001A   0x0029             MOVS     R1,R5
   1028          
   1029              if (p_spoke->FirstPtr == p_tmr) {                       /* See if timer to remove is at the beginning of list     */
   \   0000001C   0x680D             LDR      R5,[R1, #+0]
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xD107             BNE.N    ??OS_TmrUnlink_0
   1030                  p_tmr1            = (OS_TMR *)p_tmr->NextPtr;
   \   00000022   0x6905             LDR      R5,[R0, #+16]
   \   00000024   0x002A             MOVS     R2,R5
   1031                  p_spoke->FirstPtr = (OS_TMR *)p_tmr1;
   \   00000026   0x600A             STR      R2,[R1, #+0]
   1032                  if (p_tmr1 != (OS_TMR *)0) {
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xD00A             BEQ.N    ??OS_TmrUnlink_1
   1033                      p_tmr1->PrevPtr = (OS_TMR *)0;
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0x6155             STR      R5,[R2, #+20]
   \   00000030   0xE007             B.N      ??OS_TmrUnlink_1
   1034                  }
   1035              } else {
   1036                  p_tmr1          = (OS_TMR *)p_tmr->PrevPtr;         /* Remove timer from somewhere in the list                */
   \                     ??OS_TmrUnlink_0: (+1)
   \   00000032   0x6945             LDR      R5,[R0, #+20]
   \   00000034   0x002A             MOVS     R2,R5
   1037                  p_tmr2          = (OS_TMR *)p_tmr->NextPtr;
   \   00000036   0x6905             LDR      R5,[R0, #+16]
   \   00000038   0x002B             MOVS     R3,R5
   1038                  p_tmr1->NextPtr = p_tmr2;
   \   0000003A   0x6113             STR      R3,[R2, #+16]
   1039                  if (p_tmr2 != (OS_TMR *)0) {
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD000             BEQ.N    ??OS_TmrUnlink_1
   1040                      p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
   \   00000040   0x615A             STR      R2,[R3, #+20]
   1041                  }
   1042              }
   1043              p_tmr->State   = OS_TMR_STATE_STOPPED;
   \                     ??OS_TmrUnlink_1: (+1)
   \   00000042   0x2501             MOVS     R5,#+1
   \   00000044   0xF880 0x502A      STRB     R5,[R0, #+42]
   1044              p_tmr->NextPtr = (OS_TMR *)0;
   \   00000048   0x2500             MOVS     R5,#+0
   \   0000004A   0x6105             STR      R5,[R0, #+16]
   1045              p_tmr->PrevPtr = (OS_TMR *)0;
   \   0000004C   0x2500             MOVS     R5,#+0
   \   0000004E   0x6145             STR      R5,[R0, #+20]
   1046              p_spoke->NbrEntries--;
   \   00000050   0x888D             LDRH     R5,[R1, #+4]
   \   00000052   0x1E6D             SUBS     R5,R5,#+1
   \   00000054   0x808D             STRH     R5,[R1, #+4]
   1047          }
   \   00000056   0xBCF0             POP      {R4-R7}
   \   00000058   0x4770             BX       LR               ;; return
   1048          
   1049          /*$PAGE*/
   1050          /*
   1051          ************************************************************************************************************************
   1052          *                                                 TIMER MANAGEMENT TASK
   1053          *
   1054          * Description: This task is created by OS_TmrInit().
   1055          *
   1056          * Arguments  : none
   1057          *
   1058          * Returns    : none
   1059          *
   1060          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1061          ************************************************************************************************************************
   1062          */
   1063          

   \                                 In section .text, align 4, keep-with-next
   1064          void  OS_TmrTask (void  *p_arg)
   1065          {
   \                     OS_TmrTask: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   1066              CPU_BOOLEAN          done;
   1067              OS_ERR               err;
   1068              OS_TMR_CALLBACK_PTR  p_fnct;
   1069              OS_TMR_SPOKE        *p_spoke;
   1070              OS_TMR              *p_tmr;
   1071              OS_TMR              *p_tmr_next;
   1072              OS_TMR_SPOKE_IX      spoke;
   1073              CPU_TS               ts;
   1074              CPU_TS               ts_start;
   1075              CPU_TS               ts_end;
   1076          
   1077          
   1078          
   1079              p_arg = p_arg;                                               /* Not using 'p_arg', prevent compiler warning       */
   1080              while (DEF_ON) {
   1081                  (void)OSTaskSemPend((OS_TICK )0,                         /* Wait for signal indicating time to update tmrs    */
   1082                                      (OS_OPT  )OS_OPT_PEND_BLOCKING,
   1083                                      (CPU_TS *)&ts,
   1084                                      (OS_ERR *)&err);
   \                     ??OS_TmrTask_0: (+1)
   \   00000006   0x466B             MOV      R3,SP
   \   00000008   0xAA02             ADD      R2,SP,#+8
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       OSTaskSemPend
   1085          
   1086                  OSSchedLock(&err);
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       OSSchedLock
   1087                  ts_start = OS_TS_GET();
   \   00000018   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000001C   0x4681             MOV      R9,R0
   1088                  OSTmrTickCtr++;                                          /* Increment the current time                        */
   \   0000001E   0x....             LDR.N    R0,??DataTable13_4
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable13_4
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1089                  spoke    = (OS_TMR_SPOKE_IX)(OSTmrTickCtr % OSCfg_TmrWheelSize);
   \   00000028   0x....             LDR.N    R0,??DataTable13_13
   \   0000002A   0x8800             LDRH     R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable13_4
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x....             LDR.N    R2,??DataTable13_4
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0xFBB2 0xF2F0      UDIV     R2,R2,R0
   \   00000038   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   0000003C   0x4680             MOV      R8,R0
   1090                  p_spoke  = &OSCfg_TmrWheel[spoke];
   \   0000003E   0x....             LDR.N    R0,??DataTable13_14
   \   00000040   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000044   0xEB10 0x00C8      ADDS     R0,R0,R8, LSL #+3
   \   00000048   0x9001             STR      R0,[SP, #+4]
   1091                  p_tmr    = p_spoke->FirstPtr;
   \   0000004A   0x9801             LDR      R0,[SP, #+4]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x0006             MOVS     R6,R0
   1092                  done     = DEF_FALSE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x0004             MOVS     R4,R0
   1093                  while (done == DEF_FALSE) {
   \                     ??OS_TmrTask_1: (+1)
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD126             BNE.N    ??OS_TmrTask_2
   1094                      if (p_tmr != (OS_TMR *)0) {
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD021             BEQ.N    ??OS_TmrTask_3
   1095                          p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
   \   0000005E   0x6930             LDR      R0,[R6, #+16]
   \   00000060   0x0007             MOVS     R7,R0
   1096                                                                           /* ... timer could get unlinked from the wheel.      */
   1097                          if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
   \   00000062   0x....             LDR.N    R0,??DataTable13_4
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x69B1             LDR      R1,[R6, #+24]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD117             BNE.N    ??OS_TmrTask_4
   1098                              OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0x.... 0x....      BL       OS_TmrUnlink
   1099                              if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
   \   00000072   0x8D30             LDRH     R0,[R6, #+40]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD104             BNE.N    ??OS_TmrTask_5
   1100                                  OS_TmrLink(p_tmr,
   1101                                             OS_OPT_LINK_PERIODIC);        /* Recalculate new position of timer in wheel        */
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       OS_TmrLink
   \   00000080   0xE002             B.N      ??OS_TmrTask_6
   1102                              } else {
   1103                                  p_tmr->State = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
   \                     ??OS_TmrTask_5: (+1)
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xF886 0x002A      STRB     R0,[R6, #+42]
   1104                              }
   1105                              p_fnct = p_tmr->CallbackPtr;                 /* Execute callback function if available            */
   \                     ??OS_TmrTask_6: (+1)
   \   00000088   0x68B0             LDR      R0,[R6, #+8]
   \   0000008A   0x0005             MOVS     R5,R0
   1106                              if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD002             BEQ.N    ??OS_TmrTask_7
   1107                                  (*p_fnct)((void *)p_tmr,
   1108                                            p_tmr->CallbackPtrArg);
   \   00000092   0x68F1             LDR      R1,[R6, #+12]
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0x47A8             BLX      R5
   1109                              }
   1110                              p_tmr = p_tmr_next;                          /* See if next timer matches                         */
   \                     ??OS_TmrTask_7: (+1)
   \   00000098   0x003E             MOVS     R6,R7
   \   0000009A   0xE7DB             B.N      ??OS_TmrTask_1
   1111                          } else {
   1112                              done  = DEF_TRUE;
   \                     ??OS_TmrTask_4: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x0004             MOVS     R4,R0
   \   000000A0   0xE7D8             B.N      ??OS_TmrTask_1
   1113                          }
   1114                      } else {
   1115                          done = DEF_TRUE;
   \                     ??OS_TmrTask_3: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x0004             MOVS     R4,R0
   \   000000A6   0xE7D5             B.N      ??OS_TmrTask_1
   1116                      }
   1117                  }
   1118                  ts_end = OS_TS_GET() - ts_start;                         /* Measure execution time of timer task              */
   \                     ??OS_TmrTask_2: (+1)
   \   000000A8   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000AC   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000000B0   0x4682             MOV      R10,R0
   1119                  OSSchedUnlock(&err);
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x.... 0x....      BL       OSSchedUnlock
   1120                  if (OSTmrTaskTimeMax < ts_end) {
   \   000000B8   0x....             LDR.N    R0,??DataTable13_12
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x4550             CMP      R0,R10
   \   000000BE   0xD2A2             BCS.N    ??OS_TmrTask_0
   1121                      OSTmrTaskTimeMax = ts_end;
   \   000000C0   0x....             LDR.N    R0,??DataTable13_12
   \   000000C2   0xF8C0 0xA000      STR      R10,[R0, #+0]
   \   000000C6   0xE79E             B.N      ??OS_TmrTask_0
   1122                  }
   1123              }
   1124          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x20524D54         DC32     0x20524d54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     OSTmrQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     OSTmrTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     OSTmrDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     OSCfg_TmrTaskRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     OSTmrUpdateCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     OSTmrUpdateCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     OSTmrTaskTimeMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     OSCfg_TmrWheelSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     OSCfg_TmrWheel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x........         DC32     OSCfg_TmrTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x........         DC32     OSCfg_TmrTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x........         DC32     OSCfg_TmrTaskPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x........         DC32     OSCfg_TmrTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   0x........         DC32     OSTmrTaskTCB

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x54          DC8 "?TMR"
   \              0x4D 0x52    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x75 0x43          DC8 "uC/OS-III Timer Task"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x49 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x72 0x20    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1125          
   1126          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSTmrCreate
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
        40   -> OS_TmrDbgListAdd
      24   OSTmrDel
        24   -> OSSchedLock
        24   -> OSSchedUnlock
        24   -> OS_TmrClr
        24   -> OS_TmrDbgListRemove
        24   -> OS_TmrUnlink
      24   OSTmrRemainGet
        24   -> OSSchedLock
        24   -> OSSchedUnlock
      24   OSTmrStart
        24   -> OSSchedLock
        24   -> OSSchedUnlock
        24   -> OS_TmrLink
        24   -> OS_TmrUnlink
      24   OSTmrStateGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      32   OSTmrStop
        32   -- Indirect call
        32   -> OSSchedLock
        32   -> OSSchedUnlock
        32   -> OS_TmrUnlink
       0   OS_TmrClr
       0   OS_TmrDbgListAdd
       0   OS_TmrDbgListRemove
      56   OS_TmrInit
        56   -> OSTaskCreate
      16   OS_TmrLink
       0   OS_TmrResetPeak
      48   OS_TmrTask
        48   -- Indirect call
        48   -> CPU_TS_TmrRd
        48   -> OSSchedLock
        48   -> OSSchedUnlock
        48   -> OSTaskSemPend
        48   -> OS_TmrLink
        48   -> OS_TmrUnlink
      16   OS_TmrUnlink


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  ?_0
      24  ?_1
     288  OSTmrCreate
     198  OSTmrDel
     210  OSTmrRemainGet
     182  OSTmrStart
     116  OSTmrStateGet
     262  OSTmrStop
      56  OS_TmrClr
      44  OS_TmrDbgListAdd
      60  OS_TmrDbgListRemove
     224  OS_TmrInit
     220  OS_TmrLink
      34  OS_TmrResetPeak
     200  OS_TmrTask
      90  OS_TmrUnlink

 
    32 bytes in section .rodata
 2 272 bytes in section .text
 
 2 272 bytes of CODE  memory
    32 bytes of CONST memory

Errors: none
Warnings: none
