###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_cpu_c.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_cpu_c.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\os_cpu_c.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-III
      4          *                                          The Real-Time Kernel
      5          *
      6          *
      7          *                           (c) Copyright 2009-2010; Micrium, Inc.; Weston, FL
      8          *                    All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                                           ARM Cortex-M3 Port
     11          *
     12          * File    : OS_CPU_C.C
     13          * Version : V3.02.01
     14          * By      : JJL
     15          *           BAN
     16          *
     17          * LICENSING TERMS:
     18          * ---------------
     19          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     20          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     21          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     22          *           application/product.   We provide ALL the source code for your convenience and to help you 
     23          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     24          *           it commercially without paying a licensing fee.
     25          *
     26          *           Knowledge of the source code may NOT be used to develop a similar product.
     27          *
     28          *           Please help us continue to provide the embedded community with the finest software available.
     29          *           Your honesty is greatly appreciated.
     30          *
     31          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     32          *
     33          * For       : ARMv7M Cortex-M3
     34          * Mode      : Thumb2
     35          * Toolchain : IAR EWARM
     36          *********************************************************************************************************
     37          */
     38          
     39          #define   OS_CPU_GLOBALS
     40          
     41          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     42          const  CPU_CHAR  *os_cpu_c__c = "$Id: $";
     43          #endif
     44          
     45          /*$PAGE*/
     46          /*
     47          *********************************************************************************************************
     48          *                                             INCLUDE FILES
     49          *********************************************************************************************************
     50          */
     51          
     52          #include  <os.h>

   \                                 In section .bss, align 4
   \   __absolute CPU_STK *OS_CPU_ExceptStkBase
   \                     OS_CPU_ExceptStkBase:
   \   00000000                      DS8 4
     53          
     54          /*
     55          *********************************************************************************************************
     56          *                                           IDLE TASK HOOK
     57          *
     58          * Description: This function is called by the idle task.  This hook has been added to allow you to do
     59          *              such things as STOP the CPU to conserve power.
     60          *
     61          * Arguments  : None.
     62          *
     63          * Note(s)    : None.
     64          *********************************************************************************************************
     65          */
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void  OSIdleTaskHook (void)
     68          {
   \                     OSIdleTaskHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     69          #if OS_CFG_APP_HOOKS_EN > 0u
     70              if (OS_AppIdleTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSIdleTaskHook_0
     71                  (*OS_AppIdleTaskHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
     72              }
     73          #endif
     74          }
   \                     ??OSIdleTaskHook_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
     75          
     76          
     77          /*$PAGE*/
     78          /*
     79          *********************************************************************************************************
     80          *                                       OS INITIALIZATION HOOK
     81          *
     82          * Description: This function is called by OSInit() at the beginning of OSInit().
     83          *
     84          * Arguments  : None.
     85          *
     86          * Note(s)    : None.
     87          *********************************************************************************************************
     88          */
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void  OSInitHook (void)
     91          {
     92              OS_CPU_ExceptStkBase = (CPU_STK *)(OSCfg_ISRStkBasePtr + OSCfg_ISRStkSize - 1u);
   \                     OSInitHook: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable10_2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0x....             LDR.N    R1,??DataTable10_3
   \   00000010   0x6008             STR      R0,[R1, #+0]
     93          }
   \   00000012   0x4770             BX       LR               ;; return
     94          
     95          
     96          /*$PAGE*/
     97          /*
     98          *********************************************************************************************************
     99          *                                         STATISTIC TASK HOOK
    100          *
    101          * Description: This function is called every second by uC/OS-III's statistics task.  This allows your
    102          *              application to add functionality to the statistics task.
    103          *
    104          * Arguments  : None.
    105          *
    106          * Note(s)    : None.
    107          *********************************************************************************************************
    108          */
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void  OSStatTaskHook (void)
    111          {
   \                     OSStatTaskHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    112          #if OS_CFG_APP_HOOKS_EN > 0u
    113              if (OS_AppStatTaskHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable10_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSStatTaskHook_0
    114                  (*OS_AppStatTaskHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable10_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    115              }
    116          #endif
    117          }
   \                     ??OSStatTaskHook_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    118          
    119          
    120          /*$PAGE*/
    121          /*
    122          *********************************************************************************************************
    123          *                                          TASK CREATION HOOK
    124          *
    125          * Description: This function is called when a task is created.
    126          *
    127          * Arguments  : p_tcb        Pointer to the task control block of the task being created.
    128          *
    129          * Note(s)    : None.
    130          *********************************************************************************************************
    131          */
    132          

   \                                 In section .text, align 2, keep-with-next
    133          void  OSTaskCreateHook (OS_TCB  *p_tcb)
    134          {
   \                     OSTaskCreateHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    135          #if OS_CFG_APP_HOOKS_EN > 0u
    136              if (OS_AppTaskCreateHookPtr != (OS_APP_HOOK_TCB)0) {
   \   00000004   0x....             LDR.N    R0,??DataTable10_5
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??OSTaskCreateHook_0
    137                  (*OS_AppTaskCreateHookPtr)(p_tcb);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable10_5
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
    138              }
    139          #else
    140              (void)p_tcb;                                            /* Prevent compiler warning                               */
    141          #endif
    142          }
   \                     ??OSTaskCreateHook_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    143          
    144          
    145          /*$PAGE*/
    146          /*
    147          *********************************************************************************************************
    148          *                                           TASK DELETION HOOK
    149          *
    150          * Description: This function is called when a task is deleted.
    151          *
    152          * Arguments  : p_tcb        Pointer to the task control block of the task being deleted.
    153          *
    154          * Note(s)    : None.
    155          *********************************************************************************************************
    156          */
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void  OSTaskDelHook (OS_TCB  *p_tcb)
    159          {
   \                     OSTaskDelHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    160          #if OS_CFG_APP_HOOKS_EN > 0u
    161              if (OS_AppTaskDelHookPtr != (OS_APP_HOOK_TCB)0) {
   \   00000004   0x....             LDR.N    R0,??DataTable10_6
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??OSTaskDelHook_0
    162                  (*OS_AppTaskDelHookPtr)(p_tcb);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable10_6
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
    163              }
    164          #else
    165              (void)p_tcb;                                            /* Prevent compiler warning                               */
    166          #endif
    167          }
   \                     ??OSTaskDelHook_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    168          
    169          
    170          /*$PAGE*/
    171          /*
    172          *********************************************************************************************************
    173          *                                            TASK RETURN HOOK
    174          *
    175          * Description: This function is called if a task accidentally returns.  In other words, a task should
    176          *              either be an infinite loop or delete itself when done.
    177          *
    178          * Arguments  : p_tcb        Pointer to the task control block of the task that is returning.
    179          *
    180          * Note(s)    : None.
    181          *********************************************************************************************************
    182          */
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void  OSTaskReturnHook (OS_TCB  *p_tcb)
    185          {
   \                     OSTaskReturnHook: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    186          #if OS_CFG_APP_HOOKS_EN > 0u
    187              if (OS_AppTaskReturnHookPtr != (OS_APP_HOOK_TCB)0) {
   \   00000004   0x....             LDR.N    R0,??DataTable10_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??OSTaskReturnHook_0
    188                  (*OS_AppTaskReturnHookPtr)(p_tcb);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable10_7
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
    189              }
    190          #else
    191              (void)p_tcb;                                            /* Prevent compiler warning                               */
    192          #endif
    193          }
   \                     ??OSTaskReturnHook_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    194          
    195          
    196          /*$PAGE*/
    197          /*
    198          **********************************************************************************************************
    199          *                                       INITIALIZE A TASK'S STACK
    200          *
    201          * Description: This function is called by OS_Task_Create() or OSTaskCreateExt() to initialize the stack
    202          *              frame of the task being created. This function is highly processor specific.
    203          *
    204          * Arguments  : p_task       Pointer to the task entry point address.
    205          *
    206          *              p_arg        Pointer to a user supplied data area that will be passed to the task
    207          *                               when the task first executes.
    208          *
    209          *              p_stk_base   Pointer to the base address of the stack.
    210          *
    211          *              stk_size     Size of the stack, in number of CPU_STK elements.
    212          *
    213          *              opt          Options used to alter the behavior of OS_Task_StkInit().
    214          *                            (see OS.H for OS_TASK_OPT_xxx).
    215          *
    216          * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
    217          *              been placed on the stack in the proper order.
    218          *
    219          * Note(s)    : 1) Interrupts are enabled when task starts executing.
    220          *
    221          *              2) All tasks run in Thread mode, using process stack.
    222          **********************************************************************************************************
    223          */
    224          

   \                                 In section .text, align 2, keep-with-next
    225          CPU_STK  *OSTaskStkInit (OS_TASK_PTR    p_task,
    226                                   void          *p_arg,
    227                                   CPU_STK       *p_stk_base,
    228                                   CPU_STK       *p_stk_limit,
    229                                   CPU_STK_SIZE   stk_size,
    230                                   OS_OPT         opt)
    231          {
   \                     OSTaskStkInit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x9D03             LDR      R5,[SP, #+12]
    232              CPU_STK  *p_stk;
    233          
    234          
    235              (void)opt;                                              /* Prevent compiler warning                               */
    236          
    237              p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
   \   00000006   0xEB12 0x0685      ADDS     R6,R2,R5, LSL #+2
   \   0000000A   0x0030             MOVS     R0,R6
    238                                                                      /* Registers stacked as if auto-saved on exception        */
    239              *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0xF05F 0x7680      MOVS     R6,#+16777216
   \   00000012   0x6006             STR      R6,[R0, #+0]
    240              *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
   \   00000014   0x1F00             SUBS     R0,R0,#+4
   \   00000016   0x6004             STR      R4,[R0, #+0]
    241              *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
   \   00000018   0x1F00             SUBS     R0,R0,#+4
   \   0000001A   0x....             LDR.N    R6,??DataTable10_8
   \   0000001C   0x6006             STR      R6,[R0, #+0]
    242              *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
   \   0000001E   0x1F00             SUBS     R0,R0,#+4
   \   00000020   0xF05F 0x3612      MOVS     R6,#+303174162
   \   00000024   0x6006             STR      R6,[R0, #+0]
    243              *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
   \   00000026   0x1F00             SUBS     R0,R0,#+4
   \   00000028   0xF05F 0x3603      MOVS     R6,#+50529027
   \   0000002C   0x6006             STR      R6,[R0, #+0]
    244              *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
   \   0000002E   0x1F00             SUBS     R0,R0,#+4
   \   00000030   0xF05F 0x3602      MOVS     R6,#+33686018
   \   00000034   0x6006             STR      R6,[R0, #+0]
    245              *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
   \   00000036   0x1F00             SUBS     R0,R0,#+4
   \   00000038   0x6003             STR      R3,[R0, #+0]
    246              *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
   \   0000003A   0x1F00             SUBS     R0,R0,#+4
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    247                                                                      /* Remaining registers saved on process stack             */
    248              *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
   \   0000003E   0x1F00             SUBS     R0,R0,#+4
   \   00000040   0xF05F 0x3611      MOVS     R6,#+286331153
   \   00000044   0x6006             STR      R6,[R0, #+0]
    249              *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
   \   00000046   0x1F00             SUBS     R0,R0,#+4
   \   00000048   0xF05F 0x3610      MOVS     R6,#+269488144
   \   0000004C   0x6006             STR      R6,[R0, #+0]
    250              *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
   \   0000004E   0x1F00             SUBS     R0,R0,#+4
   \   00000050   0xF05F 0x3609      MOVS     R6,#+151587081
   \   00000054   0x6006             STR      R6,[R0, #+0]
    251              *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
   \   00000056   0x1F00             SUBS     R0,R0,#+4
   \   00000058   0xF05F 0x3608      MOVS     R6,#+134744072
   \   0000005C   0x6006             STR      R6,[R0, #+0]
    252              *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
   \   0000005E   0x1F00             SUBS     R0,R0,#+4
   \   00000060   0xF05F 0x3607      MOVS     R6,#+117901063
   \   00000064   0x6006             STR      R6,[R0, #+0]
    253              *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
   \   00000066   0x1F00             SUBS     R0,R0,#+4
   \   00000068   0xF05F 0x3606      MOVS     R6,#+101058054
   \   0000006C   0x6006             STR      R6,[R0, #+0]
    254              *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
   \   0000006E   0x1F00             SUBS     R0,R0,#+4
   \   00000070   0xF05F 0x3605      MOVS     R6,#+84215045
   \   00000074   0x6006             STR      R6,[R0, #+0]
    255              *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
   \   00000076   0x1F00             SUBS     R0,R0,#+4
   \   00000078   0xF05F 0x3604      MOVS     R6,#+67372036
   \   0000007C   0x6006             STR      R6,[R0, #+0]
    256          
    257              return (p_stk);
   \   0000007E   0xBC70             POP      {R4-R6}
   \   00000080   0x4770             BX       LR               ;; return
    258          }
    259          
    260          
    261          /*$PAGE*/
    262          /*
    263          *********************************************************************************************************
    264          *                                           TASK SWITCH HOOK
    265          *
    266          * Description: This function is called when a task switch is performed.  This allows you to perform other
    267          *              operations during a context switch.
    268          *
    269          * Arguments  : None.
    270          *
    271          * Note(s)    : 1) Interrupts are disabled during this call.
    272          *              2) It is assumed that the global pointer 'OSTCBHighRdyPtr' points to the TCB of the task
    273          *                 that will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCurPtr' points
    274          *                 to the task being switched out (i.e. the preempted task).
    275          *********************************************************************************************************
    276          */
    277          

   \                                 In section .text, align 2, keep-with-next
    278          void  OSTaskSwHook (void)
    279          {
   \                     OSTaskSwHook: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    280          #if OS_CFG_TASK_PROFILE_EN > 0u
    281              CPU_TS  ts;
    282          #endif
    283          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    284              CPU_TS  int_dis_time;
    285          #endif
    286          
    287          
    288          
    289          #if OS_CFG_APP_HOOKS_EN > 0u
    290              if (OS_AppTaskSwHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable10_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSTaskSwHook_0
    291                  (*OS_AppTaskSwHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable10_9
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    292              }
    293          #endif
    294          
    295          #if OS_CFG_TASK_PROFILE_EN > 0u
    296              ts = OS_TS_GET();
   \                     ??OSTaskSwHook_0: (+1)
   \   00000010   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000014   0x0004             MOVS     R4,R0
    297              if (OSTCBCurPtr != OSTCBHighRdyPtr) {
   \   00000016   0x....             LDR.N    R0,??DataTable10_10
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable10_11
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD015             BEQ.N    ??OSTaskSwHook_1
    298                  OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
   \   00000022   0x....             LDR.N    R0,??DataTable10_10
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF8D0 0x0098      LDR      R0,[R0, #+152]
   \   0000002A   0x1A20             SUBS     R0,R4,R0
   \   0000002C   0x....             LDR.N    R1,??DataTable10_10
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0xF8C1 0x0094      STR      R0,[R1, #+148]
    299                  OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
   \   00000034   0x....             LDR.N    R0,??DataTable10_10
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF8D0 0x009C      LDR      R0,[R0, #+156]
   \   0000003C   0x....             LDR.N    R1,??DataTable10_10
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0xF8D1 0x1094      LDR      R1,[R1, #+148]
   \   00000044   0x1808             ADDS     R0,R1,R0
   \   00000046   0x....             LDR.N    R1,??DataTable10_10
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0xF8C1 0x009C      STR      R0,[R1, #+156]
    300              }
    301          
    302              OSTCBHighRdyPtr->CyclesStart = ts;
   \                     ??OSTaskSwHook_1: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable10_11
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF8C0 0x4098      STR      R4,[R0, #+152]
    303          #endif
    304          
    305          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    306              int_dis_time = CPU_IntDisMeasMaxCurReset();             /* Keep track of per-task interrupt disable time          */
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasMaxCurReset
   \   0000005A   0x0005             MOVS     R5,R0
    307              if (OSTCBCurPtr->IntDisTimeMax < int_dis_time) {
   \   0000005C   0x....             LDR.N    R0,??DataTable10_10
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF8D0 0x00B4      LDR      R0,[R0, #+180]
   \   00000064   0x42A8             CMP      R0,R5
   \   00000066   0xD203             BCS.N    ??OSTaskSwHook_2
    308                  OSTCBCurPtr->IntDisTimeMax = int_dis_time;
   \   00000068   0x....             LDR.N    R0,??DataTable10_10
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF8C0 0x50B4      STR      R5,[R0, #+180]
    309              }
    310          #endif
    311          
    312          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    313                                                                      /* Keep track of per-task scheduler lock time             */
    314              if (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur) {
   \                     ??OSTaskSwHook_2: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable10_10
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF8D0 0x00B8      LDR      R0,[R0, #+184]
   \   00000078   0x....             LDR.N    R1,??DataTable10_12
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD205             BCS.N    ??OSTaskSwHook_3
    315                  OSTCBCurPtr->SchedLockTimeMax = OSSchedLockTimeMaxCur;
   \   00000080   0x....             LDR.N    R0,??DataTable10_12
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x....             LDR.N    R1,??DataTable10_10
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0xF8C1 0x00B8      STR      R0,[R1, #+184]
    316              }
    317              OSSchedLockTimeMaxCur = (CPU_TS)0;                      /* Reset the per-task value                               */
   \                     ??OSTaskSwHook_3: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x....             LDR.N    R1,??DataTable10_12
   \   00000090   0x6008             STR      R0,[R1, #+0]
    318          #endif
    319          }
   \   00000092   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    320          
    321          
    322          /*$PAGE*/
    323          /*
    324          *********************************************************************************************************
    325          *                                              TICK HOOK
    326          *
    327          * Description: This function is called every tick.
    328          *
    329          * Arguments  : None.
    330          *
    331          * Note(s)    : 1) This function is assumed to be called from the Tick ISR.
    332          *********************************************************************************************************
    333          */
    334          

   \                                 In section .text, align 2, keep-with-next
    335          void  OSTimeTickHook (void)
    336          {
   \                     OSTimeTickHook: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    337          #if OS_CFG_APP_HOOKS_EN > 0u
    338              if (OS_AppTimeTickHookPtr != (OS_APP_HOOK_VOID)0) {
   \   00000002   0x....             LDR.N    R0,??DataTable10_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??OSTimeTickHook_0
    339                  (*OS_AppTimeTickHookPtr)();
   \   0000000A   0x....             LDR.N    R0,??DataTable10_13
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    340              }
    341          #endif
    342          }
   \                     ??OSTimeTickHook_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    343          
    344          
    345          /*$PAGE*/
    346          /*
    347          *********************************************************************************************************
    348          *                                          SYS TICK HANDLER
    349          *
    350          * Description: Handle the system tick (SysTick) interrupt, which is used to generate the uC/OS-II tick
    351          *              interrupt.
    352          *
    353          * Arguments  : None.
    354          *
    355          * Note(s)    : 1) This function MUST be placed on entry 15 of the Cortex-M3 vector table.
    356          *********************************************************************************************************
    357          */
    358          

   \                                 In section .text, align 2, keep-with-next
    359          void  OS_CPU_SysTickHandler (void)
    360          {
   \                     OS_CPU_SysTickHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    361              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    362          
    363          
    364              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x.... 0x....      BL       CPU_IntDisMeasStart
    365              OSIntNestingCtr++;                                      /* Tell uC/OS-III that we are starting an ISR             */
   \   0000000E   0x....             LDR.N    R0,??DataTable10_14
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable10_14
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    366              CPU_CRITICAL_EXIT();
   \   00000018   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       CPU_SR_Restore
    367          
    368              OSTimeTick();                                           /* Call uC/OS-III's OSTimeTick()                          */
   \   00000022   0x.... 0x....      BL       OSTimeTick
    369          
    370              OSIntExit();                                            /* Tell uC/OS-III that we are leaving the ISR             */
   \   00000026   0x.... 0x....      BL       OSIntExit
    371          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    372          
    373          
    374          /*$PAGE*/
    375          /*
    376          *********************************************************************************************************
    377          *                                         INITIALIZE SYS TICK
    378          *
    379          * Description: Initialize the SysTick.
    380          *
    381          * Arguments  : cnts         Number of SysTick counts between two OS tick interrupts.
    382          *
    383          * Note(s)    : 1) This function MUST be called after OSStart() & after processor initialization.
    384          *********************************************************************************************************
    385          */
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void  OS_CPU_SysTickInit (CPU_INT32U  cnts)
    388          {
    389              CPU_INT32U  prio;
    390          
    391          
    392              CPU_REG_NVIC_ST_RELOAD = cnts - 1u;
   \                     OS_CPU_SysTickInit: (+1)
   \   00000000   0x1E42             SUBS     R2,R0,#+1
   \   00000002   0x....             LDR.N    R3,??DataTable10_15  ;; 0xe000e014
   \   00000004   0x601A             STR      R2,[R3, #+0]
    393          
    394                                                                      /* Set SysTick handler prio.                              */
    395              prio  = CPU_REG_NVIC_SHPRI3;
   \   00000006   0x....             LDR.N    R2,??DataTable10_16  ;; 0xe000ed20
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x0011             MOVS     R1,R2
    396              prio &= DEF_BIT_FIELD(24, 0);
   \   0000000C   0x0209             LSLS     R1,R1,#+8        ;; ZeroExtS R1,R1,#+8,#+8
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
    397              prio |= DEF_BIT_MASK(OS_CPU_CFG_SYSTICK_PRIO, 24);
    398          
    399              CPU_REG_NVIC_SHPRI3 = prio;
   \   00000010   0x....             LDR.N    R2,??DataTable10_16  ;; 0xe000ed20
   \   00000012   0x6011             STR      R1,[R2, #+0]
    400          
    401                                                                      /* Enable timer.                                          */
    402              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_CLKSOURCE |
    403                                      CPU_REG_NVIC_ST_CTRL_ENABLE;
   \   00000014   0x....             LDR.N    R2,??DataTable10_17  ;; 0xe000e010
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0xF052 0x0205      ORRS     R2,R2,#0x5
   \   0000001C   0x....             LDR.N    R3,??DataTable10_17  ;; 0xe000e010
   \   0000001E   0x601A             STR      R2,[R3, #+0]
    404                                                                      /* Enable timer interrupt.                                */
    405              CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_TICKINT;
   \   00000020   0x....             LDR.N    R2,??DataTable10_17  ;; 0xe000e010
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   00000028   0x....             LDR.N    R3,??DataTable10_17  ;; 0xe000e010
   \   0000002A   0x601A             STR      R2,[R3, #+0]
    406          }
   \   0000002C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OS_CPU_ExceptStkBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     OS_TaskReturn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     OSSchedLockTimeMaxCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0xE000E014         DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0xE000ED20         DC32     0xe000ed20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0xE000E010         DC32     0xe000e010
    407          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSIdleTaskHook
         8   -- Indirect call
       0   OSInitHook
       8   OSStatTaskHook
         8   -- Indirect call
       8   OSTaskCreateHook
         8   -- Indirect call
       8   OSTaskDelHook
         8   -- Indirect call
       8   OSTaskReturnHook
         8   -- Indirect call
      12   OSTaskStkInit
      16   OSTaskSwHook
        16   -- Indirect call
        16   -> CPU_IntDisMeasMaxCurReset
        16   -> CPU_TS_TmrRd
       8   OSTimeTickHook
         8   -- Indirect call
       8   OS_CPU_SysTickHandler
         8   -> CPU_IntDisMeasStart
         8   -> CPU_IntDisMeasStop
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIntExit
         8   -> OSTimeTick
       0   OS_CPU_SysTickInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      18  OSIdleTaskHook
      20  OSInitHook
      18  OSStatTaskHook
      22  OSTaskCreateHook
      22  OSTaskDelHook
      22  OSTaskReturnHook
     130  OSTaskStkInit
     148  OSTaskSwHook
      18  OSTimeTickHook
       4  OS_CPU_ExceptStkBase
      44  OS_CPU_SysTickHandler
      46  OS_CPU_SysTickInit

 
   4 bytes in section .bss
 580 bytes in section .text
 
 580 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
