###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_task.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_task.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_task.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_task.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_task.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TASK MANAGEMENT
     10          *
     11          * File    : OS_TASK.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_task__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                CHANGE PRIORITY OF A TASK
     43          *
     44          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     45          *              priority MUST be available.
     46          *
     47          * Arguments  : p_tcb      is the TCB of the tack to change the priority for
     48          *
     49          *              prio_new   is the new priority
     50          *
     51          *              p_err      is a pointer to an error code returned by this function:
     52          *
     53          *                             OS_ERR_NONE                 is the call was successful
     54          *                             OS_ERR_PRIO_INVALID         if the priority you specify is higher that the maximum allowed
     55          *                                                         (i.e. >= (OS_CFG_PRIO_MAX-1))
     56          *                             OS_ERR_STATE_INVALID        if the task is in an invalid state
     57          *                             OS_ERR_TASK_CHANGE_PRIO_ISR if you tried to change the task's priority from an ISR
     58          ************************************************************************************************************************
     59          */
     60          
     61          #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     62          void  OSTaskChangePrio (OS_TCB   *p_tcb,
     63                                  OS_PRIO   prio_new,
     64                                  OS_ERR   *p_err)
     65          {
   \                     OSTaskChangePrio: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     66              CPU_BOOLEAN   self;
     67              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
     68          
     69          
     70          
     71          #ifdef OS_SAFETY_CRITICAL
     72              if (p_err == (OS_ERR *)0) {
     73                  OS_SAFETY_CRITICAL_EXCEPTION();
     74                  return;
     75              }
     76          #endif
     77          
     78          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     79              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSTaskChangePrio_0
     80                 *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
   \   00000018   0xF247 0x1049      MOVW     R0,#+29001
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
     81                  return;
   \   0000001E   0xE0C0             B.N      ??OSTaskChangePrio_1
     82              }
     83          #endif
     84          
     85          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
     86              if (prio_new == 0) {                                    /* Cannot set to IntQueue Task priority                   */
   \                     ??OSTaskChangePrio_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD103             BNE.N    ??OSTaskChangePrio_2
     87                 *p_err = OS_ERR_PRIO_INVALID;
   \   00000026   0xF246 0x2073      MOVW     R0,#+25203
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
     88                  return;
   \   0000002C   0xE0B9             B.N      ??OSTaskChangePrio_1
     89              }
     90          #endif
     91          
     92              if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
   \                     ??OSTaskChangePrio_2: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D1F             CMP      R5,#+31
   \   00000032   0xD303             BCC.N    ??OSTaskChangePrio_3
     93                 *p_err = OS_ERR_PRIO_INVALID;
   \   00000034   0xF246 0x2073      MOVW     R0,#+25203
   \   00000038   0x8030             STRH     R0,[R6, #+0]
     94                  return;
   \   0000003A   0xE0B2             B.N      ??OSTaskChangePrio_1
     95              }
     96          
     97              if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
   \                     ??OSTaskChangePrio_3: (+1)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD110             BNE.N    ??OSTaskChangePrio_4
     98                  CPU_CRITICAL_ENTER();
   \   00000040   0x.... 0x....      BL       CPU_SR_Save
   \   00000044   0x4680             MOV      R8,R0
   \   00000046   0x.... 0x....      BL       CPU_IntDisMeasStart
     99                  p_tcb = OSTCBCurPtr;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x0004             MOVS     R4,R0
    100                  CPU_CRITICAL_EXIT();
   \   00000052   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000056   0x4640             MOV      R0,R8
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    101                  self  = DEF_TRUE;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x0007             MOVS     R7,R0
   \   00000060   0xE001             B.N      ??OSTaskChangePrio_5
    102              } else {
    103                  self  = DEF_FALSE;
   \                     ??OSTaskChangePrio_4: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0007             MOVS     R7,R0
    104              }
    105          
    106              OS_CRITICAL_ENTER();
   \                     ??OSTaskChangePrio_5: (+1)
   \   00000066   0x.... 0x....      BL       CPU_SR_Save
   \   0000006A   0x4680             MOV      R8,R0
   \   0000006C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD101             BNE.N    ??OSTaskChangePrio_6
   \   00000088   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskChangePrio_6: (+1)
   \   0000008C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    107              switch (p_tcb->TaskState) {
   \   00000096   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD00B             BEQ.N    ??OSTaskChangePrio_7
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD020             BEQ.N    ??OSTaskChangePrio_8
   \   000000A2   0xD31C             BCC.N    ??OSTaskChangePrio_9
   \   000000A4   0x2804             CMP      R0,#+4
   \   000000A6   0xD01A             BEQ.N    ??OSTaskChangePrio_9
   \   000000A8   0xD31C             BCC.N    ??OSTaskChangePrio_8
   \   000000AA   0x2806             CMP      R0,#+6
   \   000000AC   0xD01A             BEQ.N    ??OSTaskChangePrio_8
   \   000000AE   0xD316             BCC.N    ??OSTaskChangePrio_9
   \   000000B0   0x2807             CMP      R0,#+7
   \   000000B2   0xD017             BEQ.N    ??OSTaskChangePrio_8
   \   000000B4   0xE02A             B.N      ??OSTaskChangePrio_10
    108                  case OS_TASK_STATE_RDY:
    109                       OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
   \                     ??OSTaskChangePrio_7: (+1)
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       OS_RdyListRemove
    110                       p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
   \   000000BC   0xF884 0x5037      STRB     R5,[R4, #+55]
    111                       OS_PrioInsert(p_tcb->Prio);
   \   000000C0   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   000000C4   0x.... 0x....      BL       OS_PrioInsert
    112                       if (self == DEF_TRUE) {
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x2F01             CMP      R7,#+1
   \   000000CC   0xD103             BNE.N    ??OSTaskChangePrio_11
    113                           OS_RdyListInsertHead(p_tcb);
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       OS_RdyListInsertHead
   \   000000D4   0xE002             B.N      ??OSTaskChangePrio_12
    114                       } else {
    115                           OS_RdyListInsertTail(p_tcb);
   \                     ??OSTaskChangePrio_11: (+1)
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       OS_RdyListInsertTail
    116                       }
    117                       break;
   \                     ??OSTaskChangePrio_12: (+1)
   \   000000DC   0xE045             B.N      ??OSTaskChangePrio_13
    118          
    119                  case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB */
    120                  case OS_TASK_STATE_SUSPENDED:
    121                  case OS_TASK_STATE_DLY_SUSPENDED:
    122                       p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
   \                     ??OSTaskChangePrio_9: (+1)
   \   000000DE   0xF884 0x5037      STRB     R5,[R4, #+55]
    123                       break;
   \   000000E2   0xE042             B.N      ??OSTaskChangePrio_13
    124          
    125                  case OS_TASK_STATE_PEND:
    126                  case OS_TASK_STATE_PEND_TIMEOUT:
    127                  case OS_TASK_STATE_PEND_SUSPENDED:
    128                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    129                       switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
   \                     ??OSTaskChangePrio_8: (+1)
   \   000000E4   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000E8   0x1E40             SUBS     R0,R0,#+1
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xD904             BLS.N    ??OSTaskChangePrio_14
   \   000000EE   0x1E80             SUBS     R0,R0,#+2
   \   000000F0   0x2803             CMP      R0,#+3
   \   000000F2   0xD904             BLS.N    ??OSTaskChangePrio_15
   \   000000F4   0x1F00             SUBS     R0,R0,#+4
   \   000000F6   0xD108             BNE.N    ??OSTaskChangePrio_16
    130                           case OS_TASK_PEND_ON_TASK_Q:               /* Nothing to do except change the priority in the OS_TCB */
    131                           case OS_TASK_PEND_ON_TASK_SEM:
    132                           case OS_TASK_PEND_ON_FLAG:
    133                                p_tcb->Prio = prio_new;               /* Set new task priority                                  */
   \                     ??OSTaskChangePrio_14: (+1)
   \   000000F8   0xF884 0x5037      STRB     R5,[R4, #+55]
    134                                break;
   \   000000FC   0xE005             B.N      ??OSTaskChangePrio_17
    135          
    136                           case OS_TASK_PEND_ON_MUTEX:
    137                           case OS_TASK_PEND_ON_MULTI:
    138                           case OS_TASK_PEND_ON_Q:
    139                           case OS_TASK_PEND_ON_SEM:
    140                                OS_PendListChangePrio(p_tcb,
    141                                                      prio_new);
   \                     ??OSTaskChangePrio_15: (+1)
   \   000000FE   0x0029             MOVS     R1,R5
   \   00000100   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0x.... 0x....      BL       OS_PendListChangePrio
    142                                break;
   \   00000108   0xE7FF             B.N      ??OSTaskChangePrio_17
    143          
    144                           default:
    145                                break;
    146                      }
    147                       break;
   \                     ??OSTaskChangePrio_16: (+1)
   \                     ??OSTaskChangePrio_17: (+1)
   \   0000010A   0xE02E             B.N      ??OSTaskChangePrio_13
    148          
    149                  default:
    150                       OS_CRITICAL_EXIT();
   \                     ??OSTaskChangePrio_10: (+1)
   \   0000010C   0x.... 0x....      BL       CPU_SR_Save
   \   00000110   0x4680             MOV      R8,R0
   \   00000112   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x1E40             SUBS     R0,R0,#+1
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000122   0x7008             STRB     R0,[R1, #+0]
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD114             BNE.N    ??OSTaskChangePrio_18
   \   0000012E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000136   0x8800             LDRH     R0,[R0, #+0]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD007             BEQ.N    ??OSTaskChangePrio_19
   \   0000013C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000140   0x4640             MOV      R0,R8
   \   00000142   0x.... 0x....      BL       CPU_SR_Restore
   \   00000146   0x.... 0x....      BL       OS_Sched0
   \   0000014A   0xE00A             B.N      ??OSTaskChangePrio_20
   \                     ??OSTaskChangePrio_19: (+1)
   \   0000014C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000150   0x4640             MOV      R0,R8
   \   00000152   0x.... 0x....      BL       CPU_SR_Restore
   \   00000156   0xE004             B.N      ??OSTaskChangePrio_20
   \                     ??OSTaskChangePrio_18: (+1)
   \   00000158   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000015C   0x4640             MOV      R0,R8
   \   0000015E   0x.... 0x....      BL       CPU_SR_Restore
    151                      *p_err = OS_ERR_STATE_INVALID;
   \                     ??OSTaskChangePrio_20: (+1)
   \   00000162   0xF646 0x602D      MOVW     R0,#+28205
   \   00000166   0x8030             STRH     R0,[R6, #+0]
    152                       return;
   \   00000168   0xE01B             B.N      ??OSTaskChangePrio_1
    153              }
    154          
    155              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSTaskChangePrio_13: (+1)
   \   0000016A   0x.... 0x....      BL       CPU_SR_Save
   \   0000016E   0x4680             MOV      R8,R0
   \   00000170   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000178   0x7800             LDRB     R0,[R0, #+0]
   \   0000017A   0x1E40             SUBS     R0,R0,#+1
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000180   0x7008             STRB     R0,[R1, #+0]
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000186   0x7800             LDRB     R0,[R0, #+0]
   \   00000188   0x2800             CMP      R0,#+0
   \   0000018A   0xD101             BNE.N    ??OSTaskChangePrio_21
   \   0000018C   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskChangePrio_21: (+1)
   \   00000190   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000194   0x4640             MOV      R0,R8
   \   00000196   0x.... 0x....      BL       CPU_SR_Restore
    156          
    157              OSSched();                                              /* Run highest priority task ready                        */
   \   0000019A   0x.... 0x....      BL       OSSched
    158          
    159             *p_err = OS_ERR_NONE;
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0x8030             STRH     R0,[R6, #+0]
    160          }
   \                     ??OSTaskChangePrio_1: (+1)
   \   000001A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    161          #endif
    162          
    163          /*$PAGE*/
    164          /*
    165          ************************************************************************************************************************
    166          *                                                    CREATE A TASK
    167          *
    168          * Description: This function is used to have uC/OS-III manage the execution of a task.  Tasks can either be created
    169          *              prior to the start of multitasking or by a running task.  A task cannot be created by an ISR.
    170          *
    171          * Arguments  : p_tcb          is a pointer to the task's TCB
    172          *
    173          *              p_name         is a pointer to an ASCII string to provide a name to the task.
    174          *
    175          *              p_task         is a pointer to the task's code
    176          *
    177          *              p_arg          is a pointer to an optional data area which can be used to pass parameters to
    178          *                             the task when the task first executes.  Where the task is concerned it thinks
    179          *                             it was invoked and passed the argument 'p_arg' as follows:
    180          *
    181          *                                 void Task (void *p_arg)
    182          *                                 {
    183          *                                     for (;;) {
    184          *                                         Task code;
    185          *                                     }
    186          *                                 }
    187          *
    188          *              prio           is the task's priority.  A unique priority MUST be assigned to each task and the
    189          *                             lower the number, the higher the priority.
    190          *
    191          *              p_stk_base     is a pointer to the base address of the stack (i.e. low address).
    192          *
    193          *              stk_limit      is the number of stack elements to set as 'watermark' limit for the stack.  This value
    194          *                             represents the number of CPU_STK entries left before the stack is full.  For example,
    195          *                             specifying 10% of the 'stk_size' value indicates that the stack limit will be reached
    196          *                             when the stack reaches 90% full.
    197          *
    198          *              stk_size       is the size of the stack in number of elements.  If CPU_STK is set to CPU_INT08U,
    199          *                             'stk_size' corresponds to the number of bytes available.  If CPU_STK is set to
    200          *                             CPU_INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    201          *                             CPU_STK is set to CPU_INT32U, 'stk_size' contains the number of 32-bit entries
    202          *                             available on the stack.
    203          *
    204          *              q_size         is the maximum number of messages that can be sent to the task
    205          *
    206          *              time_quanta    amount of time (in ticks) for time slice when round-robin between tasks.  Specify 0 to use
    207          *                             the default.
    208          *
    209          *              p_ext          is a pointer to a user supplied memory location which is used as a TCB extension.
    210          *                             For example, this user memory can hold the contents of floating-point registers
    211          *                             during a context switch, the time each task takes to execute, the number of times
    212          *                             the task has been switched-in, etc.
    213          *
    214          *              opt            contains additional information (or options) about the behavior of the task.
    215          *                             See OS_OPT_TASK_xxx in OS.H.  Current choices are:
    216          *
    217          *                                 OS_OPT_TASK_NONE            No option selected
    218          *                                 OS_OPT_TASK_STK_CHK         Stack checking to be allowed for the task
    219          *                                 OS_OPT_TASK_STK_CLR         Clear the stack when the task is created
    220          *                                 OS_OPT_TASK_SAVE_FP         If the CPU has floating-point registers, save them
    221          *                                                             during a context switch.
    222          *                                 OS_OPT_TASK_NO_TLS          If the caller doesn't want or need TLS (Thread Local 
    223          *                                                             Storage) support for the task.  If you do not include this
    224          *                                                             option, TLS will be supported by default.
    225          *
    226          *              p_err          is a pointer to an error code that will be set during this call.  The value pointer
    227          *                             to by 'p_err' can be:
    228          *
    229          *                                 OS_ERR_NONE                    if the function was successful.
    230          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the task after you called
    231          *                                                                   OSSafetyCriticalStart().
    232          *                                 OS_ERR_NAME                    if 'p_name' is a NULL pointer
    233          *                                 OS_ERR_PRIO_INVALID            if the priority you specify is higher that the maximum
    234          *                                                                   allowed (i.e. >= OS_CFG_PRIO_MAX-1) or,
    235          *                                                                if OS_CFG_ISR_POST_DEFERRED_EN is set to 1 and you tried
    236          *                                                                   to use priority 0 which is reserved.
    237          *                                 OS_ERR_STK_INVALID             if you specified a NULL pointer for 'p_stk_base'
    238          *                                 OS_ERR_STK_SIZE_INVALID        if you specified zero for the 'stk_size'
    239          *                                 OS_ERR_STK_LIMIT_INVALID       if you specified a 'stk_limit' greater than or equal
    240          *                                                                   to 'stk_size'
    241          *                                 OS_ERR_TASK_CREATE_ISR         if you tried to create a task from an ISR.
    242          *                                 OS_ERR_TASK_INVALID            if you specified a NULL pointer for 'p_task'
    243          *                                 OS_ERR_TCB_INVALID             if you specified a NULL pointer for 'p_tcb'
    244          *
    245          * Returns    : A pointer to the TCB of the task created.  This pointer must be used as an ID (i.e handle) to the task.
    246          ************************************************************************************************************************
    247          */
    248          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    249          void  OSTaskCreate (OS_TCB        *p_tcb,
    250                              CPU_CHAR      *p_name,
    251                              OS_TASK_PTR    p_task,
    252                              void          *p_arg,
    253                              OS_PRIO        prio,
    254                              CPU_STK       *p_stk_base,
    255                              CPU_STK_SIZE   stk_limit,
    256                              CPU_STK_SIZE   stk_size,
    257                              OS_MSG_QTY     q_size,
    258                              OS_TICK        time_quanta,
    259                              void          *p_ext,
    260                              OS_OPT         opt,
    261                              OS_ERR        *p_err)
    262          {
   \                     OSTaskCreate: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x9D11             LDR      R5,[SP, #+68]
   \   0000000A   0x9E13             LDR      R6,[SP, #+76]
   \   0000000C   0x9F18             LDR      R7,[SP, #+96]
    263              CPU_STK_SIZE   i;
    264          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    265              OS_REG_ID      reg_nbr;
    266          #endif
    267          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    268              OS_TLS_ID      id;
    269          #endif
    270          
    271              CPU_STK       *p_sp;
    272              CPU_STK       *p_stk_limit;
    273              CPU_SR_ALLOC();
   \   0000000E   0xF05F 0x0900      MOVS     R9,#+0
    274          
    275          
    276          
    277          #ifdef OS_SAFETY_CRITICAL
    278              if (p_err == (OS_ERR *)0) {
    279                  OS_SAFETY_CRITICAL_EXCEPTION();
    280                  return;
    281              }
    282          #endif
    283          
    284          #ifdef OS_SAFETY_CRITICAL_IEC61508
    285              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    286                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    287                  return;
    288              }
    289          #endif
    290          
    291          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    292              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD003             BEQ.N    ??OSTaskCreate_0
    293                 *p_err = OS_ERR_TASK_CREATE_ISR;
   \   0000001C   0xF247 0x104A      MOVW     R0,#+29002
   \   00000020   0x8038             STRH     R0,[R7, #+0]
    294                  return;
   \   00000022   0xE119             B.N      ??OSTaskCreate_1
    295              }
    296          #endif
    297          
    298          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    299              if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
   \                     ??OSTaskCreate_0: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD103             BNE.N    ??OSTaskCreate_2
    300                 *p_err = OS_ERR_TCB_INVALID;
   \   00000028   0xF247 0x10AD      MOVW     R0,#+29101
   \   0000002C   0x8038             STRH     R0,[R7, #+0]
    301                  return;
   \   0000002E   0xE113             B.N      ??OSTaskCreate_1
    302              }
    303              if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
   \                     ??OSTaskCreate_2: (+1)
   \   00000030   0x9805             LDR      R0,[SP, #+20]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD103             BNE.N    ??OSTaskCreate_3
    304                 *p_err = OS_ERR_TASK_INVALID;
   \   00000036   0xF247 0x104F      MOVW     R0,#+29007
   \   0000003A   0x8038             STRH     R0,[R7, #+0]
    305                  return;
   \   0000003C   0xE10C             B.N      ??OSTaskCreate_1
    306              }
    307              if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
   \                     ??OSTaskCreate_3: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD103             BNE.N    ??OSTaskCreate_4
    308                 *p_err = OS_ERR_STK_INVALID;
   \   00000042   0xF646 0x602F      MOVW     R0,#+28207
   \   00000046   0x8038             STRH     R0,[R7, #+0]
    309                  return;
   \   00000048   0xE106             B.N      ??OSTaskCreate_1
    310              }
    311              if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
   \                     ??OSTaskCreate_4: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x4286             CMP      R6,R0
   \   00000052   0xD203             BCS.N    ??OSTaskCreate_5
    312                 *p_err = OS_ERR_STK_SIZE_INVALID;
   \   00000054   0xF646 0x6030      MOVW     R0,#+28208
   \   00000058   0x8038             STRH     R0,[R7, #+0]
    313                  return;
   \   0000005A   0xE0FD             B.N      ??OSTaskCreate_1
    314              }
    315              if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
   \                     ??OSTaskCreate_5: (+1)
   \   0000005C   0x9812             LDR      R0,[SP, #+72]
   \   0000005E   0x42B0             CMP      R0,R6
   \   00000060   0xD303             BCC.N    ??OSTaskCreate_6
    316                 *p_err = OS_ERR_STK_LIMIT_INVALID;
   \   00000062   0xF646 0x6031      MOVW     R0,#+28209
   \   00000066   0x8038             STRH     R0,[R7, #+0]
    317                  return;
   \   00000068   0xE0F6             B.N      ??OSTaskCreate_1
    318              }
    319              if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
   \                     ??OSTaskCreate_6: (+1)
   \   0000006A   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \   0000006E   0x2820             CMP      R0,#+32
   \   00000070   0xD303             BCC.N    ??OSTaskCreate_7
    320                 *p_err = OS_ERR_PRIO_INVALID;
   \   00000072   0xF246 0x2073      MOVW     R0,#+25203
   \   00000076   0x8038             STRH     R0,[R7, #+0]
    321                  return;
   \   00000078   0xE0EE             B.N      ??OSTaskCreate_1
    322              }
    323          #endif
    324          
    325          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    326              if (prio == (OS_PRIO)0) {
   \                     ??OSTaskCreate_7: (+1)
   \   0000007A   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD107             BNE.N    ??OSTaskCreate_8
    327                  if (p_tcb != &OSIntQTaskTCB) {
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000086   0x4284             CMP      R4,R0
   \   00000088   0xD003             BEQ.N    ??OSTaskCreate_8
    328                     *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use priority 0                          */
   \   0000008A   0xF246 0x2073      MOVW     R0,#+25203
   \   0000008E   0x8038             STRH     R0,[R7, #+0]
    329                      return;
   \   00000090   0xE0E2             B.N      ??OSTaskCreate_1
    330                  }
    331              }
    332          #endif
    333          
    334              if (prio == (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OSTaskCreate_8: (+1)
   \   00000092   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \   00000096   0x281F             CMP      R0,#+31
   \   00000098   0xD107             BNE.N    ??OSTaskCreate_9
    335                  if (p_tcb != &OSIdleTaskTCB) {
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD003             BEQ.N    ??OSTaskCreate_9
    336                     *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
   \   000000A2   0xF246 0x2073      MOVW     R0,#+25203
   \   000000A6   0x8038             STRH     R0,[R7, #+0]
    337                      return;
   \   000000A8   0xE0D6             B.N      ??OSTaskCreate_1
    338                  }
    339              }
    340          
    341              OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
   \                     ??OSTaskCreate_9: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       OS_TaskInitTCB
    342          
    343             *p_err = OS_ERR_NONE;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x8038             STRH     R0,[R7, #+0]
    344                                                                      /* --------------- CLEAR THE TASK'S STACK --------------- */
    345              if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
   \   000000B4   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \   000000B8   0x07C0             LSLS     R0,R0,#+31
   \   000000BA   0xD510             BPL.N    ??OSTaskCreate_10
    346                  if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
   \   000000BC   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \   000000C0   0x0780             LSLS     R0,R0,#+30
   \   000000C2   0xD50C             BPL.N    ??OSTaskCreate_10
    347                      p_sp = p_stk_base;
   \   000000C4   0x46AA             MOV      R10,R5
    348                      for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x4683             MOV      R11,R0
   \                     ??OSTaskCreate_11: (+1)
   \   000000CA   0x45B3             CMP      R11,R6
   \   000000CC   0xD207             BCS.N    ??OSTaskCreate_10
    349                         *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF8CA 0x0000      STR      R0,[R10, #+0]
    350                          p_sp++;
   \   000000D4   0xF11A 0x0A04      ADDS     R10,R10,#+4
    351                      }
   \   000000D8   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000DC   0xE7F5             B.N      ??OSTaskCreate_11
    352                  }
    353              }
    354                                                                      /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
    355          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    356              p_stk_limit = p_stk_base + stk_limit;
   \                     ??OSTaskCreate_10: (+1)
   \   000000DE   0x9812             LDR      R0,[SP, #+72]
   \   000000E0   0xEB15 0x0080      ADDS     R0,R5,R0, LSL #+2
   \   000000E4   0x9002             STR      R0,[SP, #+8]
    357          #else
    358              p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
    359          #endif
    360          
    361              p_sp = OSTaskStkInit(p_task,
    362                                   p_arg,
    363                                   p_stk_base,
    364                                   p_stk_limit,
    365                                   stk_size,
    366                                   opt);
   \   000000E6   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \   000000EA   0x9001             STR      R0,[SP, #+4]
   \   000000EC   0x9600             STR      R6,[SP, #+0]
   \   000000EE   0x9B02             LDR      R3,[SP, #+8]
   \   000000F0   0x002A             MOVS     R2,R5
   \   000000F2   0x9906             LDR      R1,[SP, #+24]
   \   000000F4   0x9805             LDR      R0,[SP, #+20]
   \   000000F6   0x.... 0x....      BL       OSTaskStkInit
   \   000000FA   0x4682             MOV      R10,R0
    367          
    368                                                                      /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    369              p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
   \   000000FC   0x9805             LDR      R0,[SP, #+20]
   \   000000FE   0x62A0             STR      R0,[R4, #+40]
    370              p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
   \   00000100   0x9806             LDR      R0,[SP, #+24]
   \   00000102   0x62E0             STR      R0,[R4, #+44]
    371          
    372              p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
   \   00000104   0x9804             LDR      R0,[SP, #+16]
   \   00000106   0x6220             STR      R0,[R4, #+32]
    373          
    374              p_tcb->Prio          = prio;                            /* Save the task's priority                               */
   \   00000108   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \   0000010C   0xF884 0x0037      STRB     R0,[R4, #+55]
    375          
    376              p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
   \   00000110   0xF8C4 0xA000      STR      R10,[R4, #+0]
    377              p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
   \   00000114   0x9802             LDR      R0,[SP, #+8]
   \   00000116   0x60A0             STR      R0,[R4, #+8]
    378          
    379              p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
   \   00000118   0x9815             LDR      R0,[SP, #+84]
   \   0000011A   0x6560             STR      R0,[R4, #+84]
    380          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    381              if (time_quanta == (OS_TICK)0) {
   \   0000011C   0x9815             LDR      R0,[SP, #+84]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD104             BNE.N    ??OSTaskCreate_12
    382                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0x65A0             STR      R0,[R4, #+88]
   \   0000012A   0xE001             B.N      ??OSTaskCreate_13
    383              } else {
    384                  p_tcb->TimeQuantaCtr = time_quanta;
   \                     ??OSTaskCreate_12: (+1)
   \   0000012C   0x9815             LDR      R0,[SP, #+84]
   \   0000012E   0x65A0             STR      R0,[R4, #+88]
    385              }
    386          #endif
    387              p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
   \                     ??OSTaskCreate_13: (+1)
   \   00000130   0x9816             LDR      R0,[SP, #+88]
   \   00000132   0x6060             STR      R0,[R4, #+4]
    388              p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
   \   00000134   0x6265             STR      R5,[R4, #+36]
    389              p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
   \   00000136   0x63A6             STR      R6,[R4, #+56]
    390              p_tcb->Opt           = opt;                             /* Save task options                                      */
   \   00000138   0xF8BD 0x005C      LDRH     R0,[SP, #+92]
   \   0000013C   0x87A0             STRH     R0,[R4, #+60]
    391          
    392          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    393              for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x4680             MOV      R8,R0
   \                     ??OSTaskCreate_14: (+1)
   \   00000142   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000146   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000014A   0xD108             BNE.N    ??OSTaskCreate_15
    394                  p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000152   0xEB14 0x0188      ADDS     R1,R4,R8, LSL #+2
   \   00000156   0x67C8             STR      R0,[R1, #+124]
    395              }
   \   00000158   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000015C   0xE7F1             B.N      ??OSTaskCreate_14
    396          #endif
    397          
    398          #if OS_CFG_TASK_Q_EN > 0u
    399              OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
    400                          q_size);
   \                     ??OSTaskCreate_15: (+1)
   \   0000015E   0xF8BD 0x1050      LDRH     R1,[SP, #+80]
   \   00000162   0xF114 0x0064      ADDS     R0,R4,#+100
   \   00000166   0x.... 0x....      BL       OS_MsgQInit
    401          #else
    402              (void)&q_size;
    403          #endif
    404          
    405              OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
   \   0000016A   0x0020             MOVS     R0,R4
   \   0000016C   0x.... 0x....      BL       OSTaskCreateHook
    406          
    407          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    408              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
    409                  p_tcb->TLS_Tbl[id] = (OS_TLS)0;
    410              }
    411              OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
    412          #endif
    413                                                                      /* --------------- ADD TASK TO READY LIST --------------- */
    414              OS_CRITICAL_ENTER();
   \   00000170   0x.... 0x....      BL       CPU_SR_Save
   \   00000174   0x4681             MOV      R9,R0
   \   00000176   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000017E   0x7800             LDRB     R0,[R0, #+0]
   \   00000180   0x1C40             ADDS     R0,R0,#+1
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000186   0x7008             STRB     R0,[R1, #+0]
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000018C   0x7800             LDRB     R0,[R0, #+0]
   \   0000018E   0x2801             CMP      R0,#+1
   \   00000190   0xD101             BNE.N    ??OSTaskCreate_16
   \   00000192   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskCreate_16: (+1)
   \   00000196   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000019A   0x4648             MOV      R0,R9
   \   0000019C   0x.... 0x....      BL       CPU_SR_Restore
    415              OS_PrioInsert(p_tcb->Prio);
   \   000001A0   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   000001A4   0x.... 0x....      BL       OS_PrioInsert
    416              OS_RdyListInsertTail(p_tcb);
   \   000001A8   0x0020             MOVS     R0,R4
   \   000001AA   0x.... 0x....      BL       OS_RdyListInsertTail
    417          
    418          #if OS_CFG_DBG_EN > 0u
    419              OS_TaskDbgListAdd(p_tcb);
   \   000001AE   0x0020             MOVS     R0,R4
   \   000001B0   0x.... 0x....      BL       OS_TaskDbgListAdd
    420          #endif
    421          
    422              OSTaskQty++;                                            /* Increment the #tasks counter                           */
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000001B8   0x8800             LDRH     R0,[R0, #+0]
   \   000001BA   0x1C40             ADDS     R0,R0,#+1
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000001C0   0x8008             STRH     R0,[R1, #+0]
    423          
    424              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000001C6   0x7800             LDRB     R0,[R0, #+0]
   \   000001C8   0x2801             CMP      R0,#+1
   \   000001CA   0xD02B             BEQ.N    ??OSTaskCreate_17
    425                  OS_CRITICAL_EXIT();
   \   000001CC   0x.... 0x....      BL       CPU_SR_Save
   \   000001D0   0x4681             MOV      R9,R0
   \   000001D2   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000001DA   0x7800             LDRB     R0,[R0, #+0]
   \   000001DC   0x1E40             SUBS     R0,R0,#+1
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000001E2   0x7008             STRB     R0,[R1, #+0]
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000001E8   0x7800             LDRB     R0,[R0, #+0]
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD114             BNE.N    ??OSTaskCreate_18
   \   000001EE   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   000001F6   0x8800             LDRH     R0,[R0, #+0]
   \   000001F8   0x2800             CMP      R0,#+0
   \   000001FA   0xD007             BEQ.N    ??OSTaskCreate_19
   \   000001FC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000200   0x4648             MOV      R0,R9
   \   00000202   0x.... 0x....      BL       CPU_SR_Restore
   \   00000206   0x.... 0x....      BL       OS_Sched0
   \   0000020A   0xE00A             B.N      ??OSTaskCreate_20
   \                     ??OSTaskCreate_19: (+1)
   \   0000020C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000210   0x4648             MOV      R0,R9
   \   00000212   0x.... 0x....      BL       CPU_SR_Restore
   \   00000216   0xE004             B.N      ??OSTaskCreate_20
   \                     ??OSTaskCreate_18: (+1)
   \   00000218   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000021C   0x4648             MOV      R0,R9
   \   0000021E   0x.... 0x....      BL       CPU_SR_Restore
    426                  return;
   \                     ??OSTaskCreate_20: (+1)
   \   00000222   0xE019             B.N      ??OSTaskCreate_1
    427              }
    428          
    429              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSTaskCreate_17: (+1)
   \   00000224   0x.... 0x....      BL       CPU_SR_Save
   \   00000228   0x4681             MOV      R9,R0
   \   0000022A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000232   0x7800             LDRB     R0,[R0, #+0]
   \   00000234   0x1E40             SUBS     R0,R0,#+1
   \   00000236   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000023A   0x7008             STRB     R0,[R1, #+0]
   \   0000023C   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000240   0x7800             LDRB     R0,[R0, #+0]
   \   00000242   0x2800             CMP      R0,#+0
   \   00000244   0xD101             BNE.N    ??OSTaskCreate_21
   \   00000246   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskCreate_21: (+1)
   \   0000024A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000024E   0x4648             MOV      R0,R9
   \   00000250   0x.... 0x....      BL       CPU_SR_Restore
    430          
    431              OSSched();
   \   00000254   0x.... 0x....      BL       OSSched
    432          }
   \                     ??OSTaskCreate_1: (+1)
   \   00000258   0xB007             ADD      SP,SP,#+28
   \   0000025A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    433          
    434          /*$PAGE*/
    435          /*
    436          ************************************************************************************************************************
    437          *                                                     DELETE A TASK
    438          *
    439          * Description: This function allows you to delete a task.  The calling task can delete itself by specifying a NULL
    440          *              pointer for 'p_tcb'.  The deleted task is returned to the dormant state and can be re-activated by
    441          *              creating the deleted task again.
    442          *
    443          * Arguments  : p_tcb      is the TCB of the tack to delete
    444          *
    445          *              p_err      is a pointer to an error code returned by this function:
    446          *
    447          *                             OS_ERR_NONE                  if the call is successful
    448          *                             OS_ERR_STATE_INVALID         if the state of the task is invalid
    449          *                             OS_ERR_TASK_DEL_IDLE         if you attempted to delete uC/OS-III's idle task
    450          *                             OS_ERR_TASK_DEL_INVALID      if you attempted to delete uC/OS-III's ISR handler task
    451          *                             OS_ERR_TASK_DEL_ISR          if you tried to delete a task from an ISR
    452          *
    453          * Note(s)    : 1) 'p_err' gets set to OS_ERR_NONE before OSSched() to allow the returned error code to be monitored even
    454          *                 for a task that is deleting itself. In this case, 'p_err' MUST point to a global variable that can be
    455          *                 accessed by another task.
    456          ************************************************************************************************************************
    457          */
    458          
    459          #if OS_CFG_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    460          void  OSTaskDel (OS_TCB  *p_tcb,
    461                           OS_ERR  *p_err)
    462          {
   \                     OSTaskDel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    463              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    464          
    465          
    466          
    467          #ifdef OS_SAFETY_CRITICAL
    468              if (p_err == (OS_ERR *)0) {
    469                  OS_SAFETY_CRITICAL_EXCEPTION();
    470                  return;
    471              }
    472          #endif
    473          
    474          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    475              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTaskDel_0
    476                 *p_err = OS_ERR_TASK_DEL_ISR;
   \   00000012   0xF247 0x104E      MOVW     R0,#+29006
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    477                  return;
   \   00000018   0xE0C8             B.N      ??OSTaskDel_1
    478              }
    479          #endif
    480          
    481              if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
   \                     ??OSTaskDel_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD103             BNE.N    ??OSTaskDel_2
    482                 *p_err = OS_ERR_TASK_DEL_IDLE;
   \   00000022   0xF247 0x104C      MOVW     R0,#+29004
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    483                  return;
   \   00000028   0xE0C0             B.N      ??OSTaskDel_1
    484              }
    485          
    486          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    487              if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
   \                     ??OSTaskDel_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD103             BNE.N    ??OSTaskDel_3
    488                 *p_err = OS_ERR_TASK_DEL_INVALID;
   \   00000032   0xF247 0x104D      MOVW     R0,#+29005
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    489                  return;
   \   00000038   0xE0B8             B.N      ??OSTaskDel_1
    490              }
    491          #endif
    492          
    493              if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
   \                     ??OSTaskDel_3: (+1)
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD10D             BNE.N    ??OSTaskDel_4
    494                  CPU_CRITICAL_ENTER();
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0006             MOVS     R6,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
    495                  p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x0004             MOVS     R4,R0
    496                  CPU_CRITICAL_EXIT();
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000054   0x0030             MOVS     R0,R6
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
    497              }
    498          
    499              OS_CRITICAL_ENTER();
   \                     ??OSTaskDel_4: (+1)
   \   0000005A   0x.... 0x....      BL       CPU_SR_Save
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD101             BNE.N    ??OSTaskDel_5
   \   0000007C   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskDel_5: (+1)
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x0030             MOVS     R0,R6
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    500              switch (p_tcb->TaskState) {
   \   0000008A   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00B             BEQ.N    ??OSTaskDel_6
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD012             BEQ.N    ??OSTaskDel_7
   \   00000096   0xD30D             BCC.N    ??OSTaskDel_8
   \   00000098   0x2804             CMP      R0,#+4
   \   0000009A   0xD00A             BEQ.N    ??OSTaskDel_9
   \   0000009C   0xD30E             BCC.N    ??OSTaskDel_7
   \   0000009E   0x2806             CMP      R0,#+6
   \   000000A0   0xD00C             BEQ.N    ??OSTaskDel_7
   \   000000A2   0xD307             BCC.N    ??OSTaskDel_8
   \   000000A4   0x2807             CMP      R0,#+7
   \   000000A6   0xD009             BEQ.N    ??OSTaskDel_7
   \   000000A8   0xE01E             B.N      ??OSTaskDel_10
    501                  case OS_TASK_STATE_RDY:
    502                       OS_RdyListRemove(p_tcb);
   \                     ??OSTaskDel_6: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       OS_RdyListRemove
    503                       break;
   \   000000B0   0xE049             B.N      ??OSTaskDel_11
    504          
    505                  case OS_TASK_STATE_SUSPENDED:
    506                       break;
   \                     ??OSTaskDel_9: (+1)
   \   000000B2   0xE048             B.N      ??OSTaskDel_11
    507          
    508                  case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
    509                  case OS_TASK_STATE_DLY_SUSPENDED:
    510                       OS_TickListRemove(p_tcb);
   \                     ??OSTaskDel_8: (+1)
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       OS_TickListRemove
    511                       break;
   \   000000BA   0xE044             B.N      ??OSTaskDel_11
    512          
    513                  case OS_TASK_STATE_PEND:
    514                  case OS_TASK_STATE_PEND_SUSPENDED:
    515                  case OS_TASK_STATE_PEND_TIMEOUT:
    516                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    517                       OS_TickListRemove(p_tcb);
   \                     ??OSTaskDel_7: (+1)
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       OS_TickListRemove
    518                       switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
   \   000000C2   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD008             BEQ.N    ??OSTaskDel_12
   \   000000CA   0x1E40             SUBS     R0,R0,#+1
   \   000000CC   0xD007             BEQ.N    ??OSTaskDel_13
   \   000000CE   0x1E40             SUBS     R0,R0,#+1
   \   000000D0   0xD004             BEQ.N    ??OSTaskDel_12
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   \   000000D4   0x2803             CMP      R0,#+3
   \   000000D6   0xD902             BLS.N    ??OSTaskDel_13
   \   000000D8   0x1F00             SUBS     R0,R0,#+4
   \   000000DA   0xD104             BNE.N    ??OSTaskDel_14
    519                           case OS_TASK_PEND_ON_NOTHING:
    520                           case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
    521                           case OS_TASK_PEND_ON_TASK_SEM:
    522                                break;
   \                     ??OSTaskDel_12: (+1)
   \   000000DC   0xE003             B.N      ??OSTaskDel_15
    523          
    524                           case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
    525                           case OS_TASK_PEND_ON_MULTI:
    526                           case OS_TASK_PEND_ON_MUTEX:
    527                           case OS_TASK_PEND_ON_Q:
    528                           case OS_TASK_PEND_ON_SEM:
    529                                OS_PendListRemove(p_tcb);
   \                     ??OSTaskDel_13: (+1)
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       OS_PendListRemove
    530                                break;
   \   000000E4   0xE7FF             B.N      ??OSTaskDel_15
    531          
    532                           default:
    533                                break;
    534                       }
    535                       break;
   \                     ??OSTaskDel_14: (+1)
   \                     ??OSTaskDel_15: (+1)
   \   000000E6   0xE02E             B.N      ??OSTaskDel_11
    536          
    537                  default:
    538                      OS_CRITICAL_EXIT();
   \                     ??OSTaskDel_10: (+1)
   \   000000E8   0x.... 0x....      BL       CPU_SR_Save
   \   000000EC   0x0006             MOVS     R6,R0
   \   000000EE   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x1E40             SUBS     R0,R0,#+1
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD114             BNE.N    ??OSTaskDel_16
   \   0000010A   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000112   0x8800             LDRH     R0,[R0, #+0]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD007             BEQ.N    ??OSTaskDel_17
   \   00000118   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011C   0x0030             MOVS     R0,R6
   \   0000011E   0x.... 0x....      BL       CPU_SR_Restore
   \   00000122   0x.... 0x....      BL       OS_Sched0
   \   00000126   0xE00A             B.N      ??OSTaskDel_18
   \                     ??OSTaskDel_17: (+1)
   \   00000128   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012C   0x0030             MOVS     R0,R6
   \   0000012E   0x.... 0x....      BL       CPU_SR_Restore
   \   00000132   0xE004             B.N      ??OSTaskDel_18
   \                     ??OSTaskDel_16: (+1)
   \   00000134   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000138   0x0030             MOVS     R0,R6
   \   0000013A   0x.... 0x....      BL       CPU_SR_Restore
    539                     *p_err = OS_ERR_STATE_INVALID;
   \                     ??OSTaskDel_18: (+1)
   \   0000013E   0xF646 0x602D      MOVW     R0,#+28205
   \   00000142   0x8028             STRH     R0,[R5, #+0]
    540                      return;
   \   00000144   0xE032             B.N      ??OSTaskDel_1
    541              }
    542          
    543          #if OS_CFG_TASK_Q_EN > 0u
    544              (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
   \                     ??OSTaskDel_11: (+1)
   \   00000146   0xF114 0x0064      ADDS     R0,R4,#+100
   \   0000014A   0x.... 0x....      BL       OS_MsgQFreeAll
    545          #endif
    546          
    547              OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
   \   0000014E   0x0020             MOVS     R0,R4
   \   00000150   0x.... 0x....      BL       OSTaskDelHook
    548          
    549          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    550              OS_TLS_TaskDel(p_tcb);                                  /* Call TLS hook                                          */
    551          #endif
    552          
    553          #if OS_CFG_DBG_EN > 0u
    554              OS_TaskDbgListRemove(p_tcb);
   \   00000154   0x0020             MOVS     R0,R4
   \   00000156   0x.... 0x....      BL       OS_TaskDbgListRemove
    555          #endif
    556              OSTaskQty--;                                            /* One less task being managed                            */
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000015E   0x8800             LDRH     R0,[R0, #+0]
   \   00000160   0x1E40             SUBS     R0,R0,#+1
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000166   0x8008             STRH     R0,[R1, #+0]
    557          
    558              OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
   \   00000168   0x0020             MOVS     R0,R4
   \   0000016A   0x.... 0x....      BL       OS_TaskInitTCB
    559              p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
   \   0000016E   0x20FF             MOVS     R0,#+255
   \   00000170   0xF884 0x0036      STRB     R0,[R4, #+54]
    560          
    561              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000174   0x.... 0x....      BL       CPU_SR_Save
   \   00000178   0x0006             MOVS     R6,R0
   \   0000017A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000182   0x7800             LDRB     R0,[R0, #+0]
   \   00000184   0x1E40             SUBS     R0,R0,#+1
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000018A   0x7008             STRB     R0,[R1, #+0]
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000190   0x7800             LDRB     R0,[R0, #+0]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD101             BNE.N    ??OSTaskDel_19
   \   00000196   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskDel_19: (+1)
   \   0000019A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000019E   0x0030             MOVS     R0,R6
   \   000001A0   0x.... 0x....      BL       CPU_SR_Restore
    562          
    563             *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0x8028             STRH     R0,[R5, #+0]
    564          
    565              OSSched();                                              /* Find new highest priority task                         */
   \   000001A8   0x.... 0x....      BL       OSSched
    566          }
   \                     ??OSTaskDel_1: (+1)
   \   000001AC   0xBD70             POP      {R4-R6,PC}       ;; return
    567          #endif
    568          
    569          /*$PAGE*/
    570          /*
    571          ************************************************************************************************************************
    572          *                                                    FLUSH TASK's QUEUE
    573          *
    574          * Description: This function is used to flush the task's internal message queue.
    575          *
    576          * Arguments  : p_tcb       is a pointer to the task's OS_TCB.  Specifying a NULL pointer indicates that you wish to
    577          *                          flush the message queue of the calling task.
    578          *
    579          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    580          *
    581          *                              OS_ERR_NONE           upon success
    582          *                              OS_ERR_FLUSH_ISR      if you called this function from an ISR
    583          *
    584          * Returns     : The number of entries freed from the queue
    585          *
    586          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    587          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    588          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    589          *                  likely, need to be de-allocated (i.e. freed).
    590          ************************************************************************************************************************
    591          */
    592          
    593          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    594          OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
    595                                    OS_ERR  *p_err)
    596          {
   \                     OSTaskQFlush: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    597              OS_MSG_QTY  entries;
    598              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    599          
    600          
    601          
    602          #ifdef OS_SAFETY_CRITICAL
    603              if (p_err == (OS_ERR *)0) {
    604                  OS_SAFETY_CRITICAL_EXCEPTION();
    605                  return ((OS_MSG_QTY)0);
    606              }
    607          #endif
    608          
    609          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    610              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskQFlush_0
    611                 *p_err = OS_ERR_FLUSH_ISR;
   \   00000012   0xF44F 0x506C      MOV      R0,#+15104
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    612                  return ((OS_MSG_QTY)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE05B             B.N      ??OSTaskQFlush_1
    613              }
    614          #endif
    615          
    616              if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
   \                     ??OSTaskQFlush_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD10D             BNE.N    ??OSTaskQFlush_2
    617                  CPU_CRITICAL_ENTER();
   \   00000020   0x.... 0x....      BL       CPU_SR_Save
   \   00000024   0x0007             MOVS     R7,R0
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStart
    618                  p_tcb = OSTCBCurPtr;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0004             MOVS     R4,R0
    619                  CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
    620              }
    621          
    622              OS_CRITICAL_ENTER();
   \                     ??OSTaskQFlush_2: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x0007             MOVS     R7,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000052   0x7008             STRB     R0,[R1, #+0]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD101             BNE.N    ??OSTaskQFlush_3
   \   0000005E   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskQFlush_3: (+1)
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    623              entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
   \   0000006C   0xF114 0x0064      ADDS     R0,R4,#+100
   \   00000070   0x.... 0x....      BL       OS_MsgQFreeAll
   \   00000074   0x0006             MOVS     R6,R0
    624              OS_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_SR_Save
   \   0000007A   0x0007             MOVS     R7,R0
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD114             BNE.N    ??OSTaskQFlush_4
   \   00000098   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   000000A0   0x8800             LDRH     R0,[R0, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD007             BEQ.N    ??OSTaskQFlush_5
   \   000000A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AA   0x0038             MOVS     R0,R7
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
   \   000000B0   0x.... 0x....      BL       OS_Sched0
   \   000000B4   0xE00A             B.N      ??OSTaskQFlush_6
   \                     ??OSTaskQFlush_5: (+1)
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
   \   000000C0   0xE004             B.N      ??OSTaskQFlush_6
   \                     ??OSTaskQFlush_4: (+1)
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    625             *p_err   = OS_ERR_NONE;
   \                     ??OSTaskQFlush_6: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x8028             STRH     R0,[R5, #+0]
    626              return (entries);
   \   000000D0   0x0030             MOVS     R0,R6
   \   000000D2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSTaskQFlush_1: (+1)
   \   000000D4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    627          }
    628          #endif
    629          
    630          /*$PAGE*/
    631          /*
    632          ************************************************************************************************************************
    633          *                                                  WAIT FOR A MESSAGE
    634          *
    635          * Description: This function causes the current task to wait for a message to be posted to it.
    636          *
    637          * Arguments  : timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    638          *                            message to arrive up to the amount of time specified by this argument.
    639          *                            If you specify 0, however, your task will wait forever or, until a message arrives.
    640          *
    641          *              opt           determines whether the user wants to block if the task's queue is empty or not:
    642          *
    643          *                                OS_OPT_PEND_BLOCKING
    644          *                                OS_OPT_PEND_NON_BLOCKING
    645          *
    646          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    647          *
    648          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    649          *                            received.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
    650          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
    651          *                            need the timestamp.
    652          *
    653          *              p_err         is a pointer to where an error message will be deposited.  Possible error
    654          *                            messages are:
    655          *
    656          *                                OS_ERR_NONE               The call was successful and your task received a message.
    657          *                                OS_ERR_PEND_ABORT
    658          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    659          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    660          *                                OS_ERR_Q_EMPTY
    661          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
    662          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    663          *                                                          would lead to a suspension.
    664          *
    665          * Returns    : A pointer to the message received or a NULL pointer upon error.
    666          *
    667          * Note(s)    : 1) It is possible to receive NULL pointers when there are no errors.
    668          ************************************************************************************************************************
    669          */
    670          
    671          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    672          void  *OSTaskQPend (OS_TICK       timeout,
    673                              OS_OPT        opt,
    674                              OS_MSG_SIZE  *p_msg_size,
    675                              CPU_TS       *p_ts,
    676                              OS_ERR       *p_err)
    677          {
   \                     OSTaskQPend: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    678              OS_MSG_Q     *p_msg_q;
    679              void         *p_void;
    680              CPU_SR_ALLOC();
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
    681          
    682          
    683          
    684          #ifdef OS_SAFETY_CRITICAL
    685              if (p_err == (OS_ERR *)0) {
    686                  OS_SAFETY_CRITICAL_EXCEPTION();
    687                  return ((void *)0);
    688              }
    689          #endif
    690          
    691          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    692              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??OSTaskQPend_0
    693                 *p_err = OS_ERR_PEND_ISR;
   \   0000001E   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000022   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    694                  return ((void *)0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE0FD             B.N      ??OSTaskQPend_1
    695              }
    696          #endif
    697          
    698          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    699              if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
   \                     ??OSTaskQPend_0: (+1)
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD105             BNE.N    ??OSTaskQPend_2
    700                 *p_err = OS_ERR_PTR_INVALID;
   \   0000002E   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000032   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    701                  return ((void *)0);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE0F5             B.N      ??OSTaskQPend_1
    702              }
    703              switch (opt) {                                          /* User must supply a valid option                        */
   \                     ??OSTaskQPend_2: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD002             BEQ.N    ??OSTaskQPend_3
   \   00000042   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000046   0xD102             BNE.N    ??OSTaskQPend_4
    704                  case OS_OPT_PEND_BLOCKING:
    705                  case OS_OPT_PEND_NON_BLOCKING:
    706                       break;
    707          
    708                  default:
    709                      *p_err = OS_ERR_OPT_INVALID;
    710                       return ((void *)0);
    711              }
    712          #endif
    713          
    714              if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskQPend_3: (+1)
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD008             BEQ.N    ??OSTaskQPend_5
   \   0000004C   0xE005             B.N      ??OSTaskQPend_6
   \                     ??OSTaskQPend_4: (+1)
   \   0000004E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000052   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE0E5             B.N      ??OSTaskQPend_1
    715                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \                     ??OSTaskQPend_6: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6038             STR      R0,[R7, #+0]
    716              }
    717          
    718              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPend_5: (+1)
   \   0000005E   0x.... 0x....      BL       CPU_SR_Save
   \   00000062   0x4682             MOV      R10,R0
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStart
    719              p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x3064             ADDS     R0,R0,#+100
   \   00000070   0x4681             MOV      R9,R0
    720              p_void  = OS_MsgQGet(p_msg_q,
    721                                   p_msg_size,
    722                                   p_ts,
    723                                   p_err);
   \   00000072   0x4643             MOV      R3,R8
   \   00000074   0x003A             MOVS     R2,R7
   \   00000076   0x0031             MOVS     R1,R6
   \   00000078   0x4648             MOV      R0,R9
   \   0000007A   0x.... 0x....      BL       OS_MsgQGet
   \   0000007E   0x4683             MOV      R11,R0
    724              if (*p_err == OS_ERR_NONE) {
   \   00000080   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD122             BNE.N    ??OSTaskQPend_7
    725          #if OS_CFG_TASK_PROFILE_EN > 0u
    726                  if (p_ts != (CPU_TS *)0) {
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD019             BEQ.N    ??OSTaskQPend_8
    727                      OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
   \   0000008C   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000090   0x6839             LDR      R1,[R7, #+0]
   \   00000092   0x1A40             SUBS     R0,R0,R1
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0x6748             STR      R0,[R1, #+116]
    728                      if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x6F80             LDR      R0,[R0, #+120]
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0x6F49             LDR      R1,[R1, #+116]
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xD207             BCS.N    ??OSTaskQPend_8
    729                          OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x6F40             LDR      R0,[R0, #+116]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000BC   0x6809             LDR      R1,[R1, #+0]
   \   000000BE   0x6788             STR      R0,[R1, #+120]
    730                      }
    731                  }
    732          #endif
    733                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPend_8: (+1)
   \   000000C0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C4   0x4650             MOV      R0,R10
   \   000000C6   0x.... 0x....      BL       CPU_SR_Restore
    734                  return (p_void);                                    /* Yes, Return oldest message received                    */
   \   000000CA   0x4658             MOV      R0,R11
   \   000000CC   0xE0AB             B.N      ??OSTaskQPend_1
    735              }
    736          
    737              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSTaskQPend_7: (+1)
   \   000000CE   0x0428             LSLS     R0,R5,#+16
   \   000000D0   0xD50A             BPL.N    ??OSTaskQPend_9
    738                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \   000000D2   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000D6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    739                  CPU_CRITICAL_EXIT();
   \   000000DA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000DE   0x4650             MOV      R0,R10
   \   000000E0   0x.... 0x....      BL       CPU_SR_Restore
    740                  return ((void *)0);
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xE09E             B.N      ??OSTaskQPend_1
    741              } else {                                                /* Yes                                                    */
    742                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
   \                     ??OSTaskQPend_9: (+1)
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable11
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD00A             BEQ.N    ??OSTaskQPend_10
    743                      CPU_CRITICAL_EXIT();
   \   000000F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
    744                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000FC   0xF646 0x5063      MOVW     R0,#+28003
   \   00000100   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    745                      return ((void *)0);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xE08E             B.N      ??OSTaskQPend_1
    746                  }
    747              }
    748                                                                      /* Lock the scheduler/re-enable interrupts                */
    749              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTaskQPend_10: (+1)
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x1C40             ADDS     R0,R0,#+1
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000114   0x7008             STRB     R0,[R1, #+0]
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x2801             CMP      R0,#+1
   \   0000011E   0xD101             BNE.N    ??OSTaskQPend_11
   \   00000120   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskQPend_11: (+1)
   \   00000124   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000128   0x4650             MOV      R0,R10
   \   0000012A   0x.... 0x....      BL       CPU_SR_Restore
    750              OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
    751                      (OS_PEND_OBJ  *)0,
    752                      (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
    753                      (OS_TICK       )timeout);
   \   0000012E   0x0023             MOVS     R3,R4
   \   00000130   0x2202             MOVS     R2,#+2
   \   00000132   0x2100             MOVS     R1,#+0
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x.... 0x....      BL       OS_Pend
    754              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000013A   0x.... 0x....      BL       CPU_SR_Save
   \   0000013E   0x4682             MOV      R10,R0
   \   00000140   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
   \   0000014A   0x1E40             SUBS     R0,R0,#+1
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000150   0x7008             STRB     R0,[R1, #+0]
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000156   0x7800             LDRB     R0,[R0, #+0]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD101             BNE.N    ??OSTaskQPend_12
   \   0000015C   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskQPend_12: (+1)
   \   00000160   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000164   0x4650             MOV      R0,R10
   \   00000166   0x.... 0x....      BL       CPU_SR_Restore
    755          
    756              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   0000016A   0x.... 0x....      BL       OSSched
    757          
    758              CPU_CRITICAL_ENTER();
   \   0000016E   0x.... 0x....      BL       CPU_SR_Save
   \   00000172   0x4682             MOV      R10,R0
   \   00000174   0x.... 0x....      BL       CPU_IntDisMeasStart
    759              switch (OSTCBCurPtr->PendStatus) {
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000182   0x2800             CMP      R0,#+0
   \   00000184   0xD002             BEQ.N    ??OSTaskQPend_13
   \   00000186   0x2801             CMP      R0,#+1
   \   00000188   0xD02C             BEQ.N    ??OSTaskQPend_14
   \   0000018A   0xE038             B.N      ??OSTaskQPend_15
    760                  case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
    761                       p_void      = OSTCBCurPtr->MsgPtr;
   \                     ??OSTaskQPend_13: (+1)
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000190   0x6800             LDR      R0,[R0, #+0]
   \   00000192   0x6DC0             LDR      R0,[R0, #+92]
   \   00000194   0x4683             MOV      R11,R0
    762                      *p_msg_size  = OSTCBCurPtr->MsgSize;
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0xF8B0 0x0060      LDRH     R0,[R0, #+96]
   \   000001A0   0x8030             STRH     R0,[R6, #+0]
    763                       if (p_ts != (CPU_TS *)0) {
   \   000001A2   0x2F00             CMP      R7,#+0
   \   000001A4   0xD01A             BEQ.N    ??OSTaskQPend_16
    764                          *p_ts  = OSTCBCurPtr->TS;
   \   000001A6   0x....             LDR.N    R0,??DataTable10_1
   \   000001A8   0x6800             LDR      R0,[R0, #+0]
   \   000001AA   0x6C00             LDR      R0,[R0, #+64]
   \   000001AC   0x6038             STR      R0,[R7, #+0]
    765          #if OS_CFG_TASK_PROFILE_EN > 0u
    766                          OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   \   000001AE   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000001B2   0x....             LDR.N    R1,??DataTable10_1
   \   000001B4   0x6809             LDR      R1,[R1, #+0]
   \   000001B6   0x6C09             LDR      R1,[R1, #+64]
   \   000001B8   0x1A40             SUBS     R0,R0,R1
   \   000001BA   0x....             LDR.N    R1,??DataTable10_1
   \   000001BC   0x6809             LDR      R1,[R1, #+0]
   \   000001BE   0x6748             STR      R0,[R1, #+116]
    767                          if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
   \   000001C0   0x....             LDR.N    R0,??DataTable10_1
   \   000001C2   0x6800             LDR      R0,[R0, #+0]
   \   000001C4   0x6F80             LDR      R0,[R0, #+120]
   \   000001C6   0x....             LDR.N    R1,??DataTable10_1
   \   000001C8   0x6809             LDR      R1,[R1, #+0]
   \   000001CA   0x6F49             LDR      R1,[R1, #+116]
   \   000001CC   0x4288             CMP      R0,R1
   \   000001CE   0xD205             BCS.N    ??OSTaskQPend_16
    768                              OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
   \   000001D0   0x....             LDR.N    R0,??DataTable10_1
   \   000001D2   0x6800             LDR      R0,[R0, #+0]
   \   000001D4   0x6F40             LDR      R0,[R0, #+116]
   \   000001D6   0x....             LDR.N    R1,??DataTable10_1
   \   000001D8   0x6809             LDR      R1,[R1, #+0]
   \   000001DA   0x6788             STR      R0,[R1, #+120]
    769                          }
    770          #endif
    771                       }
    772                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskQPend_16: (+1)
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    773                       break;
   \   000001E2   0xE01A             B.N      ??OSTaskQPend_17
    774          
    775                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    776                       p_void     = (void      *)0;
   \                     ??OSTaskQPend_14: (+1)
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x4683             MOV      R11,R0
    777                      *p_msg_size = (OS_MSG_SIZE)0;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x8030             STRH     R0,[R6, #+0]
    778                       if (p_ts  != (CPU_TS *)0) {
   \   000001EC   0x2F00             CMP      R7,#+0
   \   000001EE   0xD001             BEQ.N    ??OSTaskQPend_18
    779                          *p_ts   = (CPU_TS  )0;
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0x6038             STR      R0,[R7, #+0]
    780                       }
    781                      *p_err      =  OS_ERR_PEND_ABORT;
   \                     ??OSTaskQPend_18: (+1)
   \   000001F4   0xF246 0x10A9      MOVW     R0,#+25001
   \   000001F8   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    782                       break;
   \   000001FC   0xE00D             B.N      ??OSTaskQPend_17
    783          
    784                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
    785                  default:
    786                       p_void     = (void      *)0;
   \                     ??OSTaskQPend_15: (+1)
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x4683             MOV      R11,R0
    787                      *p_msg_size = (OS_MSG_SIZE)0;
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x8030             STRH     R0,[R6, #+0]
    788                       if (p_ts  != (CPU_TS *)0) {
   \   00000206   0x2F00             CMP      R7,#+0
   \   00000208   0xD003             BEQ.N    ??OSTaskQPend_19
    789                          *p_ts   =  OSTCBCurPtr->TS;
   \   0000020A   0x....             LDR.N    R0,??DataTable10_1
   \   0000020C   0x6800             LDR      R0,[R0, #+0]
   \   0000020E   0x6C00             LDR      R0,[R0, #+64]
   \   00000210   0x6038             STR      R0,[R7, #+0]
    790                       }
    791                      *p_err      =  OS_ERR_TIMEOUT;
   \                     ??OSTaskQPend_19: (+1)
   \   00000212   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000216   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    792                       break;
    793              }
    794              CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPend_17: (+1)
   \   0000021A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000021E   0x4650             MOV      R0,R10
   \   00000220   0x.... 0x....      BL       CPU_SR_Restore
    795              return (p_void);                                        /* Return received message                                */
   \   00000224   0x4658             MOV      R0,R11
   \                     ??OSTaskQPend_1: (+1)
   \   00000226   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    796          }
    797          #endif
    798          
    799          /*$PAGE*/
    800          /*
    801          ************************************************************************************************************************
    802          *                                              ABORT WAITING FOR A MESSAGE
    803          *
    804          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
    805          *              for a message, rather than to normally post the message to the task via OSTaskQPost().
    806          *
    807          * Arguments  : p_tcb     is a pointer to the task to pend abort
    808          *
    809          *              opt       provides options for this function:
    810          *
    811          *                            OS_OPT_POST_NONE         No option specified
    812          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
    813          *
    814          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    815          *
    816          *                            OS_ERR_NONE              If the task was readied and informed of the aborted wait
    817          *                            OS_ERR_PEND_ABORT_ISR    If you called this function from an ISR
    818          *                            OS_ERR_PEND_ABORT_NONE   If task was not pending on a message and thus there is nothing to
    819          *                                                     abort.
    820          *                            OS_ERR_PEND_ABORT_SELF   If you passed a NULL pointer for 'p_tcb'
    821          *
    822          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
    823          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
    824          ************************************************************************************************************************
    825          */
    826          
    827          #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    828          CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
    829                                         OS_OPT   opt,
    830                                         OS_ERR  *p_err)
    831          {
   \                     OSTaskQPendAbort: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0015             MOVS     R5,R2
    832              CPU_TS         ts;
    833              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
    834          
    835          
    836          
    837          #ifdef OS_SAFETY_CRITICAL
    838              if (p_err == (OS_ERR *)0) {
    839                  OS_SAFETY_CRITICAL_EXCEPTION();
    840                  return (DEF_FALSE);
    841              }
    842          #endif
    843          
    844          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    845              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \   0000000C   0x....             LDR.N    R0,??DataTable10
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSTaskQPendAbort_0
    846                 *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    847                  return (DEF_FALSE);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06B             B.N      ??OSTaskQPendAbort_1
    848              }
    849          #endif
    850          
    851          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    852              switch (opt) {                                          /* User must supply a valid option                        */
   \                     ??OSTaskQPendAbort_0: (+1)
   \   0000001E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD002             BEQ.N    ??OSTaskQPendAbort_2
   \   00000028   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002C   0xD107             BNE.N    ??OSTaskQPendAbort_3
    853                  case OS_OPT_POST_NONE:
    854                  case OS_OPT_POST_NO_SCHED:
    855                       break;
    856          
    857                  default:
    858                      *p_err = OS_ERR_OPT_INVALID;
    859                       return (DEF_FALSE);
    860              }
    861          #endif
    862          
    863              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPendAbort_2: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x0007             MOVS     R7,R0
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStart
    864          #if OS_CFG_ARG_CHK_EN > 0u
    865              if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
    866                  (p_tcb == OSTCBCurPtr)) {
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD009             BEQ.N    ??OSTaskQPendAbort_4
   \   0000003C   0xE004             B.N      ??OSTaskQPendAbort_5
   \                     ??OSTaskQPendAbort_3: (+1)
   \   0000003E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000042   0x8028             STRH     R0,[R5, #+0]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE056             B.N      ??OSTaskQPendAbort_1
   \                     ??OSTaskQPendAbort_5: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable10_1
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD109             BNE.N    ??OSTaskQPendAbort_6
    867                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPendAbort_4: (+1)
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
    868                 *p_err = OS_ERR_PEND_ABORT_SELF;                     /* ... doesn't make sense                                 */
   \   0000005A   0xF246 0x10AC      MOVW     R0,#+25004
   \   0000005E   0x8028             STRH     R0,[R5, #+0]
    869                  return (DEF_FALSE);
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE048             B.N      ??OSTaskQPendAbort_1
    870              }
    871          #endif
    872          
    873              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
   \                     ??OSTaskQPendAbort_6: (+1)
   \   00000064   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000068   0x2802             CMP      R0,#+2
   \   0000006A   0xD009             BEQ.N    ??OSTaskQPendAbort_7
    874                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   0000006C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    875                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   00000076   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000007A   0x8028             STRH     R0,[R5, #+0]
    876                  return (DEF_FALSE);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE03A             B.N      ??OSTaskQPendAbort_1
    877              }
    878          
    879              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTaskQPendAbort_7: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD101             BNE.N    ??OSTaskQPendAbort_8
   \   00000098   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskQPendAbort_8: (+1)
   \   0000009C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A0   0x0038             MOVS     R0,R7
   \   000000A2   0x.... 0x....      BL       CPU_SR_Restore
    880              ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
   \   000000A6   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000AA   0x0006             MOVS     R6,R0
    881              OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
    882                           p_tcb,
    883                           ts);
   \   000000AC   0x0032             MOVS     R2,R6
   \   000000AE   0x0021             MOVS     R1,R4
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x.... 0x....      BL       OS_PendAbort
    884              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000B6   0x.... 0x....      BL       CPU_SR_Save
   \   000000BA   0x0007             MOVS     R7,R0
   \   000000BC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD101             BNE.N    ??OSTaskQPendAbort_9
   \   000000D8   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskQPendAbort_9: (+1)
   \   000000DC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E0   0x0038             MOVS     R0,R7
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
    885              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   000000E6   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   000000EA   0xD401             BMI.N    ??OSTaskQPendAbort_10
    886                  OSSched();                                          /* Run the scheduler                                      */
   \   000000EC   0x.... 0x....      BL       OSSched
    887              }
    888             *p_err = OS_ERR_NONE;
   \                     ??OSTaskQPendAbort_10: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x8028             STRH     R0,[R5, #+0]
    889              return (DEF_TRUE);
   \   000000F4   0x2001             MOVS     R0,#+1
   \                     ??OSTaskQPendAbort_1: (+1)
   \   000000F6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    890          }
    891          #endif
    892          
    893          /*$PAGE*/
    894          /*
    895          ************************************************************************************************************************
    896          *                                               POST MESSAGE TO A TASK
    897          *
    898          * Description: This function sends a message to a task
    899          *
    900          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
    901          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
    902          *                         posting a message to yourself.
    903          *
    904          *              p_void     is a pointer to the message to send.
    905          *
    906          *              msg_size   is the size of the message sent (in #bytes)
    907          *
    908          *              opt        specifies whether the post will be FIFO or LIFO:
    909          *
    910          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
    911          *                             OS_OPT_POST_LIFO       Post at the front of the queue
    912          *
    913          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
    914          *
    915          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    916          *
    917          *
    918          *              p_err      is a pointer to a variable that will hold the error code associated
    919          *                         with the outcome of this call.  Errors can be:
    920          *
    921          *                             OS_ERR_NONE            The call was successful and the message was sent
    922          *                             OS_ERR_Q_MAX           If the queue is full
    923          *                             OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs available from the pool
    924          *
    925          * Returns    : none
    926          ************************************************************************************************************************
    927          */
    928          
    929          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    930          void  OSTaskQPost (OS_TCB       *p_tcb,
    931                             void         *p_void,
    932                             OS_MSG_SIZE   msg_size,
    933                             OS_OPT        opt,
    934                             OS_ERR       *p_err)
    935          {
   \                     OSTaskQPost: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    936              CPU_TS   ts;
    937          
    938          
    939          
    940          #ifdef OS_SAFETY_CRITICAL
    941              if (p_err == (OS_ERR *)0) {
    942                  OS_SAFETY_CRITICAL_EXCEPTION();
    943                  return;
    944              }
    945          #endif
    946          
    947          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    948              switch (opt) {                                          /* User must supply a valid option                        */
   \   00000012   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000014   0x0038             MOVS     R0,R7
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD008             BEQ.N    ??OSTaskQPost_0
   \   0000001A   0x2810             CMP      R0,#+16
   \   0000001C   0xD006             BEQ.N    ??OSTaskQPost_0
   \   0000001E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000022   0xD003             BEQ.N    ??OSTaskQPost_0
   \   00000024   0xF248 0x0110      MOVW     R1,#+32784
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD107             BNE.N    ??OSTaskQPost_1
    949                  case OS_OPT_POST_FIFO:
    950                  case OS_OPT_POST_LIFO:
    951                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
    952                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
    953                       break;
    954          
    955                  default:
    956                      *p_err = OS_ERR_OPT_INVALID;
    957                       return;
    958              }
    959          #endif
    960          
    961              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSTaskQPost_0: (+1)
   \   0000002C   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000030   0x4681             MOV      R9,R0
    962          
    963          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    964              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
   \   00000032   0x....             LDR.N    R0,??DataTable10
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD105             BNE.N    ??OSTaskQPost_2
   \   0000003A   0xE016             B.N      ??OSTaskQPost_3
   \                     ??OSTaskQPost_1: (+1)
   \   0000003C   0xF645 0x6025      MOVW     R0,#+24101
   \   00000040   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000044   0xE01D             B.N      ??OSTaskQPost_4
    965                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
    966                              (void      *)p_tcb,
    967                              (void      *)p_void,
    968                              (OS_MSG_SIZE)msg_size,
    969                              (OS_FLAGS   )0,
    970                              (OS_OPT     )opt,
    971                              (CPU_TS     )ts,
    972                              (OS_ERR    *)p_err);
   \                     ??OSTaskQPost_2: (+1)
   \   00000046   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \   0000004A   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000052   0x9001             STR      R0,[SP, #+4]
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x0033             MOVS     R3,R6
   \   0000005A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000005C   0x002A             MOVS     R2,R5
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x47534d54
   \   00000064   0x.... 0x....      BL       OS_IntQPost
    973                  return;
   \   00000068   0xE00B             B.N      ??OSTaskQPost_4
    974              }
    975          #endif
    976          
    977              OS_TaskQPost(p_tcb,
    978                           p_void,
    979                           msg_size,
    980                           opt,
    981                           ts,
    982                           p_err);
   \                     ??OSTaskQPost_3: (+1)
   \   0000006A   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   0000006E   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000072   0x003B             MOVS     R3,R7
   \   00000074   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000076   0x0032             MOVS     R2,R6
   \   00000078   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007A   0x0029             MOVS     R1,R5
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       OS_TaskQPost
    983          }
   \                     ??OSTaskQPost_4: (+1)
   \   00000082   0xB005             ADD      SP,SP,#+20
   \   00000084   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    984          #endif
    985          
    986          /*$PAGE*/
    987          /*
    988          ************************************************************************************************************************
    989          *                                       GET THE CURRENT VALUE OF A TASK REGISTER
    990          *
    991          * Description: This function is called to obtain the current value of a task register.  Task registers are application
    992          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
    993          *              etc.
    994          *
    995          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to read the register from.  If 'p_tcb' is a
    996          *                        NULL pointer then you will get the register of the current task.
    997          *
    998          *              id        is the 'id' of the desired task variable.  Note that the 'id' must be less than
    999          *                        OS_CFG_TASK_REG_TBL_SIZE
   1000          *
   1001          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1002          *
   1003          *                            OS_ERR_NONE            if the call was successful
   1004          *                            OS_ERR_REG_ID_INVALID  if the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1005          *
   1006          * Returns    : The current value of the task's register or 0 if an error is detected.
   1007          ************************************************************************************************************************
   1008          */
   1009          
   1010          #if OS_CFG_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1011          OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
   1012                                OS_REG_ID   id,
   1013                                OS_ERR     *p_err)
   1014          {
   \                     OSTaskRegGet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1015              OS_REG     value;
   1016              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   1017          
   1018          
   1019          
   1020          #ifdef OS_SAFETY_CRITICAL
   1021              if (p_err == (OS_ERR *)0) {
   1022                  OS_SAFETY_CRITICAL_EXCEPTION();
   1023                  return ((OS_REG)0);
   1024              }
   1025          #endif
   1026          
   1027          #if OS_CFG_ARG_CHK_EN > 0u
   1028              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD004             BEQ.N    ??OSTaskRegGet_0
   1029                 *p_err = OS_ERR_REG_ID_INVALID;
   \   00000014   0xF646 0x1079      MOVW     R0,#+27001
   \   00000018   0x8030             STRH     R0,[R6, #+0]
   1030                  return ((OS_REG)0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE016             B.N      ??OSTaskRegGet_1
   1031              }
   1032          #endif
   1033          
   1034              CPU_CRITICAL_ENTER();
   \                     ??OSTaskRegGet_0: (+1)
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x4680             MOV      R8,R0
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStart
   1035              if (p_tcb == (OS_TCB *)0) {
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD102             BNE.N    ??OSTaskRegGet_2
   1036                  p_tcb = OSTCBCurPtr;
   \   0000002C   0x....             LDR.N    R0,??DataTable10_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0004             MOVS     R4,R0
   1037              }
   1038              value = p_tcb->RegTbl[id];
   \                     ??OSTaskRegGet_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000038   0x6FC0             LDR      R0,[R0, #+124]
   \   0000003A   0x0007             MOVS     R7,R0
   1039              CPU_CRITICAL_EXIT();
   \   0000003C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
   1040             *p_err = OS_ERR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x8030             STRH     R0,[R6, #+0]
   1041              return ((OS_REG)value);
   \   0000004A   0x0038             MOVS     R0,R7
   \                     ??OSTaskRegGet_1: (+1)
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1042          }
   1043          #endif
   1044          
   1045          /*$PAGE*/
   1046          /*
   1047          ************************************************************************************************************************
   1048          *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
   1049          *
   1050          * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
   1051          *              allocated dynamically instead of statically.
   1052          *
   1053          * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
   1054          *
   1055          *                            OS_ERR_NONE               if the call was successful
   1056          *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
   1057          *                                                           have available through OS_CFG_TASK_REG_TBL_SIZE.
   1058          *
   1059          * Returns    : The next available task register 'id' or OS_CFG_TASK_REG_TBL_SIZE if an error is detected.
   1060          ************************************************************************************************************************
   1061          */
   1062          
   1063          #if OS_CFG_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1064          OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
   1065          {
   \                     OSTaskRegGetID: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1066              OS_REG_ID  id;
   1067              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
   1068          
   1069          
   1070          
   1071          #ifdef OS_SAFETY_CRITICAL
   1072              if (p_err == (OS_ERR *)0) {
   1073                  OS_SAFETY_CRITICAL_EXCEPTION();
   1074                  return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
   1075              }
   1076          #endif
   1077          
   1078              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
   1079              if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD009             BEQ.N    ??OSTaskRegGetID_0
   1080                 *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
   \   0000001A   0xF645 0x10DA      MOVW     R0,#+23002
   \   0000001E   0x8020             STRH     R0,[R4, #+0]
   1081                  CPU_CRITICAL_EXIT();
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
   1082                  return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE013             B.N      ??OSTaskRegGetID_1
   1083              }
   1084               
   1085              id    = OSTaskRegNextAvailID;								  /* Assign the next available ID                     */
   \                     ??OSTaskRegGetID_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x0005             MOVS     R5,R0
   1086              OSTaskRegNextAvailID++;										  /* Increment available ID for next request          */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   1087              CPU_CRITICAL_EXIT();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
   1088             *p_err = OS_ERR_NONE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   1089              return (id);
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTaskRegGetID_1: (+1)
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   1090          }
   1091          #endif
   1092          
   1093          /*$PAGE*/
   1094          /*
   1095          ************************************************************************************************************************
   1096          *                                       SET THE CURRENT VALUE OF A TASK REGISTER
   1097          *
   1098          * Description: This function is called to change the current value of a task register.  Task registers are application
   1099          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
   1100          *              etc.
   1101          *
   1102          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to set the register for.  If 'p_tcb' is a NULL
   1103          *                        pointer then you will change the register of the current task.
   1104          *
   1105          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less than
   1106          *                        OS_CFG_TASK_REG_TBL_SIZE
   1107          *
   1108          *              value     is the desired value for the task register.
   1109          *
   1110          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1111          *
   1112          *                            OS_ERR_NONE            if the call was successful
   1113          *                            OS_ERR_REG_ID_INVALID  if the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1114          *
   1115          * Returns    : none
   1116          ************************************************************************************************************************
   1117          */
   1118          
   1119          #if OS_CFG_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1120          void  OSTaskRegSet (OS_TCB     *p_tcb,
   1121                              OS_REG_ID   id,
   1122                              OS_REG      value,
   1123                              OS_ERR     *p_err)
   1124          {
   \                     OSTaskRegSet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1125              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1126          
   1127          
   1128          
   1129          #ifdef OS_SAFETY_CRITICAL
   1130              if (p_err == (OS_ERR *)0) {
   1131                  OS_SAFETY_CRITICAL_EXCEPTION();
   1132                  return;
   1133              }
   1134          #endif
   1135          
   1136          #if OS_CFG_ARG_CHK_EN > 0u
   1137              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD003             BEQ.N    ??OSTaskRegSet_0
   1138                 *p_err = OS_ERR_REG_ID_INVALID;
   \   00000016   0xF646 0x1079      MOVW     R0,#+27001
   \   0000001A   0x8038             STRH     R0,[R7, #+0]
   1139                  return;
   \   0000001C   0xE014             B.N      ??OSTaskRegSet_1
   1140              }
   1141          #endif
   1142          
   1143              CPU_CRITICAL_ENTER();
   \                     ??OSTaskRegSet_0: (+1)
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x4680             MOV      R8,R0
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStart
   1144              if (p_tcb == (OS_TCB *)0) {
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD102             BNE.N    ??OSTaskRegSet_2
   1145                  p_tcb = OSTCBCurPtr;
   \   0000002C   0x....             LDR.N    R0,??DataTable10_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0004             MOVS     R4,R0
   1146              }
   1147              p_tcb->RegTbl[id] = value;
   \                     ??OSTaskRegSet_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000038   0x67C6             STR      R6,[R0, #+124]
   1148              CPU_CRITICAL_EXIT();
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
   1149             *p_err             = OS_ERR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8038             STRH     R0,[R7, #+0]
   1150          }
   \                     ??OSTaskRegSet_1: (+1)
   \   00000048   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1151          #endif
   1152          
   1153          /*$PAGE*/
   1154          /*
   1155          ************************************************************************************************************************
   1156          *                                               RESUME A SUSPENDED TASK
   1157          *
   1158          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   1159          *              explicit task suspension.
   1160          *
   1161          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   1162          *
   1163          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   1164          *
   1165          *                             OS_ERR_NONE                  if the requested task is resumed
   1166          *                             OS_ERR_STATE_INVALID         if the task is in an invalid state
   1167          *                             OS_ERR_TASK_RESUME_ISR       if you called this function from an ISR
   1168          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   1169          *                             OS_ERR_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
   1170          *
   1171          * Returns    : none
   1172          ************************************************************************************************************************
   1173          */
   1174          
   1175          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1176          void  OSTaskResume (OS_TCB  *p_tcb,
   1177                              OS_ERR  *p_err)
   1178          {
   \                     OSTaskResume: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1179              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   1180          
   1181          
   1182          
   1183          #ifdef OS_SAFETY_CRITICAL
   1184              if (p_err == (OS_ERR *)0) {
   1185                  OS_SAFETY_CRITICAL_EXCEPTION();
   1186                  return;
   1187              }
   1188          #endif
   1189          
   1190          #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
   1191              (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
   1192              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1193                 *p_err = OS_ERR_TASK_RESUME_ISR;
   1194                  return;
   1195              }
   1196          #endif
   1197          
   1198          
   1199              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
   1200          #if OS_CFG_ARG_CHK_EN > 0u
   1201              if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
   1202                  (p_tcb == OSTCBCurPtr)) {
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD003             BEQ.N    ??OSTaskResume_0
   \   00000016   0x....             LDR.N    R0,??DataTable10_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD108             BNE.N    ??OSTaskResume_1
   1203                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_0: (+1)
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       CPU_SR_Restore
   1204                 *p_err  = OS_ERR_TASK_RESUME_SELF;
   \   00000028   0xF247 0x1057      MOVW     R0,#+29015
   \   0000002C   0x8028             STRH     R0,[R5, #+0]
   1205                  return;
   \   0000002E   0xE01B             B.N      ??OSTaskResume_2
   1206              }
   1207          #endif
   1208              CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_1: (+1)
   \   00000030   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       CPU_SR_Restore
   1209          
   1210          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1211              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \   0000003A   0x....             LDR.N    R0,??DataTable10
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00E             BEQ.N    ??OSTaskResume_3
   1212                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_RESUME,   /* Post to ISR queue                                      */
   1213                              (void      *)p_tcb,
   1214                              (void      *)0,
   1215                              (OS_MSG_SIZE)0,
   1216                              (OS_FLAGS   )0,
   1217                              (OS_OPT     )0,
   1218                              (CPU_TS     )0,
   1219                              (OS_ERR    *)p_err);
   \   00000042   0x9503             STR      R5,[SP, #+12]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9002             STR      R0,[SP, #+8]
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x9001             STR      R0,[SP, #+4]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable24_2  ;; 0x53455254
   \   0000005A   0x.... 0x....      BL       OS_IntQPost
   1220                  return;
   \   0000005E   0xE003             B.N      ??OSTaskResume_2
   1221              }
   1222          #endif
   1223          
   1224              OS_TaskResume(p_tcb, p_err);
   \                     ??OSTaskResume_3: (+1)
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       OS_TaskResume
   1225          }
   \                     ??OSTaskResume_2: (+1)
   \   00000068   0xBD7F             POP      {R0-R6,PC}       ;; return
   1226          #endif
   1227          
   1228          /*$PAGE*/
   1229          /*
   1230          ************************************************************************************************************************
   1231          *                                              WAIT FOR A TASK SEMAPHORE
   1232          *
   1233          * Description: This function is called to block the current task until a signal is sent by another task or ISR.
   1234          *
   1235          * Arguments  : timeout       is the amount of time you are will to wait for the signal
   1236          *
   1237          *              opt           determines whether the user wants to block if a semaphore post was not received:
   1238          *
   1239          *                                OS_OPT_PEND_BLOCKING
   1240          *                                OS_OPT_PEND_NON_BLOCKING
   1241          *
   1242          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
   1243          *                            or pend aborted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
   1244          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
   1245          *                            need the timestamp.
   1246          *
   1247          *              p_err         is a pointer to an error code that will be set by this function
   1248          *
   1249          *                                OS_ERR_NONE               The call was successful and your task received a message.
   1250          *                                OS_ERR_PEND_ABORT
   1251          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
   1252          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but no signal was received
   1253          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
   1254          *                                OS_ERR_STATUS_INVALID     If the pend status is invalid
   1255          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
   1256          *                                                          would lead to a suspension.
   1257          *
   1258          * Returns    : The current count of signals the task received, 0 if none.
   1259          ************************************************************************************************************************
   1260          */
   1261          

   \                                 In section .text, align 2, keep-with-next
   1262          OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
   1263                                     OS_OPT    opt,
   1264                                     CPU_TS   *p_ts,
   1265                                     OS_ERR   *p_err)
   1266          {
   \                     OSTaskSemPend: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1267              OS_SEM_CTR    ctr;
   1268              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   1269          
   1270          
   1271          
   1272          #ifdef OS_SAFETY_CRITICAL
   1273              if (p_err == (OS_ERR *)0) {
   1274                  OS_SAFETY_CRITICAL_EXCEPTION();
   1275                  return ((OS_SEM_CTR)0);
   1276              }
   1277          #endif
   1278          
   1279          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1280              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSTaskSemPend_0
   1281                 *p_err = OS_ERR_PEND_ISR;
   \   0000001A   0xF246 0x10AE      MOVW     R0,#+25006
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
   1282                  return ((OS_SEM_CTR)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE100             B.N      ??OSTaskSemPend_1
   1283              }
   1284          #endif
   1285          
   1286          #if OS_CFG_ARG_CHK_EN > 0u
   1287              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSTaskSemPend_0: (+1)
   \   00000024   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD002             BEQ.N    ??OSTaskSemPend_2
   \   0000002C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000030   0xD102             BNE.N    ??OSTaskSemPend_3
   1288                  case OS_OPT_PEND_BLOCKING:
   1289                  case OS_OPT_PEND_NON_BLOCKING:
   1290                       break;
   1291          
   1292                  default:
   1293                      *p_err = OS_ERR_OPT_INVALID;
   1294                       return ((OS_SEM_CTR)0);
   1295              }
   1296          #endif
   1297          
   1298              if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_2: (+1)
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD007             BEQ.N    ??OSTaskSemPend_4
   \   00000036   0xE004             B.N      ??OSTaskSemPend_5
   \                     ??OSTaskSemPend_3: (+1)
   \   00000038   0xF645 0x6025      MOVW     R0,#+24101
   \   0000003C   0x8038             STRH     R0,[R7, #+0]
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE0F1             B.N      ??OSTaskSemPend_1
   1299                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \                     ??OSTaskSemPend_5: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6030             STR      R0,[R6, #+0]
   1300              }
   1301          
   1302              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPend_4: (+1)
   \   00000046   0x.... 0x....      BL       CPU_SR_Save
   \   0000004A   0x4681             MOV      R9,R0
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStart
   1303              if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x6C40             LDR      R0,[R0, #+68]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD03F             BEQ.N    ??OSTaskSemPend_6
   1304                  OSTCBCurPtr->SemCtr--;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x6C40             LDR      R0,[R0, #+68]
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x6448             STR      R0,[R1, #+68]
   1305                  ctr    = OSTCBCurPtr->SemCtr;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x6C40             LDR      R0,[R0, #+68]
   \   00000076   0x4680             MOV      R8,R0
   1306                  if (p_ts != (CPU_TS *)0) {
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD004             BEQ.N    ??OSTaskSemPend_7
   1307                     *p_ts  = OSTCBCurPtr->TS;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x6C00             LDR      R0,[R0, #+64]
   \   00000084   0x6030             STR      R0,[R6, #+0]
   1308                  }
   1309          #if OS_CFG_TASK_PROFILE_EN > 0u
   1310                  OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   \                     ??OSTaskSemPend_7: (+1)
   \   00000086   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0x6C09             LDR      R1,[R1, #+64]
   \   00000092   0x1A40             SUBS     R0,R0,R1
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0xF8C1 0x00A4      STR      R0,[R1, #+164]
   1311                  if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF8D0 0x00A8      LDR      R0,[R0, #+168]
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0xF8D1 0x10A4      LDR      R1,[R1, #+164]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD209             BCS.N    ??OSTaskSemPend_8
   1312                      OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF8D0 0x00A4      LDR      R0,[R0, #+164]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0xF8C1 0x00A8      STR      R0,[R1, #+168]
   1313                  }
   1314          #endif
   1315                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPend_8: (+1)
   \   000000CA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0x.... 0x....      BL       CPU_SR_Restore
   1316                 *p_err = OS_ERR_NONE;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x8038             STRH     R0,[R7, #+0]
   1317                  return (ctr);
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0xE0A4             B.N      ??OSTaskSemPend_1
   1318              }
   1319          
   1320              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSTaskSemPend_6: (+1)
   \   000000DC   0x0428             LSLS     R0,R5,#+16
   \   000000DE   0xD509             BPL.N    ??OSTaskSemPend_9
   1321                  CPU_CRITICAL_EXIT();
   \   000000E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E4   0x4648             MOV      R0,R9
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
   1322                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \   000000EA   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000EE   0x8038             STRH     R0,[R7, #+0]
   1323                  return ((OS_SEM_CTR)0);
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xE098             B.N      ??OSTaskSemPend_1
   1324              } else {                                                /* Yes                                                    */
   1325                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSTaskSemPend_9: (+1)
   \   000000F4   0x....             LDR.N    R0,??DataTable11
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD009             BEQ.N    ??OSTaskSemPend_10
   1326                      CPU_CRITICAL_EXIT();
   \   000000FC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x.... 0x....      BL       CPU_SR_Restore
   1327                     *p_err = OS_ERR_SCHED_LOCKED;
   \   00000106   0xF646 0x5063      MOVW     R0,#+28003
   \   0000010A   0x8038             STRH     R0,[R7, #+0]
   1328                      return ((OS_SEM_CTR)0);
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xE08A             B.N      ??OSTaskSemPend_1
   1329                  }
   1330              }
   1331                                                                      /* Lock the scheduler/re-enable interrupts                */
   1332              OS_CRITICAL_ENTER_CPU_EXIT();                           
   \                     ??OSTaskSemPend_10: (+1)
   \   00000110   0x....             LDR.N    R0,??DataTable11
   \   00000112   0x7800             LDRB     R0,[R0, #+0]
   \   00000114   0x1C40             ADDS     R0,R0,#+1
   \   00000116   0x....             LDR.N    R1,??DataTable11
   \   00000118   0x7008             STRB     R0,[R1, #+0]
   \   0000011A   0x....             LDR.N    R0,??DataTable11
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD101             BNE.N    ??OSTaskSemPend_11
   \   00000122   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskSemPend_11: (+1)
   \   00000126   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012A   0x4648             MOV      R0,R9
   \   0000012C   0x.... 0x....      BL       CPU_SR_Restore
   1333              OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
   1334                      (OS_PEND_OBJ  *)0,
   1335                      (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
   1336                      (OS_TICK       )timeout);
   \   00000130   0x0023             MOVS     R3,R4
   \   00000132   0x2207             MOVS     R2,#+7
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0x.... 0x....      BL       OS_Pend
   1337              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000013C   0x.... 0x....      BL       CPU_SR_Save
   \   00000140   0x4681             MOV      R9,R0
   \   00000142   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000146   0x....             LDR.N    R0,??DataTable11
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
   \   0000014A   0x1E40             SUBS     R0,R0,#+1
   \   0000014C   0x....             LDR.N    R1,??DataTable11
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
   \   00000150   0x....             LDR.N    R0,??DataTable11
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD101             BNE.N    ??OSTaskSemPend_12
   \   00000158   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskSemPend_12: (+1)
   \   0000015C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000160   0x4648             MOV      R0,R9
   \   00000162   0x.... 0x....      BL       CPU_SR_Restore
   1338          
   1339              OSSched();                                              /* Find next highest priority task ready to run           */
   \   00000166   0x.... 0x....      BL       OSSched
   1340          
   1341              CPU_CRITICAL_ENTER();
   \   0000016A   0x.... 0x....      BL       CPU_SR_Save
   \   0000016E   0x4681             MOV      R9,R0
   \   00000170   0x.... 0x....      BL       CPU_IntDisMeasStart
   1342              switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD004             BEQ.N    ??OSTaskSemPend_13
   \   00000182   0x2801             CMP      R0,#+1
   \   00000184   0xD02E             BEQ.N    ??OSTaskSemPend_14
   \   00000186   0x2803             CMP      R0,#+3
   \   00000188   0xD037             BEQ.N    ??OSTaskSemPend_15
   \   0000018A   0xE03E             B.N      ??OSTaskSemPend_16
   1343                  case OS_STATUS_PEND_OK:
   1344                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_13: (+1)
   \   0000018C   0x2E00             CMP      R6,#+0
   \   0000018E   0xD026             BEQ.N    ??OSTaskSemPend_17
   1345                          *p_ts                    =  OSTCBCurPtr->TS;
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000194   0x6800             LDR      R0,[R0, #+0]
   \   00000196   0x6C00             LDR      R0,[R0, #+64]
   \   00000198   0x6030             STR      R0,[R6, #+0]
   1346          #if OS_CFG_TASK_PROFILE_EN > 0u
   1347                          OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   \   0000019A   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000001A2   0x6809             LDR      R1,[R1, #+0]
   \   000001A4   0x6C09             LDR      R1,[R1, #+64]
   \   000001A6   0x1A40             SUBS     R0,R0,R1
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000001AC   0x6809             LDR      R1,[R1, #+0]
   \   000001AE   0xF8C1 0x00A4      STR      R0,[R1, #+164]
   1348                          if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   \   000001B2   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000001B6   0x6800             LDR      R0,[R0, #+0]
   \   000001B8   0xF8D0 0x00A8      LDR      R0,[R0, #+168]
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000001C0   0x6809             LDR      R1,[R1, #+0]
   \   000001C2   0xF8D1 0x10A4      LDR      R1,[R1, #+164]
   \   000001C6   0x4288             CMP      R0,R1
   \   000001C8   0xD209             BCS.N    ??OSTaskSemPend_17
   1349                              OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000001CE   0x6800             LDR      R0,[R0, #+0]
   \   000001D0   0xF8D0 0x00A4      LDR      R0,[R0, #+164]
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable25
   \   000001D8   0x6809             LDR      R1,[R1, #+0]
   \   000001DA   0xF8C1 0x00A8      STR      R0,[R1, #+168]
   1350                          }
   1351          #endif
   1352                       }
   1353                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPend_17: (+1)
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0x8038             STRH     R0,[R7, #+0]
   1354                       break;
   \   000001E2   0xE015             B.N      ??OSTaskSemPend_18
   1355          
   1356                  case OS_STATUS_PEND_ABORT:
   1357                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_14: (+1)
   \   000001E4   0x2E00             CMP      R6,#+0
   \   000001E6   0xD004             BEQ.N    ??OSTaskSemPend_19
   1358                          *p_ts  =  OSTCBCurPtr->TS;
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \   000001EE   0x6C00             LDR      R0,[R0, #+64]
   \   000001F0   0x6030             STR      R0,[R6, #+0]
   1359                       }
   1360                      *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
   \                     ??OSTaskSemPend_19: (+1)
   \   000001F2   0xF246 0x10A9      MOVW     R0,#+25001
   \   000001F6   0x8038             STRH     R0,[R7, #+0]
   1361                       break;
   \   000001F8   0xE00A             B.N      ??OSTaskSemPend_18
   1362          
   1363                  case OS_STATUS_PEND_TIMEOUT:
   1364                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_15: (+1)
   \   000001FA   0x2E00             CMP      R6,#+0
   \   000001FC   0xD001             BEQ.N    ??OSTaskSemPend_20
   1365                          *p_ts  = (CPU_TS  )0;
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x6030             STR      R0,[R6, #+0]
   1366                       }
   1367                      *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
   \                     ??OSTaskSemPend_20: (+1)
   \   00000202   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000206   0x8038             STRH     R0,[R7, #+0]
   1368                       break;
   \   00000208   0xE002             B.N      ??OSTaskSemPend_18
   1369          
   1370                  default:
   1371                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSTaskSemPend_16: (+1)
   \   0000020A   0xF646 0x602E      MOVW     R0,#+28206
   \   0000020E   0x8038             STRH     R0,[R7, #+0]
   1372                       break;
   1373              }
   1374              ctr = OSTCBCurPtr->SemCtr;
   \                     ??OSTaskSemPend_18: (+1)
   \   00000210   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000214   0x6800             LDR      R0,[R0, #+0]
   \   00000216   0x6C40             LDR      R0,[R0, #+68]
   \   00000218   0x4680             MOV      R8,R0
   1375              CPU_CRITICAL_EXIT();
   \   0000021A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000021E   0x4648             MOV      R0,R9
   \   00000220   0x.... 0x....      BL       CPU_SR_Restore
   1376              return (ctr);
   \   00000224   0x4640             MOV      R0,R8
   \                     ??OSTaskSemPend_1: (+1)
   \   00000226   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1377          }
   1378          
   1379          /*$PAGE*/
   1380          /*
   1381          ************************************************************************************************************************
   1382          *                                               ABORT WAITING FOR A SIGNAL
   1383          *
   1384          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
   1385          *              for a signal, rather than to normally post the signal to the task via OSTaskSemPost().
   1386          *
   1387          * Arguments  : p_tcb     is a pointer to the task to pend abort
   1388          *
   1389          *              opt       provides options for this function:
   1390          *
   1391          *                            OS_OPT_POST_NONE         No option selected
   1392          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
   1393          *
   1394          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
   1395          *
   1396          *                            OS_ERR_NONE              If the task was readied and informed of the aborted wait
   1397          *                            OS_ERR_PEND_ABORT_ISR    If you tried calling this function from an ISR
   1398          *                            OS_ERR_PEND_ABORT_NONE   If the task was not waiting for a signal
   1399          *                            OS_ERR_PEND_ABORT_SELF   If you attempted to pend abort the calling task.  This is not
   1400          *                                                     possible since the calling task cannot be pending because it's
   1401          *                                                     running.
   1402          *
   1403          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
   1404          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
   1405          ************************************************************************************************************************
   1406          */
   1407          
   1408          #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1409          CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
   1410                                           OS_OPT   opt,
   1411                                           OS_ERR  *p_err)
   1412          {
   \                     OSTaskSemPendAbort: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0015             MOVS     R5,R2
   1413              CPU_TS         ts;
   1414              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
   1415          
   1416          
   1417          
   1418          #ifdef OS_SAFETY_CRITICAL
   1419              if (p_err == (OS_ERR *)0) {
   1420                  OS_SAFETY_CRITICAL_EXCEPTION();
   1421                  return (DEF_FALSE);
   1422              }
   1423          #endif
   1424          
   1425          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1426              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSTaskSemPendAbort_0
   1427                 *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
   \   00000016   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
   1428                  return (DEF_FALSE);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE076             B.N      ??OSTaskSemPendAbort_1
   1429              }
   1430          #endif
   1431          
   1432          #if OS_CFG_ARG_CHK_EN > 0u
   1433              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSTaskSemPendAbort_0: (+1)
   \   00000020   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??OSTaskSemPendAbort_2
   \   0000002A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002E   0xD107             BNE.N    ??OSTaskSemPendAbort_3
   1434                  case OS_OPT_POST_NONE:
   1435                  case OS_OPT_POST_NO_SCHED:
   1436                       break;
   1437          
   1438                  default:
   1439                      *p_err =  OS_ERR_OPT_INVALID;
   1440                       return (DEF_FALSE);
   1441              }
   1442          #endif
   1443          
   1444              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPendAbort_2: (+1)
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x0007             MOVS     R7,R0
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStart
   1445              if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
   1446                  (p_tcb == OSTCBCurPtr)) {
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD00A             BEQ.N    ??OSTaskSemPendAbort_4
   \   0000003E   0xE004             B.N      ??OSTaskSemPendAbort_5
   \                     ??OSTaskSemPendAbort_3: (+1)
   \   00000040   0xF645 0x6025      MOVW     R0,#+24101
   \   00000044   0x8028             STRH     R0,[R5, #+0]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE061             B.N      ??OSTaskSemPendAbort_1
   \                     ??OSTaskSemPendAbort_5: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD109             BNE.N    ??OSTaskSemPendAbort_6
   1447                  CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
   \                     ??OSTaskSemPendAbort_4: (+1)
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x0038             MOVS     R0,R7
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
   1448                 *p_err = OS_ERR_PEND_ABORT_SELF;
   \   0000005E   0xF246 0x10AC      MOVW     R0,#+25004
   \   00000062   0x8028             STRH     R0,[R5, #+0]
   1449                  return (DEF_FALSE);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE052             B.N      ??OSTaskSemPendAbort_1
   1450              }
   1451          
   1452              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
   \                     ??OSTaskSemPendAbort_6: (+1)
   \   00000068   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000006C   0x2807             CMP      R0,#+7
   \   0000006E   0xD009             BEQ.N    ??OSTaskSemPendAbort_7
   1453                  CPU_CRITICAL_EXIT();
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
   1454                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   0000007A   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000007E   0x8028             STRH     R0,[R5, #+0]
   1455                  return (DEF_FALSE);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE044             B.N      ??OSTaskSemPendAbort_1
   1456              }
   1457              CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPendAbort_7: (+1)
   \   00000084   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
   1458          
   1459              OS_CRITICAL_ENTER();
   \   0000008E   0x.... 0x....      BL       CPU_SR_Save
   \   00000092   0x0007             MOVS     R7,R0
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD101             BNE.N    ??OSTaskSemPendAbort_8
   \   000000B0   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTaskSemPendAbort_8: (+1)
   \   000000B4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B8   0x0038             MOVS     R0,R7
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
   1460              ts = OS_TS_GET();
   \   000000BE   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000C2   0x0006             MOVS     R6,R0
   1461              OS_PendAbort((OS_PEND_OBJ *)0,
   1462                           p_tcb,
   1463                           ts);
   \   000000C4   0x0032             MOVS     R2,R6
   \   000000C6   0x0021             MOVS     R1,R4
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      BL       OS_PendAbort
   1464              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000CE   0x.... 0x....      BL       CPU_SR_Save
   \   000000D2   0x0007             MOVS     R7,R0
   \   000000D4   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x1E40             SUBS     R0,R0,#+1
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000E4   0x7008             STRB     R0,[R1, #+0]
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD101             BNE.N    ??OSTaskSemPendAbort_9
   \   000000F0   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTaskSemPendAbort_9: (+1)
   \   000000F4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F8   0x0038             MOVS     R0,R7
   \   000000FA   0x.... 0x....      BL       CPU_SR_Restore
   1465              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   000000FE   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   00000102   0xD401             BMI.N    ??OSTaskSemPendAbort_10
   1466                  OSSched();                                          /* Run the scheduler                                      */
   \   00000104   0x.... 0x....      BL       OSSched
   1467              }
   1468             *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPendAbort_10: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x8028             STRH     R0,[R5, #+0]
   1469              return (DEF_TRUE);
   \   0000010C   0x2001             MOVS     R0,#+1
   \                     ??OSTaskSemPendAbort_1: (+1)
   \   0000010E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1470          }
   1471          #endif
   1472          
   1473          /*$PAGE*/
   1474          /*
   1475          ************************************************************************************************************************
   1476          *                                                    SIGNAL A TASK
   1477          *
   1478          * Description: This function is called to signal a task waiting for a signal.
   1479          *
   1480          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   1481          *                        a signal to yourself.
   1482          *
   1483          *              opt       determines the type of POST performed:
   1484          *
   1485          *                             OS_OPT_POST_NONE         No option
   1486          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   1487          *
   1488          *              p_err     is a pointer to an error code returned by this function:
   1489          *
   1490          *                            OS_ERR_NONE              If the requested task is signaled
   1491          *                            OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow.
   1492          *
   1493          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   1494          ************************************************************************************************************************
   1495          */
   1496          

   \                                 In section .text, align 2, keep-with-next
   1497          OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
   1498                                     OS_OPT   opt,
   1499                                     OS_ERR  *p_err)
   1500          {
   \                     OSTaskSemPost: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1501              OS_SEM_CTR  ctr;
   1502              CPU_TS      ts;
   1503          
   1504          
   1505          
   1506          #ifdef OS_SAFETY_CRITICAL
   1507              if (p_err == (OS_ERR *)0) {
   1508                  OS_SAFETY_CRITICAL_EXCEPTION();
   1509                  return ((OS_SEM_CTR)0);
   1510              }
   1511          #endif
   1512          
   1513          #if OS_CFG_ARG_CHK_EN > 0u
   1514              switch (opt) {                                          /* Validate 'opt'                                         */
   \   0000000A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ.N    ??OSTaskSemPost_0
   \   00000012   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000016   0xD108             BNE.N    ??OSTaskSemPost_1
   1515                  case OS_OPT_POST_NONE:
   1516                  case OS_OPT_POST_NO_SCHED:
   1517                       break;
   1518          
   1519                  default:
   1520                      *p_err =  OS_ERR_OPT_INVALID;
   1521                       return ((OS_SEM_CTR)0u);
   1522              }
   1523          #endif
   1524          
   1525              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSTaskSemPost_0: (+1)
   \   00000018   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000001C   0x4680             MOV      R8,R0
   1526          
   1527          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1528              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD105             BNE.N    ??OSTaskSemPost_2
   \   00000028   0xE014             B.N      ??OSTaskSemPost_3
   \                     ??OSTaskSemPost_1: (+1)
   \   0000002A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000002E   0x8030             STRH     R0,[R6, #+0]
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE018             B.N      ??OSTaskSemPost_4
   1529                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
   1530                              (void      *)p_tcb,
   1531                              (void      *)0,
   1532                              (OS_MSG_SIZE)0,
   1533                              (OS_FLAGS   )0,
   1534                              (OS_OPT     )0,
   1535                              (CPU_TS     )ts,
   1536                              (OS_ERR    *)p_err);
   \                     ??OSTaskSemPost_2: (+1)
   \   00000034   0x9603             STR      R6,[SP, #+12]
   \   00000036   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9001             STR      R0,[SP, #+4]
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x47495354
   \   0000004C   0x.... 0x....      BL       OS_IntQPost
   1537                  return ((OS_SEM_CTR)0);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE008             B.N      ??OSTaskSemPost_4
   1538              }
   1539          #endif
   1540          
   1541              ctr = OS_TaskSemPost(p_tcb,
   1542                                   opt,
   1543                                   ts,
   1544                                   p_err);
   \                     ??OSTaskSemPost_3: (+1)
   \   00000054   0x0033             MOVS     R3,R6
   \   00000056   0x4642             MOV      R2,R8
   \   00000058   0x0029             MOVS     R1,R5
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       OS_TaskSemPost
   \   00000062   0x0007             MOVS     R7,R0
   1545          
   1546              return (ctr);
   \   00000064   0x0038             MOVS     R0,R7
   \                     ??OSTaskSemPost_4: (+1)
   \   00000066   0xB004             ADD      SP,SP,#+16
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1547          }
   1548          
   1549          /*$PAGE*/
   1550          /*
   1551          ************************************************************************************************************************
   1552          *                                            SET THE SIGNAL COUNTER OF A TASK
   1553          *
   1554          * Description: This function is called to clear the signal counter
   1555          *
   1556          * Arguments  : p_tcb      is the pointer to the TCB of the task to clear the counter.  If you specify a NULL pointer
   1557          *                         then the signal counter of the current task will be cleared.
   1558          *
   1559          *              cnt        is the desired value of the semaphore counter
   1560          *
   1561          *              p_err      is a pointer to an error code returned by this function
   1562          *
   1563          *                             OS_ERR_NONE        if the signal counter of the requested task is cleared
   1564          *                             OS_ERR_SET_ISR     if the function was called from an ISR
   1565          *
   1566          * Returns    : none
   1567          ************************************************************************************************************************
   1568          */
   1569          

   \                                 In section .text, align 2, keep-with-next
   1570          OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
   1571                                    OS_SEM_CTR   cnt,
   1572                                    OS_ERR      *p_err)
   1573          {
   \                     OSTaskSemSet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1574              OS_SEM_CTR  ctr;
   1575              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   1576          
   1577          
   1578          
   1579          #ifdef OS_SAFETY_CRITICAL
   1580              if (p_err == (OS_ERR *)0) {
   1581                  OS_SAFETY_CRITICAL_EXCEPTION();
   1582                  return ((OS_SEM_CTR)0);
   1583              }
   1584          #endif
   1585          
   1586          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1587              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSTaskSemSet_0
   1588                 *p_err = OS_ERR_SET_ISR;
   \   00000018   0xF646 0x50C6      MOVW     R0,#+28102
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
   1589                  return ((OS_SEM_CTR)0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE015             B.N      ??OSTaskSemSet_1
   1590              }
   1591          #endif
   1592          
   1593              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemSet_0: (+1)
   \   00000022   0x.... 0x....      BL       CPU_SR_Save
   \   00000026   0x4680             MOV      R8,R0
   \   00000028   0x.... 0x....      BL       CPU_IntDisMeasStart
   1594              if (p_tcb == (OS_TCB *)0) {
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD103             BNE.N    ??OSTaskSemSet_2
   1595                  p_tcb = OSTCBCurPtr;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0004             MOVS     R4,R0
   1596              }
   1597              ctr           = p_tcb->SemCtr;
   \                     ??OSTaskSemSet_2: (+1)
   \   00000038   0x6C60             LDR      R0,[R4, #+68]
   \   0000003A   0x0007             MOVS     R7,R0
   1598              p_tcb->SemCtr = (OS_SEM_CTR)cnt;
   \   0000003C   0x6465             STR      R5,[R4, #+68]
   1599              CPU_CRITICAL_EXIT();
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x.... 0x....      BL       CPU_SR_Restore
   1600             *p_err         =  OS_ERR_NONE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
   1601              return (ctr);
   \   0000004C   0x0038             MOVS     R0,R7
   \                     ??OSTaskSemSet_1: (+1)
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1602          }
   1603          
   1604          /*$PAGE*/
   1605          /*
   1606          ************************************************************************************************************************
   1607          *                                                    STACK CHECKING
   1608          *
   1609          * Description: This function is called to calculate the amount of free memory left on the specified task's stack.
   1610          *
   1611          * Arguments  : p_tcb       is a pointer to the TCB of the task to check.  If you specify a NULL pointer then
   1612          *                          you are specifying that you want to check the stack of the current task.
   1613          *
   1614          *              p_free      is a pointer to a variable that will receive the number of free 'entries' on the task's stack.
   1615          *
   1616          *              p_used      is a pointer to a variable that will receive the number of used 'entries' on the task's stack.
   1617          *
   1618          *              p_err       is a pointer to a variable that will contain an error code.
   1619          *
   1620          *                              OS_ERR_NONE               upon success
   1621          *                              OS_ERR_PTR_INVALID        if either 'p_free' or 'p_used' are NULL pointers
   1622          *                              OS_ERR_TASK_NOT_EXIST     if the stack pointer of the task is a NULL pointer
   1623          *                              OS_ERR_TASK_OPT           if you did NOT specified OS_OPT_TASK_STK_CHK when the task
   1624          *                                                        was created
   1625          *                              OS_ERR_TASK_STK_CHK_ISR   you called this function from an ISR
   1626          ************************************************************************************************************************
   1627          */
   1628          
   1629          #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1630          void  OSTaskStkChk (OS_TCB        *p_tcb,
   1631                              CPU_STK_SIZE  *p_free,
   1632                              CPU_STK_SIZE  *p_used,
   1633                              OS_ERR        *p_err)
   1634          {
   \                     OSTaskStkChk: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1635              CPU_STK_SIZE  free_stk;
   1636              CPU_STK      *p_stk;
   1637              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   1638          
   1639          
   1640          
   1641          #ifdef OS_SAFETY_CRITICAL
   1642              if (p_err == (OS_ERR *)0) {
   1643                  OS_SAFETY_CRITICAL_EXCEPTION();
   1644                  return;
   1645              }
   1646          #endif
   1647          
   1648          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1649              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??OSTaskStkChk_0
   1650                 *p_err = OS_ERR_TASK_STK_CHK_ISR;
   \   0000001A   0xF247 0x1059      MOVW     R0,#+29017
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
   1651                  return;
   \   00000020   0xE051             B.N      ??OSTaskStkChk_1
   1652              }
   1653          #endif
   1654          
   1655          #if OS_CFG_ARG_CHK_EN > 0u
   1656              if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
   \                     ??OSTaskStkChk_0: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD103             BNE.N    ??OSTaskStkChk_2
   1657                 *p_err  = OS_ERR_PTR_INVALID;
   \   00000026   0xF246 0x20D5      MOVW     R0,#+25301
   \   0000002A   0x8038             STRH     R0,[R7, #+0]
   1658                  return;
   \   0000002C   0xE04B             B.N      ??OSTaskStkChk_1
   1659              }
   1660          
   1661              if (p_used == (CPU_STK_SIZE*)0) {
   \                     ??OSTaskStkChk_2: (+1)
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD103             BNE.N    ??OSTaskStkChk_3
   1662                 *p_err  = OS_ERR_PTR_INVALID;
   \   00000032   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000036   0x8038             STRH     R0,[R7, #+0]
   1663                  return;
   \   00000038   0xE045             B.N      ??OSTaskStkChk_1
   1664              }
   1665          #endif
   1666          
   1667              CPU_CRITICAL_ENTER();
   \                     ??OSTaskStkChk_3: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4682             MOV      R10,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
   1668              if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD103             BNE.N    ??OSTaskStkChk_4
   1669                  p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x0004             MOVS     R4,R0
   1670              }
   1671          
   1672              if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
   \                     ??OSTaskStkChk_4: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD10C             BNE.N    ??OSTaskStkChk_5
   1673                  CPU_CRITICAL_EXIT();
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005A   0x4650             MOV      R0,R10
   \   0000005C   0x.... 0x....      BL       CPU_SR_Restore
   1674                 *p_free = (CPU_STK_SIZE)0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6028             STR      R0,[R5, #+0]
   1675                 *p_used = (CPU_STK_SIZE)0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x6030             STR      R0,[R6, #+0]
   1676                 *p_err  =  OS_ERR_TASK_NOT_EXIST;
   \   00000068   0xF247 0x1052      MOVW     R0,#+29010
   \   0000006C   0x8038             STRH     R0,[R7, #+0]
   1677                  return;
   \   0000006E   0xE02A             B.N      ??OSTaskStkChk_1
   1678              }
   1679          
   1680              if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
   \                     ??OSTaskStkChk_5: (+1)
   \   00000070   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000074   0x07C0             LSLS     R0,R0,#+31
   \   00000076   0xD40C             BMI.N    ??OSTaskStkChk_6
   1681                  CPU_CRITICAL_EXIT();
   \   00000078   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007C   0x4650             MOV      R0,R10
   \   0000007E   0x.... 0x....      BL       CPU_SR_Restore
   1682                 *p_free = (CPU_STK_SIZE)0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x6028             STR      R0,[R5, #+0]
   1683                 *p_used = (CPU_STK_SIZE)0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x6030             STR      R0,[R6, #+0]
   1684                 *p_err  =  OS_ERR_TASK_OPT;
   \   0000008A   0xF247 0x1054      MOVW     R0,#+29012
   \   0000008E   0x8038             STRH     R0,[R7, #+0]
   1685                  return;
   \   00000090   0xE019             B.N      ??OSTaskStkChk_1
   1686              }
   1687              CPU_CRITICAL_EXIT();
   \                     ??OSTaskStkChk_6: (+1)
   \   00000092   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000096   0x4650             MOV      R0,R10
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
   1688          
   1689              free_stk  = 0u;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x4680             MOV      R8,R0
   1690          #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
   1691              p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
   \   000000A0   0x6A60             LDR      R0,[R4, #+36]
   \   000000A2   0x4681             MOV      R9,R0
   1692              while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
   \                     ??OSTaskStkChk_7: (+1)
   \   000000A4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD104             BNE.N    ??OSTaskStkChk_8
   1693                  p_stk++;
   \   000000AC   0xF119 0x0904      ADDS     R9,R9,#+4
   1694                  free_stk++;
   \   000000B0   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000B4   0xE7F6             B.N      ??OSTaskStkChk_7
   1695              }
   1696          #else
   1697              p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
   1698              while (*p_stk == (CPU_STK)0) {
   1699                  free_stk++;
   1700                  p_stk--;
   1701              }
   1702          #endif
   1703             *p_free = free_stk;
   \                     ??OSTaskStkChk_8: (+1)
   \   000000B6   0xF8C5 0x8000      STR      R8,[R5, #+0]
   1704             *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
   \   000000BA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000BC   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000000C0   0x6030             STR      R0,[R6, #+0]
   1705             *p_err  = OS_ERR_NONE;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x8038             STRH     R0,[R7, #+0]
   1706          }
   \                     ??OSTaskStkChk_1: (+1)
   \   000000C6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1707          #endif
   1708          
   1709          /*$PAGE*/
   1710          /*
   1711          ************************************************************************************************************************
   1712          *                                                   SUSPEND A TASK
   1713          *
   1714          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   1715          *              or the pointer to the TCB of the calling task.
   1716          *
   1717          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   1718          *                       If p_tcb is a NULL pointer then, suspend the current task.
   1719          *
   1720          *              p_err    is a pointer to a variable that will receive an error code from this function.
   1721          *
   1722          *                           OS_ERR_NONE                      if the requested task is suspended
   1723          *                           OS_ERR_SCHED_LOCKED              you can't suspend the current task is the scheduler is
   1724          *                                                            locked
   1725          *                           OS_ERR_TASK_SUSPEND_ISR          if you called this function from an ISR
   1726          *                           OS_ERR_TASK_SUSPEND_IDLE         if you attempted to suspend the idle task which is not
   1727          *                                                            allowed.
   1728          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER  if you attempted to suspend the idle task which is not
   1729          *                                                            allowed.
   1730          *
   1731          * Note(s)    : 1) You should use this function with great care.  If you suspend a task that is waiting for an event
   1732          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   1733          *                 arrives.
   1734          ************************************************************************************************************************
   1735          */
   1736          
   1737          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1738          void   OSTaskSuspend (OS_TCB  *p_tcb,
   1739                                OS_ERR  *p_err)
   1740          {
   \                     OSTaskSuspend: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1741          #ifdef OS_SAFETY_CRITICAL
   1742              if (p_err == (OS_ERR *)0) {
   1743                  OS_SAFETY_CRITICAL_EXCEPTION();
   1744                  return;
   1745              }
   1746          #endif
   1747          
   1748          #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
   1749              (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
   1750              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1751                 *p_err = OS_ERR_TASK_SUSPEND_ISR;
   1752                  return;
   1753              }
   1754          #endif
   1755          
   1756              if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD103             BNE.N    ??OSTaskSuspend_0
   1757                 *p_err = OS_ERR_TASK_SUSPEND_IDLE;
   \   00000010   0xF247 0x105B      MOVW     R0,#+29019
   \   00000014   0x8028             STRH     R0,[R5, #+0]
   1758                  return;
   \   00000016   0xE01F             B.N      ??OSTaskSuspend_1
   1759              }
   1760          
   1761          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1762              if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
   \                     ??OSTaskSuspend_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD103             BNE.N    ??OSTaskSuspend_2
   1763                 *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
   \   00000020   0xF247 0x105C      MOVW     R0,#+29020
   \   00000024   0x8028             STRH     R0,[R5, #+0]
   1764                  return;
   \   00000026   0xE017             B.N      ??OSTaskSuspend_1
   1765              }
   1766          
   1767              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \                     ??OSTaskSuspend_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00E             BEQ.N    ??OSTaskSuspend_3
   1768                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SUSPEND,  /* Post to ISR queue                                      */
   1769                              (void      *)p_tcb,
   1770                              (void      *)0,
   1771                              (OS_MSG_SIZE)0,
   1772                              (OS_FLAGS   )0,
   1773                              (OS_OPT     )0,
   1774                              (CPU_TS     )0,
   1775                              (OS_ERR    *)p_err);
   \   00000032   0x9503             STR      R5,[SP, #+12]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9002             STR      R0,[SP, #+8]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0x53555354
   \   0000004A   0x.... 0x....      BL       OS_IntQPost
   1776                  return;
   \   0000004E   0xE003             B.N      ??OSTaskSuspend_1
   1777              }
   1778          #endif
   1779          
   1780              OS_TaskSuspend(p_tcb, p_err);
   \                     ??OSTaskSuspend_3: (+1)
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OS_TaskSuspend
   1781          }
   \                     ??OSTaskSuspend_1: (+1)
   \   00000058   0xB005             ADD      SP,SP,#+20
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
   1782          #endif
   1783          
   1784          /*$PAGE*/
   1785          /*
   1786          ************************************************************************************************************************
   1787          *                                                CHANGE A TASK'S TIME SLICE
   1788          *
   1789          * Description: This function is called to change the value of the task's specific time slice.
   1790          *
   1791          * Arguments  : p_tcb        is the pointer to the TCB of the task to change. If you specify an NULL pointer, the current
   1792          *                           task is assumed.
   1793          *
   1794          *              time_quanta  is the number of ticks before the CPU is taken away when round-robin scheduling is enabled.
   1795          *
   1796          *              p_err        is a pointer to an error code returned by this function:
   1797          *
   1798          *                               OS_ERR_NONE       upon success
   1799          *                               OS_ERR_SET_ISR    if you called this function from an ISR
   1800          *
   1801          * Returns    : none
   1802          ************************************************************************************************************************
   1803          */
   1804          
   1805          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1806          void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
   1807                                     OS_TICK   time_quanta,
   1808                                     OS_ERR   *p_err)
   1809          {
   \                     OSTaskTimeQuantaSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1810              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   1811          
   1812          
   1813          
   1814          #ifdef OS_SAFETY_CRITICAL
   1815              if (p_err == (OS_ERR *)0) {
   1816                  OS_SAFETY_CRITICAL_EXCEPTION();
   1817                  return;
   1818              }
   1819          #endif
   1820          
   1821          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1822              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSTaskTimeQuantaSet_0
   1823                 *p_err = OS_ERR_SET_ISR;
   \   00000014   0xF646 0x50C6      MOVW     R0,#+28102
   \   00000018   0x8030             STRH     R0,[R6, #+0]
   1824                  return;
   \   0000001A   0xE01F             B.N      ??OSTaskTimeQuantaSet_1
   1825              }
   1826          #endif
   1827          
   1828              CPU_CRITICAL_ENTER();
   \                     ??OSTaskTimeQuantaSet_0: (+1)
   \   0000001C   0x.... 0x....      BL       CPU_SR_Save
   \   00000020   0x0007             MOVS     R7,R0
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStart
   1829              if (p_tcb == (OS_TCB *)0) {
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD103             BNE.N    ??OSTaskTimeQuantaSet_2
   1830                  p_tcb = OSTCBCurPtr;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0004             MOVS     R4,R0
   1831              }
   1832          
   1833              if (time_quanta == 0u) {
   \                     ??OSTaskTimeQuantaSet_2: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD104             BNE.N    ??OSTaskTimeQuantaSet_3
   1834                  p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x6560             STR      R0,[R4, #+84]
   \   0000003E   0xE000             B.N      ??OSTaskTimeQuantaSet_4
   1835              } else {
   1836                  p_tcb->TimeQuanta    = time_quanta;
   \                     ??OSTaskTimeQuantaSet_3: (+1)
   \   00000040   0x6565             STR      R5,[R4, #+84]
   1837              }
   1838              if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
   \                     ??OSTaskTimeQuantaSet_4: (+1)
   \   00000042   0x6DA0             LDR      R0,[R4, #+88]
   \   00000044   0x6D61             LDR      R1,[R4, #+84]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD201             BCS.N    ??OSTaskTimeQuantaSet_5
   1839                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
   \   0000004A   0x6D60             LDR      R0,[R4, #+84]
   \   0000004C   0x65A0             STR      R0,[R4, #+88]
   1840              }
   1841              CPU_CRITICAL_EXIT();
   \                     ??OSTaskTimeQuantaSet_5: (+1)
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
   1842             *p_err = OS_ERR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x8030             STRH     R0,[R6, #+0]
   1843          }
   \                     ??OSTaskTimeQuantaSet_1: (+1)
   \   0000005C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1844          #endif
   1845          
   1846          /*$PAGE*/
   1847          /*
   1848          ************************************************************************************************************************
   1849          *                                            ADD/REMOVE TASK TO/FROM DEBUG LIST
   1850          *
   1851          * Description: These functions are called by uC/OS-III to add or remove an OS_TCB from the debug list.
   1852          *
   1853          * Arguments  : p_tcb     is a pointer to the OS_TCB to add/remove
   1854          *
   1855          * Returns    : none
   1856          *
   1857          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1858          ************************************************************************************************************************
   1859          */
   1860          
   1861          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1862          void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
   1863          {
   1864              p_tcb->DbgPrevPtr                = (OS_TCB *)0;
   \                     OS_TaskDbgListAdd: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF8C0 0x10BC      STR      R1,[R0, #+188]
   1865              if (OSTaskDbgListPtr == (OS_TCB *)0) {
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD103             BNE.N    ??OS_TaskDbgListAdd_0
   1866                  p_tcb->DbgNextPtr            = (OS_TCB *)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF8C0 0x10C0      STR      R1,[R0, #+192]
   \   00000016   0xE009             B.N      ??OS_TaskDbgListAdd_1
   1867              } else {
   1868                  p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
   \                     ??OS_TaskDbgListAdd_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF8C0 0x10C0      STR      R1,[R0, #+192]
   1869                  OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0xF8C1 0x00BC      STR      R0,[R1, #+188]
   1870              }
   1871              OSTaskDbgListPtr                 =  p_tcb;
   \                     ??OS_TaskDbgListAdd_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1872          }
   \   00000032   0x4770             BX       LR               ;; return
   1873          
   1874          
   1875          

   \                                 In section .text, align 2, keep-with-next
   1876          void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
   1877          {
   1878              OS_TCB  *p_tcb_next;
   1879              OS_TCB  *p_tcb_prev;
   1880          
   1881          
   1882              p_tcb_prev = p_tcb->DbgPrevPtr;
   \                     OS_TaskDbgListRemove: (+1)
   \   00000000   0xF8D0 0x30BC      LDR      R3,[R0, #+188]
   \   00000004   0x001A             MOVS     R2,R3
   1883              p_tcb_next = p_tcb->DbgNextPtr;
   \   00000006   0xF8D0 0x30C0      LDR      R3,[R0, #+192]
   \   0000000A   0x0019             MOVS     R1,R3
   1884          
   1885              if (p_tcb_prev == (OS_TCB *)0) {
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD10B             BNE.N    ??OS_TaskDbgListRemove_0
   1886                  OSTaskDbgListPtr = p_tcb_next;
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable26_7
   \   00000014   0x6019             STR      R1,[R3, #+0]
   1887                  if (p_tcb_next != (OS_TCB *)0) {
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD002             BEQ.N    ??OS_TaskDbgListRemove_1
   1888                      p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0xF8C1 0x30BC      STR      R3,[R1, #+188]
   1889                  }
   1890                  p_tcb->DbgNextPtr = (OS_TCB *)0;
   \                     ??OS_TaskDbgListRemove_1: (+1)
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0xF8C0 0x30C0      STR      R3,[R0, #+192]
   \   00000026   0xE012             B.N      ??OS_TaskDbgListRemove_2
   1891          
   1892              } else if (p_tcb_next == (OS_TCB *)0) {
   \                     ??OS_TaskDbgListRemove_0: (+1)
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD106             BNE.N    ??OS_TaskDbgListRemove_3
   1893                  p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0xF8C2 0x30C0      STR      R3,[R2, #+192]
   1894                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0xF8C0 0x30BC      STR      R3,[R0, #+188]
   \   00000038   0xE009             B.N      ??OS_TaskDbgListRemove_2
   1895          
   1896              } else {
   1897                  p_tcb_prev->DbgNextPtr =  p_tcb_next;
   \                     ??OS_TaskDbgListRemove_3: (+1)
   \   0000003A   0xF8C2 0x10C0      STR      R1,[R2, #+192]
   1898                  p_tcb_next->DbgPrevPtr =  p_tcb_prev;
   \   0000003E   0xF8C1 0x20BC      STR      R2,[R1, #+188]
   1899                  p_tcb->DbgNextPtr      = (OS_TCB *)0;
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0xF8C0 0x30C0      STR      R3,[R0, #+192]
   1900                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0xF8C0 0x30BC      STR      R3,[R0, #+188]
   1901              }
   1902          }
   \                     ??OS_TaskDbgListRemove_2: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
   1903          #endif
   1904          
   1905          /*$PAGE*/
   1906          /*
   1907          ************************************************************************************************************************
   1908          *                                             TASK MANAGER INITIALIZATION
   1909          *
   1910          * Description: This function is called by OSInit() to initialize the task management.
   1911          *
   1912          
   1913          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
   1914          *
   1915          *                                OS_ERR_NONE     the call was successful
   1916          *
   1917          * Returns    : none
   1918          *
   1919          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1920          ************************************************************************************************************************
   1921          */
   1922          

   \                                 In section .text, align 2, keep-with-next
   1923          void  OS_TaskInit (OS_ERR  *p_err)
   1924          {
   1925          #ifdef OS_SAFETY_CRITICAL
   1926              if (p_err == (OS_ERR *)0) {
   1927                  OS_SAFETY_CRITICAL_EXCEPTION();
   1928                  return;
   1929              }
   1930          #endif
   1931          
   1932          #if OS_CFG_DBG_EN > 0u
   1933              OSTaskDbgListPtr = (OS_TCB      *)0;
   \                     OS_TaskInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable26_7
   \   00000006   0x6011             STR      R1,[R2, #+0]
   1934          #endif
   1935          
   1936              OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable26_8
   \   0000000E   0x8011             STRH     R1,[R2, #+0]
   1937              OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1938          
   1939             *p_err            = OS_ERR_NONE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
   1940          }
   \   0000001C   0x4770             BX       LR               ;; return
   1941          
   1942          /*$PAGE*/
   1943          /*
   1944          ************************************************************************************************************************
   1945          *                                               INITIALIZE TCB FIELDS
   1946          *
   1947          * Description: This function is called to initialize a TCB to default values
   1948          *
   1949          * Arguments  : p_tcb    is a pointer to the TCB to initialize
   1950          *
   1951          * Returns    : none
   1952          *
   1953          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1954          ************************************************************************************************************************
   1955          */
   1956          

   \                                 In section .text, align 2, keep-with-next
   1957          void  OS_TaskInitTCB (OS_TCB  *p_tcb)
   1958          {
   \                     OS_TaskInitTCB: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1959          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   1960              OS_REG_ID   reg_id;
   1961          #endif
   1962          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   1963              OS_TLS_ID   id;
   1964          #endif
   1965          #if OS_CFG_TASK_PROFILE_EN > 0u
   1966              CPU_TS      ts;
   1967          #endif
   1968          
   1969          
   1970              p_tcb->StkPtr             = (CPU_STK       *)0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
   1971              p_tcb->StkLimitPtr        = (CPU_STK       *)0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x60A0             STR      R0,[R4, #+8]
   1972          
   1973              p_tcb->ExtPtr             = (void          *)0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
   1974          
   1975              p_tcb->NextPtr            = (OS_TCB        *)0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x60E0             STR      R0,[R4, #+12]
   1976              p_tcb->PrevPtr            = (OS_TCB        *)0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6120             STR      R0,[R4, #+16]
   1977          
   1978              p_tcb->TickNextPtr        = (OS_TCB        *)0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6160             STR      R0,[R4, #+20]
   1979              p_tcb->TickPrevPtr        = (OS_TCB        *)0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61A0             STR      R0,[R4, #+24]
   1980              p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x61E0             STR      R0,[R4, #+28]
   1981          
   1982              p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000028   0x6220             STR      R0,[R4, #+32]
   1983          
   1984              p_tcb->StkBasePtr         = (CPU_STK       *)0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6260             STR      R0,[R4, #+36]
   1985          
   1986              p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x62A0             STR      R0,[R4, #+40]
   1987              p_tcb->TaskEntryArg       = (void          *)0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x62E0             STR      R0,[R4, #+44]
   1988          
   1989          #if (OS_CFG_PEND_MULTI_EN > 0u)
   1990              p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6320             STR      R0,[R4, #+48]
   1991              p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x87E0             STRH     R0,[R4, #+62]
   1992          #endif
   1993          
   1994              p_tcb->TS                 = (CPU_TS         )0u;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6420             STR      R0,[R4, #+64]
   1995          
   1996          #if (OS_MSG_EN > 0u)
   1997              p_tcb->MsgPtr             = (void          *)0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x65E0             STR      R0,[R4, #+92]
   1998              p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF8A4 0x0060      STRH     R0,[R4, #+96]
   1999          #endif
   2000          
   2001          #if OS_CFG_TASK_Q_EN > 0u
   2002              OS_MsgQInit(&p_tcb->MsgQ,
   2003                          (OS_MSG_QTY)0u);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xF114 0x0064      ADDS     R0,R4,#+100
   \   00000052   0x.... 0x....      BL       OS_MsgQInit
   2004          #if OS_CFG_TASK_PROFILE_EN > 0u
   2005              p_tcb->MsgQPendTime       = (CPU_TS         )0u;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6760             STR      R0,[R4, #+116]
   2006              p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x67A0             STR      R0,[R4, #+120]
   2007          #endif
   2008          #endif
   2009          
   2010          #if OS_CFG_FLAG_EN > 0u
   2011              p_tcb->FlagsPend          = (OS_FLAGS       )0u;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8C4 0x0080      STR      R0,[R4, #+128]
   2012              p_tcb->FlagsOpt           = (OS_OPT         )0u;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF8A4 0x0088      STRH     R0,[R4, #+136]
   2013              p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF8C4 0x0084      STR      R0,[R4, #+132]
   2014          #endif
   2015          
   2016          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   2017              for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x0005             MOVS     R5,R0
   \                     ??OS_TaskInitTCB_0: (+1)
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD106             BNE.N    ??OS_TaskInitTCB_1
   2018                  p_tcb->RegTbl[reg_id] = (OS_REG)0u;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000082   0x67C8             STR      R0,[R1, #+124]
   2019              }
   \   00000084   0x1C6D             ADDS     R5,R5,#+1
   \   00000086   0xE7F5             B.N      ??OS_TaskInitTCB_0
   2020          #endif
   2021          
   2022          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2023              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
   2024                  p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
   2025              }
   2026          #endif
   2027          
   2028              p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
   \                     ??OS_TaskInitTCB_1: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x6460             STR      R0,[R4, #+68]
   2029          #if OS_CFG_TASK_PROFILE_EN > 0u
   2030              p_tcb->SemPendTime        = (CPU_TS         )0u;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF8C4 0x00A4      STR      R0,[R4, #+164]
   2031              p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF8C4 0x00A8      STR      R0,[R4, #+168]
   2032          #endif
   2033          
   2034              p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x63A0             STR      R0,[R4, #+56]
   2035          
   2036          
   2037          #if OS_CFG_TASK_SUSPEND_EN > 0u
   2038              p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x008A      STRB     R0,[R4, #+138]
   2039          #endif
   2040          
   2041          #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
   2042              p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF8C4 0x00B0      STR      R0,[R4, #+176]
   2043              p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF8C4 0x00AC      STR      R0,[R4, #+172]
   2044          #endif
   2045          
   2046              p_tcb->Opt                = (OS_OPT         )0u;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x87A0             STRH     R0,[R4, #+60]
   2047          
   2048              p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
   \   000000B2   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   000000B6   0x64A0             STR      R0,[R4, #+72]
   2049              p_tcb->TickCtrMatch       = (OS_TICK        )0u;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x64E0             STR      R0,[R4, #+76]
   2050              p_tcb->TickRemain         = (OS_TICK        )0u;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x6520             STR      R0,[R4, #+80]
   2051          
   2052              p_tcb->TimeQuanta         = (OS_TICK        )0u;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x6560             STR      R0,[R4, #+84]
   2053              p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x65A0             STR      R0,[R4, #+88]
   2054          
   2055          #if OS_CFG_TASK_PROFILE_EN > 0u
   2056              p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF8A4 0x008C      STRH     R0,[R4, #+140]
   2057              p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF8A4 0x008E      STRH     R0,[R4, #+142]
   2058              p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF8C4 0x0090      STR      R0,[R4, #+144]
   2059              p_tcb->CyclesDelta        = (CPU_TS         )0u;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF8C4 0x0094      STR      R0,[R4, #+148]
   2060              ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
   \   000000E0   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000E4   0x0006             MOVS     R6,R0
   2061              p_tcb->CyclesStart        = ts;
   \   000000E6   0xF8C4 0x6098      STR      R6,[R4, #+152]
   2062              p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xF8C4 0x009C      STR      R0,[R4, #+156]
   2063          #endif
   2064          #ifdef CPU_CFG_INT_DIS_MEAS_EN
   2065              p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xF8C4 0x00B4      STR      R0,[R4, #+180]
   2066          #endif
   2067          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
   2068              p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF8C4 0x00B8      STR      R0,[R4, #+184]
   2069          #endif
   2070          
   2071              p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF884 0x0034      STRB     R0,[R4, #+52]
   2072              p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0xF884 0x0035      STRB     R0,[R4, #+53]
   2073              p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xF884 0x0036      STRB     R0,[R4, #+54]
   2074          
   2075              p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
   \   0000010E   0x2020             MOVS     R0,#+32
   \   00000110   0xF884 0x0037      STRB     R0,[R4, #+55]
   2076          
   2077          #if OS_CFG_DBG_EN > 0u
   2078              p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF8C4 0x00BC      STR      R0,[R4, #+188]
   2079              p_tcb->DbgNextPtr         = (OS_TCB        *)0;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xF8C4 0x00C0      STR      R0,[R4, #+192]
   2080              p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
   \   00000120   0x....             ADR.N    R0,??DataTable23  ;; " "
   \   00000122   0xF8C4 0x00C4      STR      R0,[R4, #+196]
   2081          #endif
   2082          }
   \   00000126   0xBD70             POP      {R4-R6,PC}       ;; return
   2083          
   2084          /*$PAGE*/
   2085          /*
   2086          ************************************************************************************************************************
   2087          *                                               POST MESSAGE TO A TASK
   2088          *
   2089          * Description: This function sends a message to a task
   2090          *
   2091          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
   2092          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
   2093          *                         posting a message to yourself.
   2094          *
   2095          *              p_void     is a pointer to the message to send.
   2096          *
   2097          *              msg_size   is the size of the message sent (in #bytes)
   2098          *
   2099          *              opt        specifies whether the post will be FIFO or LIFO:
   2100          *
   2101          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
   2102          *                             OS_OPT_POST_LIFO       Post at the front of the queue
   2103          *
   2104          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
   2105          *
   2106          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
   2107          *
   2108          *
   2109          *              ts         is a timestamp indicating when the post occurred.
   2110          *
   2111          *              p_err      is a pointer to a variable that will hold the error code associated
   2112          *                         with the outcome of this call.  Errors can be:
   2113          *
   2114          *                             OS_ERR_NONE            The call was successful and the message was sent
   2115          *                             OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs available from the pool
   2116          *                             OS_ERR_Q_MAX           If the queue is full
   2117          *                             OS_ERR_STATE_INVALID   If the task is in an invalid state.  This should never happen
   2118          *                                                    and if it does, would be considered a system failure.
   2119          *
   2120          * Returns    : none
   2121          *
   2122          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2123          ************************************************************************************************************************
   2124          */
   2125          
   2126          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2127          void  OS_TaskQPost (OS_TCB       *p_tcb,
   2128                              void         *p_void,
   2129                              OS_MSG_SIZE   msg_size,
   2130                              OS_OPT        opt,
   2131                              CPU_TS        ts,
   2132                              OS_ERR       *p_err)
   2133          {
   \                     OS_TaskQPost: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000010   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   2134              CPU_SR_ALLOC();
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   2135          
   2136          
   2137          
   2138              OS_CRITICAL_ENTER();
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x4682             MOV      R10,R0
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD101             BNE.N    ??OS_TaskQPost_0
   \   0000003A   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_TaskQPost_0: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000042   0x4650             MOV      R0,R10
   \   00000044   0x.... 0x....      BL       CPU_SR_Restore
   2139              if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD103             BNE.N    ??OS_TaskQPost_1
   2140                  p_tcb = OSTCBCurPtr;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x0004             MOVS     R4,R0
   2141              }
   2142             *p_err  = OS_ERR_NONE;                                   /* Assume we won't have any errors                        */
   \                     ??OS_TaskQPost_1: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   2143              switch (p_tcb->TaskState) {
   \   0000005A   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD00B             BEQ.N    ??OS_TaskQPost_2
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD042             BEQ.N    ??OS_TaskQPost_3
   \   00000066   0xD308             BCC.N    ??OS_TaskQPost_2
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xD006             BEQ.N    ??OS_TaskQPost_2
   \   0000006C   0xD33E             BCC.N    ??OS_TaskQPost_3
   \   0000006E   0x2806             CMP      R0,#+6
   \   00000070   0xD03C             BEQ.N    ??OS_TaskQPost_3
   \   00000072   0xD302             BCC.N    ??OS_TaskQPost_2
   \   00000074   0x2807             CMP      R0,#+7
   \   00000076   0xD039             BEQ.N    ??OS_TaskQPost_3
   \   00000078   0xE09B             B.N      ??OS_TaskQPost_4
   2144                  case OS_TASK_STATE_RDY:
   2145                  case OS_TASK_STATE_DLY:
   2146                  case OS_TASK_STATE_SUSPENDED:
   2147                  case OS_TASK_STATE_DLY_SUSPENDED:
   2148                       OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
   2149                                  p_void,
   2150                                  msg_size,
   2151                                  opt,
   2152                                  ts,
   2153                                  p_err);
   \                     ??OS_TaskQPost_2: (+1)
   \   0000007A   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000007E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000082   0x003B             MOVS     R3,R7
   \   00000084   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000086   0x0032             MOVS     R2,R6
   \   00000088   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0xF114 0x0064      ADDS     R0,R4,#+100
   \   00000090   0x.... 0x....      BL       OS_MsgQPut
   2154                       OS_CRITICAL_EXIT();
   \   00000094   0x.... 0x....      BL       CPU_SR_Save
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD114             BNE.N    ??OS_TaskQPost_5
   \   000000B6   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   000000BE   0x8800             LDRH     R0,[R0, #+0]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD007             BEQ.N    ??OS_TaskQPost_6
   \   000000C4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C8   0x4650             MOV      R0,R10
   \   000000CA   0x.... 0x....      BL       CPU_SR_Restore
   \   000000CE   0x.... 0x....      BL       OS_Sched0
   \   000000D2   0xE00A             B.N      ??OS_TaskQPost_7
   \                     ??OS_TaskQPost_6: (+1)
   \   000000D4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D8   0x4650             MOV      R0,R10
   \   000000DA   0x.... 0x....      BL       CPU_SR_Restore
   \   000000DE   0xE004             B.N      ??OS_TaskQPost_7
   \                     ??OS_TaskQPost_5: (+1)
   \   000000E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E4   0x4650             MOV      R0,R10
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
   2155                       break;
   \                     ??OS_TaskQPost_7: (+1)
   \   000000EA   0xE091             B.N      ??OS_TaskQPost_8
   2156          
   2157                  case OS_TASK_STATE_PEND:
   2158                  case OS_TASK_STATE_PEND_TIMEOUT:
   2159                  case OS_TASK_STATE_PEND_SUSPENDED:
   2160                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2161                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
   \                     ??OS_TaskQPost_3: (+1)
   \   000000EC   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   000000F0   0x2802             CMP      R0,#+2
   \   000000F2   0xD125             BNE.N    ??OS_TaskQPost_9
   2162                           OS_Post((OS_PEND_OBJ *)0,
   2163                                   p_tcb,
   2164                                   p_void,
   2165                                   msg_size,
   2166                                   ts);
   \   000000F4   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000F8   0x0033             MOVS     R3,R6
   \   000000FA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000FC   0x002A             MOVS     R2,R5
   \   000000FE   0x0021             MOVS     R1,R4
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      BL       OS_Post
   2167                           OS_CRITICAL_EXIT_NO_SCHED();
   \   00000106   0x.... 0x....      BL       CPU_SR_Save
   \   0000010A   0x4682             MOV      R10,R0
   \   0000010C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000011C   0x7008             STRB     R0,[R1, #+0]
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD101             BNE.N    ??OS_TaskQPost_10
   \   00000128   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_TaskQPost_10: (+1)
   \   0000012C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000130   0x4650             MOV      R0,R10
   \   00000132   0x.... 0x....      BL       CPU_SR_Restore
   2168                           if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   00000136   0x0438             LSLS     R0,R7,#+16
   \   00000138   0xD43A             BMI.N    ??OS_TaskQPost_11
   2169                               OSSched();                             /* Run the scheduler                                      */
   \   0000013A   0x.... 0x....      BL       OSSched
   \   0000013E   0xE037             B.N      ??OS_TaskQPost_11
   2170                           }
   2171                       } else {
   2172                           OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
   2173                                      p_void,                         /*      ... Deposit the message in the task's queue       */
   2174                                      msg_size,
   2175                                      opt,
   2176                                      ts,
   2177                                      p_err);
   \                     ??OS_TaskQPost_9: (+1)
   \   00000140   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000144   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000148   0x003B             MOVS     R3,R7
   \   0000014A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000014C   0x0032             MOVS     R2,R6
   \   0000014E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000150   0x0029             MOVS     R1,R5
   \   00000152   0xF114 0x0064      ADDS     R0,R4,#+100
   \   00000156   0x.... 0x....      BL       OS_MsgQPut
   2178                           OS_CRITICAL_EXIT();
   \   0000015A   0x.... 0x....      BL       CPU_SR_Save
   \   0000015E   0x4682             MOV      R10,R0
   \   00000160   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000168   0x7800             LDRB     R0,[R0, #+0]
   \   0000016A   0x1E40             SUBS     R0,R0,#+1
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000170   0x7008             STRB     R0,[R1, #+0]
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000176   0x7800             LDRB     R0,[R0, #+0]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD114             BNE.N    ??OS_TaskQPost_12
   \   0000017C   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   00000184   0x8800             LDRH     R0,[R0, #+0]
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD007             BEQ.N    ??OS_TaskQPost_13
   \   0000018A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000018E   0x4650             MOV      R0,R10
   \   00000190   0x.... 0x....      BL       CPU_SR_Restore
   \   00000194   0x.... 0x....      BL       OS_Sched0
   \   00000198   0xE00A             B.N      ??OS_TaskQPost_14
   \                     ??OS_TaskQPost_13: (+1)
   \   0000019A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000019E   0x4650             MOV      R0,R10
   \   000001A0   0x.... 0x....      BL       CPU_SR_Restore
   \   000001A4   0xE004             B.N      ??OS_TaskQPost_14
   \                     ??OS_TaskQPost_12: (+1)
   \   000001A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001AA   0x4650             MOV      R0,R10
   \   000001AC   0x.... 0x....      BL       CPU_SR_Restore
   2179                       }
   2180                       break;
   \                     ??OS_TaskQPost_14: (+1)
   \                     ??OS_TaskQPost_11: (+1)
   \   000001B0   0xE02E             B.N      ??OS_TaskQPost_8
   2181          
   2182                  default:
   2183                       OS_CRITICAL_EXIT();
   \                     ??OS_TaskQPost_4: (+1)
   \   000001B2   0x.... 0x....      BL       CPU_SR_Save
   \   000001B6   0x4682             MOV      R10,R0
   \   000001B8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000001C0   0x7800             LDRB     R0,[R0, #+0]
   \   000001C2   0x1E40             SUBS     R0,R0,#+1
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable26
   \   000001C8   0x7008             STRB     R0,[R1, #+0]
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000001CE   0x7800             LDRB     R0,[R0, #+0]
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD114             BNE.N    ??OS_TaskQPost_15
   \   000001D4   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   000001DC   0x8800             LDRH     R0,[R0, #+0]
   \   000001DE   0x2800             CMP      R0,#+0
   \   000001E0   0xD007             BEQ.N    ??OS_TaskQPost_16
   \   000001E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001E6   0x4650             MOV      R0,R10
   \   000001E8   0x.... 0x....      BL       CPU_SR_Restore
   \   000001EC   0x.... 0x....      BL       OS_Sched0
   \   000001F0   0xE00A             B.N      ??OS_TaskQPost_17
   \                     ??OS_TaskQPost_16: (+1)
   \   000001F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001F6   0x4650             MOV      R0,R10
   \   000001F8   0x.... 0x....      BL       CPU_SR_Restore
   \   000001FC   0xE004             B.N      ??OS_TaskQPost_17
   \                     ??OS_TaskQPost_15: (+1)
   \   000001FE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000202   0x4650             MOV      R0,R10
   \   00000204   0x.... 0x....      BL       CPU_SR_Restore
   2184                      *p_err = OS_ERR_STATE_INVALID;
   \                     ??OS_TaskQPost_17: (+1)
   \   00000208   0xF646 0x602D      MOVW     R0,#+28205
   \   0000020C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   2185                       break;
   2186              }
   2187          }
   \                     ??OS_TaskQPost_8: (+1)
   \   00000210   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   2188          #endif
   2189          
   2190          /*$PAGE*/
   2191          /*
   2192          ************************************************************************************************************************
   2193          *                                               RESUME A SUSPENDED TASK
   2194          *
   2195          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   2196          *              explicit task suspension.
   2197          *
   2198          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   2199          *
   2200          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   2201          *
   2202          *                             OS_ERR_NONE                  if the requested task is resumed
   2203          *                             OS_ERR_STATE_INVALID         if the task is in an invalid state
   2204          *                             OS_ERR_TASK_RESUME_ISR       if you called this function from an ISR
   2205          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   2206          *                             OS_ERR_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
   2207          *
   2208          * Returns    : none
   2209          *
   2210          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2211          ************************************************************************************************************************
   2212          */
   2213          
   2214          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2215          void  OS_TaskResume (OS_TCB  *p_tcb,
   2216                               OS_ERR  *p_err)
   2217          {
   \                     OS_TaskResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2218              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   2219          
   2220          
   2221              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
   2222             *p_err  = OS_ERR_NONE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8028             STRH     R0,[R5, #+0]
   2223              switch (p_tcb->TaskState) {
   \   00000016   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD908             BLS.N    ??OS_TaskResume_0
   \   00000020   0x1F00             SUBS     R0,R0,#+4
   \   00000022   0xD00F             BEQ.N    ??OS_TaskResume_1
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0xD048             BEQ.N    ??OS_TaskResume_2
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0xD058             BEQ.N    ??OS_TaskResume_3
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0xD068             BEQ.N    ??OS_TaskResume_4
   \   00000030   0xE079             B.N      ??OS_TaskResume_5
   2224                  case OS_TASK_STATE_RDY:
   2225                  case OS_TASK_STATE_DLY:
   2226                  case OS_TASK_STATE_PEND:
   2227                  case OS_TASK_STATE_PEND_TIMEOUT:
   2228                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskResume_0: (+1)
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
   2229                      *p_err = OS_ERR_TASK_NOT_SUSPENDED;
   \   0000003C   0xF247 0x1053      MOVW     R0,#+29011
   \   00000040   0x8028             STRH     R0,[R5, #+0]
   2230                       break;
   \   00000042   0xE079             B.N      ??OS_TaskResume_6
   2231          
   2232                  case OS_TASK_STATE_SUSPENDED:
   2233                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OS_TaskResume_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD101             BNE.N    ??OS_TaskResume_7
   \   0000005C   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_TaskResume_7: (+1)
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
   2234                       p_tcb->SuspendCtr--;
   \   0000006A   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   0000006E   0x1E40             SUBS     R0,R0,#+1
   \   00000070   0xF884 0x008A      STRB     R0,[R4, #+138]
   2235                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   \   00000074   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD105             BNE.N    ??OS_TaskResume_8
   2236                           p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF884 0x0036      STRB     R0,[R4, #+54]
   2237                           OS_TaskRdy(p_tcb);
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       OS_TaskRdy
   2238                       }
   2239                       OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OS_TaskResume_8: (+1)
   \   00000088   0x.... 0x....      BL       CPU_SR_Save
   \   0000008C   0x0006             MOVS     R6,R0
   \   0000008E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x1E40             SUBS     R0,R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD101             BNE.N    ??OS_TaskResume_9
   \   000000AA   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_TaskResume_9: (+1)
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
   2240                       break;
   \   000000B8   0xE03E             B.N      ??OS_TaskResume_6
   2241          
   2242                  case OS_TASK_STATE_DLY_SUSPENDED:
   2243                       p_tcb->SuspendCtr--;
   \                     ??OS_TaskResume_2: (+1)
   \   000000BA   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   000000BE   0x1E40             SUBS     R0,R0,#+1
   \   000000C0   0xF884 0x008A      STRB     R0,[R4, #+138]
   2244                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   \   000000C4   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD102             BNE.N    ??OS_TaskResume_10
   2245                           p_tcb->TaskState = OS_TASK_STATE_DLY;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xF884 0x0036      STRB     R0,[R4, #+54]
   2246                       }
   2247                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskResume_10: (+1)
   \   000000D2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D6   0x0030             MOVS     R0,R6
   \   000000D8   0x.... 0x....      BL       CPU_SR_Restore
   2248                       break;
   \   000000DC   0xE02C             B.N      ??OS_TaskResume_6
   2249          
   2250                  case OS_TASK_STATE_PEND_SUSPENDED:
   2251                       p_tcb->SuspendCtr--;
   \                     ??OS_TaskResume_3: (+1)
   \   000000DE   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   000000E2   0x1E40             SUBS     R0,R0,#+1
   \   000000E4   0xF884 0x008A      STRB     R0,[R4, #+138]
   2252                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   \   000000E8   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD102             BNE.N    ??OS_TaskResume_11
   2253                           p_tcb->TaskState = OS_TASK_STATE_PEND;
   \   000000F0   0x2002             MOVS     R0,#+2
   \   000000F2   0xF884 0x0036      STRB     R0,[R4, #+54]
   2254                       }
   2255                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskResume_11: (+1)
   \   000000F6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FA   0x0030             MOVS     R0,R6
   \   000000FC   0x.... 0x....      BL       CPU_SR_Restore
   2256                       break;
   \   00000100   0xE01A             B.N      ??OS_TaskResume_6
   2257          
   2258                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2259                       p_tcb->SuspendCtr--;
   \                     ??OS_TaskResume_4: (+1)
   \   00000102   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   00000106   0x1E40             SUBS     R0,R0,#+1
   \   00000108   0xF884 0x008A      STRB     R0,[R4, #+138]
   2260                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   \   0000010C   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD102             BNE.N    ??OS_TaskResume_12
   2261                           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   00000114   0x2003             MOVS     R0,#+3
   \   00000116   0xF884 0x0036      STRB     R0,[R4, #+54]
   2262                       }
   2263                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskResume_12: (+1)
   \   0000011A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011E   0x0030             MOVS     R0,R6
   \   00000120   0x.... 0x....      BL       CPU_SR_Restore
   2264                       break;
   \   00000124   0xE008             B.N      ??OS_TaskResume_6
   2265          
   2266                  default:
   2267                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskResume_5: (+1)
   \   00000126   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012A   0x0030             MOVS     R0,R6
   \   0000012C   0x.... 0x....      BL       CPU_SR_Restore
   2268                      *p_err = OS_ERR_STATE_INVALID;
   \   00000130   0xF646 0x602D      MOVW     R0,#+28205
   \   00000134   0x8028             STRH     R0,[R5, #+0]
   2269                       return;
   \   00000136   0xE001             B.N      ??OS_TaskResume_13
   2270              }
   2271          
   2272              OSSched();
   \                     ??OS_TaskResume_6: (+1)
   \   00000138   0x.... 0x....      BL       OSSched
   2273          }
   \                     ??OS_TaskResume_13: (+1)
   \   0000013C   0xBD70             POP      {R4-R6,PC}       ;; return
   2274          #endif
   2275          
   2276          /*$PAGE*/
   2277          /*
   2278          ************************************************************************************************************************
   2279          *                                              CATCH ACCIDENTAL TASK RETURN
   2280          *
   2281          * Description: This function is called if a task accidentally returns without deleting itself.  In other words, a task
   2282          *              should either be an infinite loop or delete itself if it's done.
   2283          *
   2284          * Arguments  : none
   2285          *
   2286          * Returns    : none
   2287          *
   2288          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2289          ************************************************************************************************************************
   2290          */
   2291          

   \                                 In section .text, align 2, keep-with-next
   2292          void  OS_TaskReturn (void)
   2293          {
   \                     OS_TaskReturn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2294              OS_ERR  err;
   2295          
   2296          
   2297          
   2298              OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       OSTaskReturnHook
   2299          #if OS_CFG_TASK_DEL_EN > 0u
   2300              OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
   2301                        (OS_ERR *)&err);
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       OSTaskDel
   2302          #else
   2303              for (;;) {
   2304                  OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
   2305                            (OS_OPT  )OS_OPT_TIME_DLY,
   2306                            (OS_ERR *)&err);
   2307              }
   2308          #endif
   2309          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   2310          
   2311          /*$PAGE*/
   2312          /*
   2313          ************************************************************************************************************************
   2314          *                                                    SIGNAL A TASK
   2315          *
   2316          * Description: This function is called to signal a task waiting for a signal.
   2317          *
   2318          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   2319          *                        a signal to yourself.
   2320          *
   2321          *              opt       determines the type of POST performed:
   2322          *
   2323          *                             OS_OPT_POST_NONE         No option
   2324          *
   2325          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   2326          *
   2327          *              ts        is a timestamp indicating when the post occurred.
   2328          *
   2329          *              p_err     is a pointer to an error code returned by this function:
   2330          *
   2331          *                            OS_ERR_NONE           If the requested task is signaled
   2332          *                            OS_ERR_SEM_OVF        If the post would cause the semaphore count to overflow.
   2333          *                            OS_ERR_STATE_INVALID  If the task is in an invalid state.  This should never happen
   2334          *                                                  and if it does, would be considered a system failure.
   2335          *
   2336          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   2337          *
   2338          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2339          ************************************************************************************************************************
   2340          */
   2341          

   \                                 In section .text, align 2, keep-with-next
   2342          OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
   2343                                      OS_OPT   opt,
   2344                                      CPU_TS   ts,
   2345                                      OS_ERR  *p_err)
   2346          {
   \                     OS_TaskSemPost: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2347              OS_SEM_CTR  ctr;
   2348              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   2349          
   2350          
   2351          
   2352              OS_CRITICAL_ENTER();
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   \   00000014   0x4681             MOV      R9,R0
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD101             BNE.N    ??OS_TaskSemPost_0
   \   00000032   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_TaskSemPost_0: (+1)
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003A   0x4648             MOV      R0,R9
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
   2353              if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD102             BNE.N    ??OS_TaskSemPost_1
   2354                  p_tcb = OSTCBCurPtr;
   \   00000044   0x....             LDR.N    R0,??DataTable25
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x0004             MOVS     R4,R0
   2355              }
   2356              p_tcb->TS = ts;
   \                     ??OS_TaskSemPost_1: (+1)
   \   0000004A   0x6426             STR      R6,[R4, #+64]
   2357             *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x8038             STRH     R0,[R7, #+0]
   2358              switch (p_tcb->TaskState) {
   \   00000050   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD00B             BEQ.N    ??OS_TaskSemPost_2
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xD067             BEQ.N    ??OS_TaskSemPost_3
   \   0000005C   0xD308             BCC.N    ??OS_TaskSemPost_2
   \   0000005E   0x2804             CMP      R0,#+4
   \   00000060   0xD006             BEQ.N    ??OS_TaskSemPost_2
   \   00000062   0xD363             BCC.N    ??OS_TaskSemPost_3
   \   00000064   0x2806             CMP      R0,#+6
   \   00000066   0xD061             BEQ.N    ??OS_TaskSemPost_3
   \   00000068   0xD302             BCC.N    ??OS_TaskSemPost_2
   \   0000006A   0x2807             CMP      R0,#+7
   \   0000006C   0xD05E             BEQ.N    ??OS_TaskSemPost_3
   \   0000006E   0xE0E1             B.N      ??OS_TaskSemPost_4
   2359                  case OS_TASK_STATE_RDY:
   2360                  case OS_TASK_STATE_DLY:
   2361                  case OS_TASK_STATE_SUSPENDED:
   2362                  case OS_TASK_STATE_DLY_SUSPENDED:
   2363                       switch (sizeof(OS_SEM_CTR)) {
   2364                           case 1u:
   2365                                if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   2366                                    OS_CRITICAL_EXIT();
   2367                                   *p_err = OS_ERR_SEM_OVF;
   2368                                    return ((OS_SEM_CTR)0);
   2369                                }
   2370                                break;
   2371          
   2372                           case 2u:
   2373                                if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   2374                                    OS_CRITICAL_EXIT();
   2375                                   *p_err = OS_ERR_SEM_OVF;
   2376                                    return ((OS_SEM_CTR)0);
   2377                                }
   2378                                break;
   2379          
   2380                           case 4u:
   2381                                if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OS_TaskSemPost_2: (+1)
   \   00000070   0x6C60             LDR      R0,[R4, #+68]
   \   00000072   0xF110 0x0F01      CMN      R0,#+1
   \   00000076   0xD12C             BNE.N    ??OS_TaskSemPost_5
   2382                                    OS_CRITICAL_EXIT();
   \   00000078   0x.... 0x....      BL       CPU_SR_Save
   \   0000007C   0x4681             MOV      R9,R0
   \   0000007E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000082   0x....             LDR.N    R0,??DataTable26
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x....             LDR.N    R1,??DataTable26
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
   \   0000008C   0x....             LDR.N    R0,??DataTable26
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD114             BNE.N    ??OS_TaskSemPost_6
   \   00000094   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   0000009C   0x8800             LDRH     R0,[R0, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD007             BEQ.N    ??OS_TaskSemPost_7
   \   000000A2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       CPU_SR_Restore
   \   000000AC   0x.... 0x....      BL       OS_Sched0
   \   000000B0   0xE00A             B.N      ??OS_TaskSemPost_8
   \                     ??OS_TaskSemPost_7: (+1)
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B6   0x4648             MOV      R0,R9
   \   000000B8   0x.... 0x....      BL       CPU_SR_Restore
   \   000000BC   0xE004             B.N      ??OS_TaskSemPost_8
   \                     ??OS_TaskSemPost_6: (+1)
   \   000000BE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C2   0x4648             MOV      R0,R9
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
   2383                                   *p_err = OS_ERR_SEM_OVF;
   \                     ??OS_TaskSemPost_8: (+1)
   \   000000C8   0xF646 0x50C5      MOVW     R0,#+28101
   \   000000CC   0x8038             STRH     R0,[R7, #+0]
   2384                                    return ((OS_SEM_CTR)0);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xE0DD             B.N      ??OS_TaskSemPost_9
   2385                                }
   2386                                break;
   2387          
   2388                           default:
   2389                                break;
   2390                       }
   2391                       p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
   \                     ??OS_TaskSemPost_5: (+1)
   \   000000D2   0x6C60             LDR      R0,[R4, #+68]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x6460             STR      R0,[R4, #+68]
   2392                       ctr = p_tcb->SemCtr;
   \   000000D8   0x6C60             LDR      R0,[R4, #+68]
   \   000000DA   0x4680             MOV      R8,R0
   2393                       OS_CRITICAL_EXIT();
   \   000000DC   0x.... 0x....      BL       CPU_SR_Save
   \   000000E0   0x4681             MOV      R9,R0
   \   000000E2   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000E6   0x....             LDR.N    R0,??DataTable26
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   \   000000EC   0x....             LDR.N    R1,??DataTable26
   \   000000EE   0x7008             STRB     R0,[R1, #+0]
   \   000000F0   0x....             LDR.N    R0,??DataTable26
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD113             BNE.N    ??OS_TaskSemPost_10
   \   000000F8   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000000FC   0x....             LDR.N    R0,??DataTable26_11
   \   000000FE   0x8800             LDRH     R0,[R0, #+0]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD007             BEQ.N    ??OS_TaskSemPost_11
   \   00000104   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000108   0x4648             MOV      R0,R9
   \   0000010A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000010E   0x.... 0x....      BL       OS_Sched0
   \   00000112   0xE00A             B.N      ??OS_TaskSemPost_12
   \                     ??OS_TaskSemPost_11: (+1)
   \   00000114   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000118   0x4648             MOV      R0,R9
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000011E   0xE004             B.N      ??OS_TaskSemPost_12
   \                     ??OS_TaskSemPost_10: (+1)
   \   00000120   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000124   0x4648             MOV      R0,R9
   \   00000126   0x.... 0x....      BL       CPU_SR_Restore
   2394                       break;
   \                     ??OS_TaskSemPost_12: (+1)
   \   0000012A   0xE0AF             B.N      ??OS_TaskSemPost_13
   2395          
   2396                  case OS_TASK_STATE_PEND:
   2397                  case OS_TASK_STATE_PEND_TIMEOUT:
   2398                  case OS_TASK_STATE_PEND_SUSPENDED:
   2399                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2400                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
   \                     ??OS_TaskSemPost_3: (+1)
   \   0000012C   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000130   0x2807             CMP      R0,#+7
   \   00000132   0xD122             BNE.N    ??OS_TaskSemPost_14
   2401                           OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
   2402                                   (OS_TCB      *)p_tcb,
   2403                                   (void        *)0,
   2404                                   (OS_MSG_SIZE  )0u,
   2405                                   (CPU_TS       )ts);
   \   00000134   0x9600             STR      R6,[SP, #+0]
   \   00000136   0x2300             MOVS     R3,#+0
   \   00000138   0x2200             MOVS     R2,#+0
   \   0000013A   0x0021             MOVS     R1,R4
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x.... 0x....      BL       OS_Post
   2406                           ctr = p_tcb->SemCtr;
   \   00000142   0x6C60             LDR      R0,[R4, #+68]
   \   00000144   0x4680             MOV      R8,R0
   2407                           OS_CRITICAL_EXIT_NO_SCHED();
   \   00000146   0x.... 0x....      BL       CPU_SR_Save
   \   0000014A   0x4681             MOV      R9,R0
   \   0000014C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000150   0x....             LDR.N    R0,??DataTable26
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0x1E40             SUBS     R0,R0,#+1
   \   00000156   0x....             LDR.N    R1,??DataTable26
   \   00000158   0x7008             STRB     R0,[R1, #+0]
   \   0000015A   0x....             LDR.N    R0,??DataTable26
   \   0000015C   0x7800             LDRB     R0,[R0, #+0]
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD101             BNE.N    ??OS_TaskSemPost_15
   \   00000162   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_TaskSemPost_15: (+1)
   \   00000166   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016A   0x4648             MOV      R0,R9
   \   0000016C   0x.... 0x....      BL       CPU_SR_Restore
   2408                           if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   00000170   0x0428             LSLS     R0,R5,#+16
   \   00000172   0xD45E             BMI.N    ??OS_TaskSemPost_16
   2409                               OSSched();                                 /* Run the scheduler                                  */
   \   00000174   0x.... 0x....      BL       OSSched
   \   00000178   0xE05B             B.N      ??OS_TaskSemPost_16
   2410                           }
   2411                       } else {
   2412                           switch (sizeof(OS_SEM_CTR)) {
   2413                               case 1u:
   2414                                    if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   2415                                        OS_CRITICAL_EXIT();
   2416                                       *p_err = OS_ERR_SEM_OVF;
   2417                                        return ((OS_SEM_CTR)0);
   2418                                    }
   2419                                    break;
   2420          
   2421                               case 2u:
   2422                                    if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   2423                                        OS_CRITICAL_EXIT();
   2424                                       *p_err = OS_ERR_SEM_OVF;
   2425                                        return ((OS_SEM_CTR)0);
   2426                                    }
   2427                                    break;
   2428          
   2429                               case 4u:
   2430                                    if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OS_TaskSemPost_14: (+1)
   \   0000017A   0x6C60             LDR      R0,[R4, #+68]
   \   0000017C   0xF110 0x0F01      CMN      R0,#+1
   \   00000180   0xD12B             BNE.N    ??OS_TaskSemPost_17
   2431                                        OS_CRITICAL_EXIT();
   \   00000182   0x.... 0x....      BL       CPU_SR_Save
   \   00000186   0x4681             MOV      R9,R0
   \   00000188   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000018C   0x....             LDR.N    R0,??DataTable26
   \   0000018E   0x7800             LDRB     R0,[R0, #+0]
   \   00000190   0x1E40             SUBS     R0,R0,#+1
   \   00000192   0x....             LDR.N    R1,??DataTable26
   \   00000194   0x7008             STRB     R0,[R1, #+0]
   \   00000196   0x....             LDR.N    R0,??DataTable26
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0x2800             CMP      R0,#+0
   \   0000019C   0xD113             BNE.N    ??OS_TaskSemPost_18
   \   0000019E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000001A2   0x....             LDR.N    R0,??DataTable26_11
   \   000001A4   0x8800             LDRH     R0,[R0, #+0]
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD007             BEQ.N    ??OS_TaskSemPost_19
   \   000001AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001AE   0x4648             MOV      R0,R9
   \   000001B0   0x.... 0x....      BL       CPU_SR_Restore
   \   000001B4   0x.... 0x....      BL       OS_Sched0
   \   000001B8   0xE00A             B.N      ??OS_TaskSemPost_20
   \                     ??OS_TaskSemPost_19: (+1)
   \   000001BA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001BE   0x4648             MOV      R0,R9
   \   000001C0   0x.... 0x....      BL       CPU_SR_Restore
   \   000001C4   0xE004             B.N      ??OS_TaskSemPost_20
   \                     ??OS_TaskSemPost_18: (+1)
   \   000001C6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001CA   0x4648             MOV      R0,R9
   \   000001CC   0x.... 0x....      BL       CPU_SR_Restore
   2432                                       *p_err = OS_ERR_SEM_OVF;
   \                     ??OS_TaskSemPost_20: (+1)
   \   000001D0   0xF646 0x50C5      MOVW     R0,#+28101
   \   000001D4   0x8038             STRH     R0,[R7, #+0]
   2433                                        return ((OS_SEM_CTR)0);
   \   000001D6   0x2000             MOVS     R0,#+0
   \   000001D8   0xE059             B.N      ??OS_TaskSemPost_9
   2434                                    }
   2435                                    break;
   2436          
   2437                               default:
   2438                                    break;
   2439                           }
   2440                           p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
   \                     ??OS_TaskSemPost_17: (+1)
   \   000001DA   0x6C60             LDR      R0,[R4, #+68]
   \   000001DC   0x1C40             ADDS     R0,R0,#+1
   \   000001DE   0x6460             STR      R0,[R4, #+68]
   2441                           ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
   \   000001E0   0x6C60             LDR      R0,[R4, #+68]
   \   000001E2   0x4680             MOV      R8,R0
   2442                           OS_CRITICAL_EXIT();
   \   000001E4   0x.... 0x....      BL       CPU_SR_Save
   \   000001E8   0x4681             MOV      R9,R0
   \   000001EA   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001EE   0x....             LDR.N    R0,??DataTable26
   \   000001F0   0x7800             LDRB     R0,[R0, #+0]
   \   000001F2   0x1E40             SUBS     R0,R0,#+1
   \   000001F4   0x....             LDR.N    R1,??DataTable26
   \   000001F6   0x7008             STRB     R0,[R1, #+0]
   \   000001F8   0x....             LDR.N    R0,??DataTable26
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD113             BNE.N    ??OS_TaskSemPost_21
   \   00000200   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000204   0x....             LDR.N    R0,??DataTable26_11
   \   00000206   0x8800             LDRH     R0,[R0, #+0]
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD007             BEQ.N    ??OS_TaskSemPost_22
   \   0000020C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000210   0x4648             MOV      R0,R9
   \   00000212   0x.... 0x....      BL       CPU_SR_Restore
   \   00000216   0x.... 0x....      BL       OS_Sched0
   \   0000021A   0xE00A             B.N      ??OS_TaskSemPost_23
   \                     ??OS_TaskSemPost_22: (+1)
   \   0000021C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000220   0x4648             MOV      R0,R9
   \   00000222   0x.... 0x....      BL       CPU_SR_Restore
   \   00000226   0xE004             B.N      ??OS_TaskSemPost_23
   \                     ??OS_TaskSemPost_21: (+1)
   \   00000228   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000022C   0x4648             MOV      R0,R9
   \   0000022E   0x.... 0x....      BL       CPU_SR_Restore
   2443                       }
   2444                       break;
   \                     ??OS_TaskSemPost_23: (+1)
   \                     ??OS_TaskSemPost_16: (+1)
   \   00000232   0xE02B             B.N      ??OS_TaskSemPost_13
   2445          
   2446                  default:
   2447                       OS_CRITICAL_EXIT();
   \                     ??OS_TaskSemPost_4: (+1)
   \   00000234   0x.... 0x....      BL       CPU_SR_Save
   \   00000238   0x4681             MOV      R9,R0
   \   0000023A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000023E   0x....             LDR.N    R0,??DataTable26
   \   00000240   0x7800             LDRB     R0,[R0, #+0]
   \   00000242   0x1E40             SUBS     R0,R0,#+1
   \   00000244   0x....             LDR.N    R1,??DataTable26
   \   00000246   0x7008             STRB     R0,[R1, #+0]
   \   00000248   0x....             LDR.N    R0,??DataTable26
   \   0000024A   0x7800             LDRB     R0,[R0, #+0]
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD113             BNE.N    ??OS_TaskSemPost_24
   \   00000250   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000254   0x....             LDR.N    R0,??DataTable26_11
   \   00000256   0x8800             LDRH     R0,[R0, #+0]
   \   00000258   0x2800             CMP      R0,#+0
   \   0000025A   0xD007             BEQ.N    ??OS_TaskSemPost_25
   \   0000025C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000260   0x4648             MOV      R0,R9
   \   00000262   0x.... 0x....      BL       CPU_SR_Restore
   \   00000266   0x.... 0x....      BL       OS_Sched0
   \   0000026A   0xE00A             B.N      ??OS_TaskSemPost_26
   \                     ??OS_TaskSemPost_25: (+1)
   \   0000026C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000270   0x4648             MOV      R0,R9
   \   00000272   0x.... 0x....      BL       CPU_SR_Restore
   \   00000276   0xE004             B.N      ??OS_TaskSemPost_26
   \                     ??OS_TaskSemPost_24: (+1)
   \   00000278   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000027C   0x4648             MOV      R0,R9
   \   0000027E   0x.... 0x....      BL       CPU_SR_Restore
   2448                      *p_err = OS_ERR_STATE_INVALID;
   \                     ??OS_TaskSemPost_26: (+1)
   \   00000282   0xF646 0x602D      MOVW     R0,#+28205
   \   00000286   0x8038             STRH     R0,[R7, #+0]
   2449                       ctr   = (OS_SEM_CTR)0;
   \   00000288   0x2000             MOVS     R0,#+0
   \   0000028A   0x4680             MOV      R8,R0
   2450                       break;
   2451              }
   2452              return (ctr);
   \                     ??OS_TaskSemPost_13: (+1)
   \   0000028C   0x4640             MOV      R0,R8
   \                     ??OS_TaskSemPost_9: (+1)
   \   0000028E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2453          }
   2454          
   2455          /*$PAGE*/
   2456          /*
   2457          ************************************************************************************************************************
   2458          *                                                   SUSPEND A TASK
   2459          *
   2460          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   2461          *              or the pointer to the TCB of the calling task.
   2462          *
   2463          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   2464          *                       If p_tcb is a NULL pointer then, suspend the current task.
   2465          *
   2466          *              p_err    is a pointer to a variable that will receive an error code from this function.
   2467          *
   2468          *                           OS_ERR_NONE                      if the requested task is suspended
   2469          *                           OS_ERR_SCHED_LOCKED              you can't suspend the current task is the scheduler is
   2470          *                                                            locked
   2471          *                           OS_ERR_TASK_SUSPEND_ISR          if you called this function from an ISR
   2472          *                           OS_ERR_TASK_SUSPEND_IDLE         if you attempted to suspend the idle task which is not
   2473          *                                                            allowed.
   2474          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER  if you attempted to suspend the idle task which is not
   2475          *                                                            allowed.
   2476          *
   2477          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
   2478          *
   2479          *              2) You should use this function with great care.  If you suspend a task that is waiting for an event
   2480          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   2481          *                 arrives.
   2482          ************************************************************************************************************************
   2483          */
   2484          
   2485          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2486          void   OS_TaskSuspend (OS_TCB  *p_tcb,
   2487                                 OS_ERR  *p_err)
   2488          {
   \                     OS_TaskSuspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2489              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
   2490          
   2491          
   2492          
   2493              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
   2494              if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD102             BNE.N    ??OS_TaskSuspend_0
   2495                  p_tcb = OSTCBCurPtr;
   \   00000016   0x....             LDR.N    R0,??DataTable26_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0004             MOVS     R4,R0
   2496              }
   2497          
   2498              if (p_tcb == OSTCBCurPtr) {
   \                     ??OS_TaskSuspend_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable26_2
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD10C             BNE.N    ??OS_TaskSuspend_1
   2499                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
   \   00000024   0x....             LDR.N    R0,??DataTable26
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD008             BEQ.N    ??OS_TaskSuspend_1
   2500                      CPU_CRITICAL_EXIT();
   \   0000002C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
   2501                     *p_err = OS_ERR_SCHED_LOCKED;
   \   00000036   0xF646 0x5063      MOVW     R0,#+28003
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
   2502                      return;
   \   0000003C   0xE078             B.N      ??OS_TaskSuspend_2
   2503                  }
   2504              }
   2505          
   2506             *p_err = OS_ERR_NONE;
   \                     ??OS_TaskSuspend_1: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x8028             STRH     R0,[R5, #+0]
   2507              switch (p_tcb->TaskState) {
   \   00000042   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD009             BEQ.N    ??OS_TaskSuspend_3
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0xD036             BEQ.N    ??OS_TaskSuspend_4
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0xD040             BEQ.N    ??OS_TaskSuspend_5
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0xD04A             BEQ.N    ??OS_TaskSuspend_6
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x2803             CMP      R0,#+3
   \   0000005A   0xD953             BLS.N    ??OS_TaskSuspend_7
   \   0000005C   0xE05D             B.N      ??OS_TaskSuspend_8
   2508                  case OS_TASK_STATE_RDY:
   2509                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OS_TaskSuspend_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable26
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0x....             LDR.N    R1,??DataTable26
   \   00000066   0x7008             STRB     R0,[R1, #+0]
   \   00000068   0x....             LDR.N    R0,??DataTable26
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD101             BNE.N    ??OS_TaskSuspend_9
   \   00000070   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_TaskSuspend_9: (+1)
   \   00000074   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0x.... 0x....      BL       CPU_SR_Restore
   2510                       p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0xF884 0x0036      STRB     R0,[R4, #+54]
   2511                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x008A      STRB     R0,[R4, #+138]
   2512                       OS_RdyListRemove(p_tcb);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       OS_RdyListRemove
   2513                       OS_CRITICAL_EXIT_NO_SCHED();
   \   00000090   0x.... 0x....      BL       CPU_SR_Save
   \   00000094   0x0006             MOVS     R6,R0
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000009A   0x....             LDR.N    R0,??DataTable26
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0x....             LDR.N    R1,??DataTable26
   \   000000A2   0x7008             STRB     R0,[R1, #+0]
   \   000000A4   0x....             LDR.N    R0,??DataTable26
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD101             BNE.N    ??OS_TaskSuspend_10
   \   000000AC   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_TaskSuspend_10: (+1)
   \   000000B0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B4   0x0030             MOVS     R0,R6
   \   000000B6   0x.... 0x....      BL       CPU_SR_Restore
   2514                       break;
   \   000000BA   0xE037             B.N      ??OS_TaskSuspend_11
   2515          
   2516                  case OS_TASK_STATE_DLY:
   2517                       p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
   \                     ??OS_TaskSuspend_4: (+1)
   \   000000BC   0x2005             MOVS     R0,#+5
   \   000000BE   0xF884 0x0036      STRB     R0,[R4, #+54]
   2518                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x008A      STRB     R0,[R4, #+138]
   2519                       CPU_CRITICAL_EXIT();
   \   000000C8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0x.... 0x....      BL       CPU_SR_Restore
   2520                       break;
   \   000000D2   0xE02B             B.N      ??OS_TaskSuspend_11
   2521          
   2522                  case OS_TASK_STATE_PEND:
   2523                       p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
   \                     ??OS_TaskSuspend_5: (+1)
   \   000000D4   0x2006             MOVS     R0,#+6
   \   000000D6   0xF884 0x0036      STRB     R0,[R4, #+54]
   2524                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0xF884 0x008A      STRB     R0,[R4, #+138]
   2525                       CPU_CRITICAL_EXIT();
   \   000000E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E4   0x0030             MOVS     R0,R6
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
   2526                       break;
   \   000000EA   0xE01F             B.N      ??OS_TaskSuspend_11
   2527          
   2528                  case OS_TASK_STATE_PEND_TIMEOUT:
   2529                       p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
   \                     ??OS_TaskSuspend_6: (+1)
   \   000000EC   0x2007             MOVS     R0,#+7
   \   000000EE   0xF884 0x0036      STRB     R0,[R4, #+54]
   2530                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xF884 0x008A      STRB     R0,[R4, #+138]
   2531                       CPU_CRITICAL_EXIT();
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x0030             MOVS     R0,R6
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
   2532                       break;
   \   00000102   0xE013             B.N      ??OS_TaskSuspend_11
   2533          
   2534                  case OS_TASK_STATE_SUSPENDED:
   2535                  case OS_TASK_STATE_DLY_SUSPENDED:
   2536                  case OS_TASK_STATE_PEND_SUSPENDED:
   2537                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2538                       p_tcb->SuspendCtr++;
   \                     ??OS_TaskSuspend_7: (+1)
   \   00000104   0xF894 0x008A      LDRB     R0,[R4, #+138]
   \   00000108   0x1C40             ADDS     R0,R0,#+1
   \   0000010A   0xF884 0x008A      STRB     R0,[R4, #+138]
   2539                       CPU_CRITICAL_EXIT();
   \   0000010E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000112   0x0030             MOVS     R0,R6
   \   00000114   0x.... 0x....      BL       CPU_SR_Restore
   2540                       break;
   \   00000118   0xE008             B.N      ??OS_TaskSuspend_11
   2541          
   2542                  default:
   2543                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskSuspend_8: (+1)
   \   0000011A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011E   0x0030             MOVS     R0,R6
   \   00000120   0x.... 0x....      BL       CPU_SR_Restore
   2544                      *p_err = OS_ERR_STATE_INVALID;
   \   00000124   0xF646 0x602D      MOVW     R0,#+28205
   \   00000128   0x8028             STRH     R0,[R5, #+0]
   2545                       return;
   \   0000012A   0xE001             B.N      ??OS_TaskSuspend_2
   2546              }
   2547          
   2548              OSSched();
   \                     ??OS_TaskSuspend_11: (+1)
   \   0000012C   0x.... 0x....      BL       OSSched
   2549          }
   \                     ??OS_TaskSuspend_2: (+1)
   \   00000130   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     OSIntQTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x47534D54         DC32     0x47534d54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x53455254         DC32     0x53455254

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x47495354         DC32     0x47495354

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x........         DC32     OSIntQTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x53555354         DC32     0x53555354

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x........         DC32     OSTaskDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x54          DC8 "?Task"
   \              0x61 0x73    
   \              0x6B 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
   2550          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTaskChangePrio
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_PendListChangePrio
        24   -> OS_PrioInsert
        24   -> OS_RdyListInsertHead
        24   -> OS_RdyListInsertTail
        24   -> OS_RdyListRemove
        24   -> OS_Sched0
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      64   OSTaskCreate
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OSTaskCreateHook
        64   -> OSTaskStkInit
        64   -> OS_MsgQInit
        64   -> OS_PrioInsert
        64   -> OS_RdyListInsertTail
        64   -> OS_Sched0
        64   -> OS_SchedLockTimeMeasStart
        64   -> OS_SchedLockTimeMeasStop
        64   -> OS_TaskDbgListAdd
        64   -> OS_TaskInitTCB
      16   OSTaskDel
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OSTaskDelHook
        16   -> OS_MsgQFreeAll
        16   -> OS_PendListRemove
        16   -> OS_RdyListRemove
        16   -> OS_Sched0
        16   -> OS_SchedLockTimeMeasStart
        16   -> OS_SchedLockTimeMeasStop
        16   -> OS_TaskDbgListRemove
        16   -> OS_TaskInitTCB
        16   -> OS_TickListRemove
      24   OSTaskQFlush
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQFreeAll
        24   -> OS_Sched0
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      40   OSTaskQPend
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_MsgQGet
        40   -> OS_Pend
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
      24   OSTaskQPendAbort
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_TS_TmrRd
        24   -> OSSched
        24   -> OS_PendAbort
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      48   OSTaskQPost
        48   -> CPU_TS_TmrRd
        48   -> OS_IntQPost
        48   -> OS_TaskQPost
      24   OSTaskRegGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskRegGetID
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   OSTaskRegSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      32   OSTaskResume
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_IntQPost
        32   -> OS_TaskResume
      32   OSTaskSemPend
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CPU_TS_TmrRd
        32   -> OSSched
        32   -> OS_Pend
        32   -> OS_SchedLockTimeMeasStart
        32   -> OS_SchedLockTimeMeasStop
      24   OSTaskSemPendAbort
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_TS_TmrRd
        24   -> OSSched
        24   -> OS_PendAbort
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      40   OSTaskSemPost
        40   -> CPU_TS_TmrRd
        40   -> OS_IntQPost
        40   -> OS_TaskSemPost
      24   OSTaskSemSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      32   OSTaskStkChk
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
      32   OSTaskSuspend
        32   -> OS_IntQPost
        32   -> OS_TaskSuspend
      24   OSTaskTimeQuantaSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   OS_TaskDbgListAdd
       0   OS_TaskDbgListRemove
       0   OS_TaskInit
      16   OS_TaskInitTCB
        16   -> CPU_TS_TmrRd
        16   -> OS_MsgQInit
      40   OS_TaskQPost
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MsgQPut
        40   -> OS_Post
        40   -> OS_Sched0
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
      16   OS_TaskResume
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_SchedLockTimeMeasStart
        16   -> OS_SchedLockTimeMeasStop
        16   -> OS_TaskRdy
       8   OS_TaskReturn
         8   -> OSTaskDel
         8   -> OSTaskReturnHook
      32   OS_TaskSemPost
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Post
        32   -> OS_Sched0
        32   -> OS_SchedLockTimeMeasStart
        32   -> OS_SchedLockTimeMeasStop
      16   OS_TaskSuspend
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListRemove
        16   -> OS_SchedLockTimeMeasStart
        16   -> OS_SchedLockTimeMeasStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable20
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
       8  ?_0
       2  ?_1
     422  OSTaskChangePrio
     606  OSTaskCreate
     430  OSTaskDel
     214  OSTaskQFlush
     554  OSTaskQPend
     250  OSTaskQPendAbort
     136  OSTaskQPost
      80  OSTaskRegGet
      88  OSTaskRegGetID
      76  OSTaskRegSet
     106  OSTaskResume
     554  OSTaskSemPend
     274  OSTaskSemPendAbort
     108  OSTaskSemPost
      82  OSTaskSemSet
     202  OSTaskStkChk
      92  OSTaskSuspend
      94  OSTaskTimeQuantaSet
      52  OS_TaskDbgListAdd
      80  OS_TaskDbgListRemove
      30  OS_TaskInit
     296  OS_TaskInitTCB
     532  OS_TaskQPost
     318  OS_TaskResume
      22  OS_TaskReturn
     658  OS_TaskSemPost
     306  OS_TaskSuspend

 
    10 bytes in section .rodata
 6 778 bytes in section .text
 
 6 778 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
