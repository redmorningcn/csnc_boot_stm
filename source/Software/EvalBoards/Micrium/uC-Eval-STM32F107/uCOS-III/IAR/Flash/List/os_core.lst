###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_core.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_core.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_core.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_core.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_core.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                    CORE FUNCTIONS
     10          *
     11          * File    : OS_CORE.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_core__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                    INITIALIZATION
     43          *
     44          * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
     45          *              creating any uC/OS-III object and, prior to calling OS_Start().
     46          *
     47          * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
     48          *
     49          *                                OS_ERR_NONE    Initialization was successful
     50          *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
     51          * Returns    : none
     52          ************************************************************************************************************************
     53          */
     54          

   \                                 In section .text, align 2, keep-with-next
     55          void  OSInit (OS_ERR  *p_err)
     56          {
   \                     OSInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     57              CPU_STK      *p_stk;
     58              CPU_STK_SIZE  size;
     59          
     60          
     61          
     62          #ifdef OS_SAFETY_CRITICAL
     63              if (p_err == (OS_ERR *)0) {
     64                  OS_SAFETY_CRITICAL_EXCEPTION();
     65                  return;
     66              }
     67          #endif
     68          
     69              OSInitHook();                                           /* Call port specific initialization code                 */
   \   00000004   0x.... 0x....      BL       OSInitHook
     70          
     71              OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
     72          
     73              OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
     74          
     75              OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
     76          
     77              OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000026   0x6008             STR      R0,[R1, #+0]
     78              OSTCBHighRdyPtr                 = (OS_TCB *)0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     79          
     80              OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000036   0x7008             STRB     R0,[R1, #+0]
     81              OSPrioHighRdy                   = (OS_PRIO)0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
     82              OSPrioSaved                     = (OS_PRIO)0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000046   0x7008             STRB     R0,[R1, #+0]
     83          
     84          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
     85              OSSchedLockTimeBegin            = (CPU_TS)0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   0000004E   0x6008             STR      R0,[R1, #+0]
     86              OSSchedLockTimeMax              = (CPU_TS)0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000056   0x6008             STR      R0,[R1, #+0]
     87              OSSchedLockTimeMaxCur           = (CPU_TS)0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000005E   0x6008             STR      R0,[R1, #+0]
     88          #endif
     89          
     90          #ifdef OS_SAFETY_CRITICAL_IEC61508
     91              OSSafetyCriticalStartFlag       =  DEF_FALSE;
     92          #endif
     93          
     94          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
     95              OSSchedRoundRobinEn             = DEF_FALSE;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000066   0x7008             STRB     R0,[R1, #+0]
     96              OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x210A             MOVS     R1,#+10
   \   00000070   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000078   0x6008             STR      R0,[R1, #+0]
     97          #endif
     98          
     99              if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD010             BEQ.N    ??OSInit_0
    100                  p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x0005             MOVS     R5,R0
    101                  if (p_stk != (CPU_STK *)0) {
   \   0000008C   0x2D00             CMP      R5,#+0
   \   0000008E   0xD00A             BEQ.N    ??OSInit_0
    102                      size  = OSCfg_ISRStkSize;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x0006             MOVS     R6,R0
    103                      while (size > (CPU_STK_SIZE)0) {
   \                     ??OSInit_1: (+1)
   \   00000098   0x2E00             CMP      R6,#+0
   \   0000009A   0xD004             BEQ.N    ??OSInit_0
    104                          size--;
   \   0000009C   0x1E76             SUBS     R6,R6,#+1
    105                         *p_stk = (CPU_STK)0;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x6028             STR      R0,[R5, #+0]
    106                          p_stk++;
   \   000000A2   0x1D2D             ADDS     R5,R5,#+4
   \   000000A4   0xE7F8             B.N      ??OSInit_1
    107                      }
    108                  }
    109              }
    110          
    111          #if OS_CFG_APP_HOOKS_EN > 0u
    112              OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
   \                     ??OSInit_0: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    113              OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    114              OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable17_8
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    115          
    116              OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable17_9
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    117              OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    118              OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable17_11
   \   000000D4   0x6008             STR      R0,[R1, #+0]
    119              OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    120          #endif
    121          
    122          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    123              OSTaskRegNextAvailID    = (OS_REG_ID)0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000E4   0x7008             STRB     R0,[R1, #+0]
    124          #endif
    125          
    126              OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
   \   000000E6   0x.... 0x....      BL       OS_PrioInit
    127          
    128              OS_RdyListInit();                                       /* Initialize the Ready List                              */
   \   000000EA   0x.... 0x....      BL       OS_RdyListInit
    129          
    130              
    131          #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
    132              OS_FlagInit(p_err);
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       OS_FlagInit
    133              if (*p_err != OS_ERR_NONE) {
   \   000000F4   0x8820             LDRH     R0,[R4, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD145             BNE.N    ??OSInit_2
    134                  return;
    135              }
    136          #endif
    137          
    138          
    139          #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
    140              OS_MemInit(p_err);
   \                     ??OSInit_3: (+1)
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       OS_MemInit
    141              if (*p_err != OS_ERR_NONE) {
   \   00000100   0x8820             LDRH     R0,[R4, #+0]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD13F             BNE.N    ??OSInit_2
    142                  return;
    143              }
    144          #endif
    145          
    146          
    147          #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
    148              OS_MsgPoolInit(p_err);
   \                     ??OSInit_4: (+1)
   \   00000106   0x0020             MOVS     R0,R4
   \   00000108   0x.... 0x....      BL       OS_MsgPoolInit
    149              if (*p_err != OS_ERR_NONE) {
   \   0000010C   0x8820             LDRH     R0,[R4, #+0]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD139             BNE.N    ??OSInit_2
    150                  return;
    151              }
    152          #endif
    153          
    154          
    155          #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
    156              OS_MutexInit(p_err);
   \                     ??OSInit_5: (+1)
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       OS_MutexInit
    157              if (*p_err != OS_ERR_NONE) {
   \   00000118   0x8820             LDRH     R0,[R4, #+0]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD133             BNE.N    ??OSInit_2
    158                  return;
    159              }
    160          #endif
    161          
    162          
    163          #if OS_CFG_Q_EN > 0u
    164              OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
   \                     ??OSInit_6: (+1)
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0x.... 0x....      BL       OS_QInit
    165              if (*p_err != OS_ERR_NONE) {
   \   00000124   0x8820             LDRH     R0,[R4, #+0]
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD12D             BNE.N    ??OSInit_2
    166                  return;
    167              }
    168          #endif
    169          
    170          
    171          #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
    172              OS_SemInit(p_err);
   \                     ??OSInit_7: (+1)
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       OS_SemInit
    173              if (*p_err != OS_ERR_NONE) {
   \   00000130   0x8820             LDRH     R0,[R4, #+0]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD127             BNE.N    ??OSInit_2
    174                  return;
    175              }
    176          #endif
    177          
    178          
    179          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    180              OS_TLS_Init(p_err);                                     /* Initialize Task Local Storage, before creating tasks   */
    181              if (*p_err != OS_ERR_NONE) {
    182                  return;
    183              }
    184          #endif
    185          
    186          
    187              OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
   \                     ??OSInit_8: (+1)
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0x.... 0x....      BL       OS_TaskInit
    188              if (*p_err != OS_ERR_NONE) {
   \   0000013C   0x8820             LDRH     R0,[R4, #+0]
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD121             BNE.N    ??OSInit_2
    189                  return;
    190              }
    191          
    192          
    193          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    194              OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
   \                     ??OSInit_9: (+1)
   \   00000142   0x0020             MOVS     R0,R4
   \   00000144   0x.... 0x....      BL       OS_IntQTaskInit
    195              if (*p_err != OS_ERR_NONE) {
   \   00000148   0x8820             LDRH     R0,[R4, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD11B             BNE.N    ??OSInit_2
    196                  return;
    197              }
    198          #endif
    199          
    200              
    201              OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
   \                     ??OSInit_10: (+1)
   \   0000014E   0x0020             MOVS     R0,R4
   \   00000150   0x.... 0x....      BL       OS_IdleTaskInit
    202              if (*p_err != OS_ERR_NONE) {
   \   00000154   0x8820             LDRH     R0,[R4, #+0]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD115             BNE.N    ??OSInit_2
    203                  return;
    204              }
    205          
    206          
    207              OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
   \                     ??OSInit_11: (+1)
   \   0000015A   0x0020             MOVS     R0,R4
   \   0000015C   0x.... 0x....      BL       OS_TickTaskInit
    208              if (*p_err != OS_ERR_NONE) {
   \   00000160   0x8820             LDRH     R0,[R4, #+0]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD10F             BNE.N    ??OSInit_2
    209                  return;
    210              }
    211          
    212          
    213          #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
    214              OS_StatTaskInit(p_err);
   \                     ??OSInit_12: (+1)
   \   00000166   0x0020             MOVS     R0,R4
   \   00000168   0x.... 0x....      BL       OS_StatTaskInit
    215              if (*p_err != OS_ERR_NONE) {
   \   0000016C   0x8820             LDRH     R0,[R4, #+0]
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD109             BNE.N    ??OSInit_2
    216                  return;
    217              }
    218          #endif
    219          
    220          
    221          #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
    222              OS_TmrInit(p_err);
   \                     ??OSInit_13: (+1)
   \   00000172   0x0020             MOVS     R0,R4
   \   00000174   0x.... 0x....      BL       OS_TmrInit
    223              if (*p_err != OS_ERR_NONE) {
   \   00000178   0x8820             LDRH     R0,[R4, #+0]
   \   0000017A   0x2800             CMP      R0,#+0
   \   0000017C   0xD103             BNE.N    ??OSInit_2
    224                  return;
    225              }
    226          #endif
    227          
    228          
    229          #if OS_CFG_DBG_EN > 0u
    230              OS_Dbg_Init();
   \                     ??OSInit_14: (+1)
   \   0000017E   0x.... 0x....      BL       OS_Dbg_Init
    231          #endif
    232          
    233          
    234              OSCfg_Init();
   \   00000182   0x.... 0x....      BL       OSCfg_Init
    235          }
   \                     ??OSInit_2: (+1)
   \   00000186   0xBD70             POP      {R4-R6,PC}       ;; return
    236          
    237          /*$PAGE*/
    238          /*
    239          ************************************************************************************************************************
    240          *                                                      ENTER ISR
    241          *
    242          * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
    243          *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
    244          *              the last nested ISR.
    245          *
    246          * Arguments  : none
    247          *
    248          * Returns    : none
    249          *
    250          * Note(s)    : 1) This function MUST be called with interrupts already disabled
    251          *
    252          *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
    253          *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
    254          *                 uC/OS-III variables.
    255          *
    256          *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
    257          *
    258          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    259          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    260          *                 at the end of the ISR.
    261          *
    262          *              5) You are allowed to nest interrupts up to 250 levels deep.
    263          ************************************************************************************************************************
    264          */
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void  OSIntEnter (void)
    267          {
    268              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
   \                     OSIntEnter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE.N    ??OSIntEnter_0
    269                  return;                                             /* No                                                     */
    270              }
    271          
    272              if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
   \                     ??OSIntEnter_1: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x28FA             CMP      R0,#+250
   \   00000012   0xDA06             BGE.N    ??OSIntEnter_0
    273                  return;                                             /* Yes                                                    */
    274              }
    275          
    276              OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
   \                     ??OSIntEnter_2: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    277          }
   \                     ??OSIntEnter_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    278          
    279          /*$PAGE*/
    280          /*
    281          ************************************************************************************************************************
    282          *                                                       EXIT ISR
    283          *
    284          * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
    285          *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
    286          *              ready to run.
    287          *
    288          * Arguments  : none
    289          *
    290          * Returns    : none
    291          *
    292          * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    293          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    294          *                 at the end of the ISR.
    295          *
    296          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    297          ************************************************************************************************************************
    298          */
    299          

   \                                 In section .text, align 2, keep-with-next
    300          void  OSIntExit (void)
    301          {
   \                     OSIntExit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    302              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    303          
    304          
    305          
    306              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD15B             BNE.N    ??OSIntExit_0
    307                  return;                                             /* No                                                     */
    308              }
    309          
    310              CPU_INT_DIS();
   \                     ??OSIntExit_1: (+1)
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x0004             MOVS     R4,R0
    311              if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD103             BNE.N    ??OSIntExit_2
    312                  CPU_INT_EN();
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       CPU_SR_Restore
    313                  return;
   \   00000024   0xE04F             B.N      ??OSIntExit_0
    314              }
    315              OSIntNestingCtr--;
   \                     ??OSIntExit_2: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    316              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD003             BEQ.N    ??OSIntExit_3
    317                  CPU_INT_EN();                                       /* Yes                                                    */
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    318                  return;
   \   00000044   0xE03F             B.N      ??OSIntExit_0
    319              }
    320          
    321              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
   \                     ??OSIntExit_3: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD003             BEQ.N    ??OSIntExit_4
    322                  CPU_INT_EN();                                       /* Yes                                                    */
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    323                  return;
   \   00000056   0xE036             B.N      ??OSIntExit_0
    324              }
    325          
    326              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
   \                     ??OSIntExit_4: (+1)
   \   00000058   0x.... 0x....      BL       OS_PrioGetHighest
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    327              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000006A   0x7809             LDRB     R1,[R1, #+0]
   \   0000006C   0x220C             MOVS     R2,#+12
   \   0000006E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000078   0x6008             STR      R0,[R1, #+0]
    328              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD103             BNE.N    ??OSIntExit_5
    329                  CPU_INT_EN();                                       /* Yes                                                    */
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
    330                  return;
   \   00000090   0xE019             B.N      ??OSIntExit_0
    331              }
    332          
    333          #if OS_CFG_TASK_PROFILE_EN > 0u
    334              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
   \                     ??OSIntExit_5: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable16
   \   000000A2   0x6809             LDR      R1,[R1, #+0]
   \   000000A4   0xF8C1 0x0090      STR      R0,[R1, #+144]
    335          #endif
    336              OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable22
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable22
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    337          
    338          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    339              OS_TLS_TaskSw();
    340          #endif
    341          
    342              OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
   \   000000B6   0xF05F 0x5080      MOVS     R0,#+268435456
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0xe000ed04
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    343              CPU_INT_EN();
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    344          }
   \                     ??OSIntExit_0: (+1)
   \   000000C6   0xBD10             POP      {R4,PC}          ;; return
    345          
    346          /*$PAGE*/
    347          /*
    348          ************************************************************************************************************************
    349          *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    350          *
    351          * Description: This function is called by the application code to indicate that all initialization has been completed
    352          *              and that kernel objects are no longer allowed to be created.
    353          *
    354          * Arguments  : none
    355          *
    356          * Returns    : none
    357          *
    358          * Note(s)    : none
    359          ************************************************************************************************************************
    360          */
    361          
    362          #ifdef OS_SAFETY_CRITICAL_IEC61508
    363          void  OSSafetyCriticalStart (void)
    364          {
    365              OSSafetyCriticalStartFlag = DEF_TRUE;
    366          }
    367          
    368          #endif
    369          
    370          /*$PAGE*/
    371          /*
    372          ************************************************************************************************************************
    373          *                                                      SCHEDULER
    374          *
    375          * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
    376          *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
    377          *              from ISRs (see OSIntExit() for ISR rescheduling).
    378          *
    379          * Arguments  : none
    380          *
    381          * Returns    : none
    382          *
    383          * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    384          ************************************************************************************************************************
    385          */
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void  OSSched (void)
    388          {
   \                     OSSched: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    389              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
    390          
    391          
    392          
    393              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD13E             BNE.N    ??OSSched_0
    394                  return;                                             /* Yes ... only schedule when no nested ISRs              */
    395              }
    396          
    397              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
   \                     ??OSSched_1: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD139             BNE.N    ??OSSched_0
    398                  return;                                             /* Yes                                                    */
    399              }
    400          
    401              CPU_INT_DIS();
   \                     ??OSSched_2: (+1)
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x0004             MOVS     R4,R0
    402              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
   \   0000001E   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    403              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x220C             MOVS     R2,#+12
   \   00000034   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    404              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD103             BNE.N    ??OSSched_3
    405                  CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    406                  return;
   \   00000056   0xE019             B.N      ??OSSched_0
    407              }
    408          
    409          #if OS_CFG_TASK_PROFILE_EN > 0u
    410              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
   \                     ??OSSched_3: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0xF8C1 0x0090      STR      R0,[R1, #+144]
    411          #endif
    412              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable22
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable22
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    413          
    414          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    415              OS_TLS_TaskSw();
    416          #endif
    417          
    418              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   \   0000007C   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0xe000ed04
   \   00000084   0x6008             STR      R0,[R1, #+0]
    419              CPU_INT_EN();
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    420          }
   \                     ??OSSched_0: (+1)
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    421          
    422          /*$PAGE*/
    423          /*
    424          ************************************************************************************************************************
    425          *                                                 PREVENT SCHEDULING
    426          *
    427          * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
    428          *              context switches until you are ready to permit context switching.
    429          *
    430          * Arguments  : p_err     is a pointer to a variable that will receive an error code:
    431          *
    432          *                            OS_ERR_NONE                 The scheduler is locked
    433          *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
    434          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet.
    435          *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR.
    436          *
    437          * Returns    : none
    438          *
    439          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    440          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    441          ************************************************************************************************************************
    442          */
    443          

   \                                 In section .text, align 2, keep-with-next
    444          void  OSSchedLock (OS_ERR  *p_err)
    445          {
   \                     OSSchedLock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    446              CPU_SR_ALLOC();
   \   00000004   0x2500             MOVS     R5,#+0
    447          
    448          
    449          
    450          #ifdef OS_SAFETY_CRITICAL
    451              if (p_err == (OS_ERR *)0) {
    452                  OS_SAFETY_CRITICAL_EXCEPTION();
    453                  return;
    454              }
    455          #endif
    456          
    457          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    458              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedLock_0
    459                 *p_err = OS_ERR_SCHED_LOCK_ISR;
   \   00000010   0xF646 0x5062      MOVW     R0,#+28002
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    460                  return;
   \   00000016   0xE026             B.N      ??OSSchedLock_1
    461              }
    462          #endif
    463          
    464              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
   \                     ??OSSchedLock_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSSchedLock_2
    465                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    466                  return;
   \   00000028   0xE01D             B.N      ??OSSchedLock_1
    467              }
    468          
    469              if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
   \                     ??OSSchedLock_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x28FA             CMP      R0,#+250
   \   00000032   0xDB03             BLT.N    ??OSSchedLock_3
    470                 *p_err = OS_ERR_LOCK_NESTING_OVF;
   \   00000034   0xF245 0x2009      MOVW     R0,#+21001
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    471                  return;
   \   0000003A   0xE014             B.N      ??OSSchedLock_1
    472              }
    473          
    474              CPU_CRITICAL_ENTER();
   \                     ??OSSchedLock_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x0005             MOVS     R5,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    475              OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable22_2
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    476          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    477              OS_SchedLockTimeMeasStart();
   \   00000054   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
    478          #endif
    479              CPU_CRITICAL_EXIT();
   \   00000058   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0x.... 0x....      BL       CPU_SR_Restore
    480             *p_err = OS_ERR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x8020             STRH     R0,[R4, #+0]
    481          }
   \                     ??OSSchedLock_1: (+1)
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    482          
    483          /*$PAGE*/
    484          /*
    485          ************************************************************************************************************************
    486          *                                                  ENABLE SCHEDULING
    487          *
    488          * Description: This function is used to re-allow rescheduling.
    489          *
    490          * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
    491          *
    492          *                            OS_ERR_NONE
    493          *                            OS_ERR_OS_NOT_RUNNING       The scheduler has been enabled
    494          *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
    495          *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
    496          *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR.
    497          *
    498          * Returns    : none
    499          *
    500          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
    501          *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
    502          ************************************************************************************************************************
    503          */
    504          

   \                                 In section .text, align 2, keep-with-next
    505          void  OSSchedUnlock (OS_ERR  *p_err)
    506          {
   \                     OSSchedUnlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    507              CPU_SR_ALLOC();
   \   00000004   0x2500             MOVS     R5,#+0
    508          
    509          
    510          
    511          #ifdef OS_SAFETY_CRITICAL
    512              if (p_err == (OS_ERR *)0) {
    513                  OS_SAFETY_CRITICAL_EXCEPTION();
    514                  return;
    515              }
    516          #endif
    517          
    518          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    519              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedUnlock_0
    520                 *p_err = OS_ERR_SCHED_UNLOCK_ISR;
   \   00000010   0xF646 0x5065      MOVW     R0,#+28005
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    521                  return;
   \   00000016   0xE036             B.N      ??OSSchedUnlock_1
    522              }
    523          #endif
    524          
    525              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
   \                     ??OSSchedUnlock_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSSchedUnlock_2
    526                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    527                  return;
   \   00000028   0xE02D             B.N      ??OSSchedUnlock_1
    528              }
    529          
    530              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
   \                     ??OSSchedUnlock_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD103             BNE.N    ??OSSchedUnlock_3
    531                 *p_err = OS_ERR_SCHED_NOT_LOCKED;
   \   00000034   0xF646 0x5064      MOVW     R0,#+28004
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    532                  return;
   \   0000003A   0xE024             B.N      ??OSSchedUnlock_1
    533              }
    534          
    535              CPU_CRITICAL_ENTER();
   \                     ??OSSchedUnlock_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x0005             MOVS     R5,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    536              OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable22_2
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    537              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD008             BEQ.N    ??OSSchedUnlock_4
    538                  CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
    539                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000068   0xF646 0x5063      MOVW     R0,#+28003
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    540                  return;
   \   0000006E   0xE00A             B.N      ??OSSchedUnlock_1
    541              }
    542          
    543          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    544              OS_SchedLockTimeMeasStop();
   \                     ??OSSchedUnlock_4: (+1)
   \   00000070   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
    545          #endif
    546          
    547              CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
   \   00000074   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x.... 0x....      BL       CPU_SR_Restore
    548              OSSched();                                              /* Run the scheduler                                      */
   \   0000007E   0x.... 0x....      BL       OSSched
    549             *p_err = OS_ERR_NONE;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x8020             STRH     R0,[R4, #+0]
    550          }
   \                     ??OSSchedUnlock_1: (+1)
   \   00000086   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    551          
    552          /*$PAGE*/
    553          /*
    554          ************************************************************************************************************************
    555          *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
    556          *
    557          * Description: This function is called to change the round-robin scheduling parameters.
    558          *
    559          * Arguments  : en                determines whether round-robin will be enabled (when DEF_EN) or not (when DEF_DIS)
    560          *
    561          *              dflt_time_quanta  default number of ticks between time slices.  0 means assumes OSCfg_TickRate_Hz / 10.
    562          *
    563          *              p_err             is a pointer to a variable that will contain an error code returned by this function.
    564          *
    565          *                                    OS_ERR_NONE    The call was successful
    566          *
    567          * Returns    : none
    568          ************************************************************************************************************************
    569          */
    570          
    571          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    572          void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
    573                                      OS_TICK       dflt_time_quanta,
    574                                      OS_ERR       *p_err)
    575          {
   \                     OSSchedRoundRobinCfg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    576              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    577          
    578          
    579          
    580          #ifdef OS_SAFETY_CRITICAL
    581              if (p_err == (OS_ERR *)0) {
    582                  OS_SAFETY_CRITICAL_EXCEPTION();
    583                  return;
    584              }
    585          #endif
    586          
    587              CPU_CRITICAL_ENTER();
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
   \   0000000E   0x0007             MOVS     R7,R0
   \   00000010   0x.... 0x....      BL       CPU_IntDisMeasStart
    588              if (en != DEF_ENABLED) {
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD004             BEQ.N    ??OSSchedRoundRobinCfg_0
    589                  OSSchedRoundRobinEn = DEF_DISABLED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   \   00000022   0xE003             B.N      ??OSSchedRoundRobinCfg_1
    590              } else {
    591                  OSSchedRoundRobinEn = DEF_ENABLED;
   \                     ??OSSchedRoundRobinCfg_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    592              }
    593          
    594              if (dflt_time_quanta > (OS_TICK)0) {
   \                     ??OSSchedRoundRobinCfg_1: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD003             BEQ.N    ??OSSchedRoundRobinCfg_2
    595                  OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000034   0x6005             STR      R5,[R0, #+0]
   \   00000036   0xE008             B.N      ??OSSchedRoundRobinCfg_3
    596              } else {
    597                  OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
   \                     ??OSSchedRoundRobinCfg_2: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x210A             MOVS     R1,#+10
   \   00000040   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000048   0x6008             STR      R0,[R1, #+0]
    598              }
    599              CPU_CRITICAL_EXIT();
   \                     ??OSSchedRoundRobinCfg_3: (+1)
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
    600             *p_err = OS_ERR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    601          }
   \   00000058   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    602          #endif
    603          
    604          /*$PAGE*/
    605          /*
    606          ************************************************************************************************************************
    607          *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
    608          *
    609          * Description: This function is called to give up the CPU when it is done executing before its time slice expires.
    610          *
    611          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    612          *
    613          *                             OS_ERR_NONE                   The call was successful
    614          *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
    615          *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
    616          *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
    617          *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
    618          *
    619          * Returns    : none
    620          *
    621          * Note(s)    : 1) This function MUST be called from a task.
    622          ************************************************************************************************************************
    623          */
    624          
    625          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    626          void  OSSchedRoundRobinYield (OS_ERR  *p_err)
    627          {
   \                     OSSchedRoundRobinYield: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    628              OS_RDY_LIST  *p_rdy_list;
    629              OS_TCB       *p_tcb;
    630              CPU_SR_ALLOC();
   \   00000004   0x2700             MOVS     R7,#+0
    631          
    632          
    633          
    634          #ifdef OS_SAFETY_CRITICAL
    635              if (p_err == (OS_ERR *)0) {
    636                  OS_SAFETY_CRITICAL_EXCEPTION();
    637                  return;
    638              }
    639          #endif
    640          
    641          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    642              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedRoundRobinYield_0
    643                 *p_err = OS_ERR_YIELD_ISR;
   \   00000010   0xF248 0x40D1      MOVW     R0,#+34001
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    644                  return;
   \   00000016   0xE043             B.N      ??OSSchedRoundRobinYield_1
    645              }
    646          #endif
    647          
    648              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
   \                     ??OSSchedRoundRobinYield_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??OSSchedRoundRobinYield_2
    649                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000022   0xF646 0x5063      MOVW     R0,#+28003
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    650                  return;
   \   00000028   0xE03A             B.N      ??OSSchedRoundRobinYield_1
    651              }
    652          
    653              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
   \                     ??OSSchedRoundRobinYield_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD003             BEQ.N    ??OSSchedRoundRobinYield_3
    654                 *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
   \   00000034   0xF646 0x107B      MOVW     R0,#+27003
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    655                  return;
   \   0000003A   0xE031             B.N      ??OSSchedRoundRobinYield_1
    656              }
    657          
    658              CPU_CRITICAL_ENTER();
   \                     ??OSSchedRoundRobinYield_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x0007             MOVS     R7,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    659              p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000004E   0x7809             LDRB     R1,[R1, #+0]
   \   00000050   0x220C             MOVS     R2,#+12
   \   00000052   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000056   0x0005             MOVS     R5,R0
    660              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
   \   00000058   0x8928             LDRH     R0,[R5, #+8]
   \   0000005A   0x2802             CMP      R0,#+2
   \   0000005C   0xDA08             BGE.N    ??OSSchedRoundRobinYield_4
    661                  CPU_CRITICAL_EXIT();
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
    662                 *p_err = OS_ERR_ROUND_ROBIN_1;
   \   00000068   0xF646 0x107A      MOVW     R0,#+27002
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    663                  return;
   \   0000006E   0xE017             B.N      ??OSSchedRoundRobinYield_1
    664              }
    665          
    666              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
   \                     ??OSSchedRoundRobinYield_4: (+1)
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
    667              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0x0006             MOVS     R6,R0
    668              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
   \   0000007A   0x6D70             LDR      R0,[R6, #+84]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD104             BNE.N    ??OSSchedRoundRobinYield_5
    669                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x65B0             STR      R0,[R6, #+88]
   \   00000088   0xE001             B.N      ??OSSchedRoundRobinYield_6
    670              } else {
    671                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
   \                     ??OSSchedRoundRobinYield_5: (+1)
   \   0000008A   0x6D70             LDR      R0,[R6, #+84]
   \   0000008C   0x65B0             STR      R0,[R6, #+88]
    672              }
    673          
    674              CPU_CRITICAL_EXIT();
   \                     ??OSSchedRoundRobinYield_6: (+1)
   \   0000008E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       CPU_SR_Restore
    675          
    676              OSSched();                                              /* Run new task                                           */
   \   00000098   0x.... 0x....      BL       OSSched
    677             *p_err = OS_ERR_NONE;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x8020             STRH     R0,[R4, #+0]
    678          }
   \                     ??OSSchedRoundRobinYield_1: (+1)
   \   000000A0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    679          #endif
    680          
    681          /*$PAGE*/
    682          /*
    683          ************************************************************************************************************************
    684          *                                                 START MULTITASKING
    685          *
    686          * Description: This function is used to start the multitasking process which lets uC/OS-III manages the task that you
    687          *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
    688          *              one application task.
    689          *
    690          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    691          *
    692          *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned.
    693          *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
    694          *
    695          * Returns    : none
    696          *
    697          * Note(s)    : 1) OSStartHighRdy() MUST:
    698          *                 a) Call OSTaskSwHook() then,
    699          *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
    700          *                 c) Execute the task.
    701          *
    702          *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
    703          ************************************************************************************************************************
    704          */
    705          

   \                                 In section .text, align 2, keep-with-next
    706          void  OSStart (OS_ERR  *p_err)
    707          {
   \                     OSStart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    708          #ifdef OS_SAFETY_CRITICAL
    709              if (p_err == (OS_ERR *)0) {
    710                  OS_SAFETY_CRITICAL_EXCEPTION();
    711                  return;
    712              }
    713          #endif
    714          
    715              if (OSRunning == OS_STATE_OS_STOPPED) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD126             BNE.N    ??OSStart_0
    716                  OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
   \   0000000E   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    717                  OSPrioCur       = OSPrioHighRdy;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    718                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000002C   0x7809             LDRB     R1,[R1, #+0]
   \   0000002E   0x220C             MOVS     R2,#+12
   \   00000030   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    719                  OSTCBCurPtr     = OSTCBHighRdyPtr;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000046   0x6008             STR      R0,[R1, #+0]
    720                  OSRunning       = OS_STATE_OS_RUNNING;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    721                  OSStartHighRdy();                                   /* Execute target specific code to start task             */
   \   00000050   0x.... 0x....      BL       OSStartHighRdy
    722                 *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
   \   00000054   0xF643 0x2099      MOVW     R0,#+15001
   \   00000058   0x8020             STRH     R0,[R4, #+0]
   \   0000005A   0xE002             B.N      ??OSStart_1
    723              } else {
    724                 *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
   \                     ??OSStart_0: (+1)
   \   0000005C   0xF645 0x608A      MOVW     R0,#+24202
   \   00000060   0x8020             STRH     R0,[R4, #+0]
    725              }
    726          }
   \                     ??OSStart_1: (+1)
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    727          
    728          /*$PAGE*/
    729          /*
    730          ************************************************************************************************************************
    731          *                                                    GET VERSION
    732          *
    733          * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
    734          *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
    735          *
    736          * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
    737          *                      variable to
    738          *
    739          *                         OS_ERR_NONE
    740          *
    741          * Returns    : The version number of uC/OS-III multiplied by 10000.
    742          ************************************************************************************************************************
    743          */
    744          

   \                                 In section .text, align 2, keep-with-next
    745          CPU_INT16U  OSVersion (OS_ERR  *p_err)
    746          {
   \                     OSVersion: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    747          #ifdef OS_SAFETY_CRITICAL
    748              if (p_err == (OS_ERR *)0) {
    749                  OS_SAFETY_CRITICAL_EXCEPTION();
    750                  return ((CPU_INT16U)0u);
    751              }
    752          #endif
    753          
    754             *p_err = OS_ERR_NONE;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    755              return (OS_VERSION);
   \   00000006   0xF247 0x605D      MOVW     R0,#+30301
   \   0000000A   0x4770             BX       LR               ;; return
    756          }
    757          
    758          /*$PAGE*/
    759          /*
    760          ************************************************************************************************************************
    761          *                                                      IDLE TASK
    762          *
    763          * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
    764          *              they are ALL waiting for event(s) to occur.
    765          *
    766          * Arguments  : p_arg    is an argument passed to the task when the task is created.
    767          *
    768          * Returns    : none
    769          *
    770          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    771          *
    772          *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
    773          *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
    774          *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
    775          *                 uC/OS-III would thus never recognize interrupts.
    776          *
    777          *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
    778          ************************************************************************************************************************
    779          */
    780          

   \                                 In section .text, align 2, keep-with-next
    781          void  OS_IdleTask (void  *p_arg)
    782          {
   \                     OS_IdleTask: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    783              CPU_SR_ALLOC();
   \   00000004   0x2400             MOVS     R4,#+0
    784          
    785          
    786          
    787              p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
    788          
    789              while (DEF_ON) {
    790                  CPU_CRITICAL_ENTER();
   \                     ??OS_IdleTask_0: (+1)
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    791                  OSIdleTaskCtr++;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable22_3
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    792          #if OS_CFG_STAT_TASK_EN > 0u
    793                  OSStatTaskCtr++;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable22_4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    794          #endif
    795                  CPU_CRITICAL_EXIT();
   \   0000002C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
    796          
    797                  OSIdleTaskHook();                                   /* Call user definable HOOK                               */
   \   00000036   0x.... 0x....      BL       OSIdleTaskHook
   \   0000003A   0xE7E4             B.N      ??OS_IdleTask_0
    798              }
    799          }
    800          
    801          /*$PAGE*/
    802          /*
    803          ************************************************************************************************************************
    804          *                                               INITIALIZE THE IDLE TASK
    805          *
    806          * Description: This function initializes the idle task
    807          *
    808          * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
    809          *
    810          * Returns    : none
    811          *
    812          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    813          ************************************************************************************************************************
    814          */
    815          

   \                                 In section .text, align 2, keep-with-next
    816          void  OS_IdleTaskInit (OS_ERR  *p_err)
    817          {
   \                     OS_IdleTaskInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    818          #ifdef OS_SAFETY_CRITICAL
    819              if (p_err == (OS_ERR *)0) {
    820                  OS_SAFETY_CRITICAL_EXCEPTION();
    821                  return;
    822              }
    823          #endif
    824          
    825              OSIdleTaskCtr = (OS_IDLE_CTR)0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable22_3
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    826                                                                      /* ---------------- CREATE THE IDLE TASK ---------------- */
    827              OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
    828                           (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
    829                           (OS_TASK_PTR)OS_IdleTask,
    830                           (void       *)0,
    831                           (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
    832                           (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
    833                           (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
    834                           (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
    835                           (OS_MSG_QTY  )0u,
    836                           (OS_TICK     )0u,
    837                           (void       *)0,
    838                           (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    839                           (OS_ERR     *)p_err);
   \   0000000E   0x9408             STR      R4,[SP, #+32]
   \   00000010   0x200B             MOVS     R0,#+11
   \   00000012   0x9007             STR      R0,[SP, #+28]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9006             STR      R0,[SP, #+24]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9005             STR      R0,[SP, #+20]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9004             STR      R0,[SP, #+16]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable22_5
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x9003             STR      R0,[SP, #+12]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable22_6
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x9002             STR      R0,[SP, #+8]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable22_7
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0x201F             MOVS     R0,#+31
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable22_8
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable22_10
   \   0000004A   0x.... 0x....      BL       OSTaskCreate
    840          }
   \   0000004E   0xB00A             ADD      SP,SP,#+40
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    841          
    842          /*$PAGE*/
    843          /*
    844          ************************************************************************************************************************
    845          *                                             BLOCK A TASK PENDING ON EVENT
    846          *
    847          * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
    848          *              exist because it is common to a number of OSxxxPend() services.
    849          *
    850          * Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
    851          *              -----------    pending on the desired object.
    852          
    853          *              p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
    854          *              -----          the caller must pass a NULL pointer.
    855          *
    856          *              pending_on     Specifies what the task will be pending on:
    857          *
    858          *                                 OS_TASK_PEND_ON_FLAG
    859          *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
    860          *                                 OS_TASK_PEND_ON_MUTEX
    861          *                                 OS_TASK_PEND_ON_Q
    862          *                                 OS_TASK_PEND_ON_SEM
    863          *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
    864          *
    865          *              timeout        Is the amount of time the task will wait for the event to occur.
    866          *
    867          * Returns    : none
    868          *
    869          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    870          ************************************************************************************************************************
    871          */
    872          

   \                                 In section .text, align 2, keep-with-next
    873          void  OS_Pend (OS_PEND_DATA  *p_pend_data,
    874                         OS_PEND_OBJ   *p_obj,
    875                         OS_STATE       pending_on,
    876                         OS_TICK        timeout)
    877          {
   \                     OS_Pend: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    878              OS_PEND_LIST  *p_pend_list;
    879          
    880          
    881          
    882              OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF880 0x6034      STRB     R6,[R0, #+52]
    883              OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF881 0x0035      STRB     R0,[R1, #+53]
    884          
    885              OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
    886                           timeout);
   \   00000022   0x0039             MOVS     R1,R7
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       OS_TaskBlock
    887          
    888              if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD00F             BEQ.N    ??OS_Pend_0
    889                  p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
   \   00000032   0xF115 0x0008      ADDS     R0,R5,#+8
   \   00000036   0x4680             MOV      R8,R0
    890                  p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
   \   00000038   0x60E5             STR      R5,[R4, #+12]
    891                  OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
    892                                  (OS_PEND_DATA *)p_pend_data,
    893                                  (OS_OBJ_QTY    )1);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x0021             MOVS     R1,R4
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x.... 0x....      BL       OS_PendDataInit
    894                  OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
    895                                        p_pend_data);
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0x4640             MOV      R0,R8
   \   0000004C   0x.... 0x....      BL       OS_PendListInsertPrio
   \   00000050   0xE009             B.N      ??OS_Pend_1
    896              } else {
    897                  OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
   \                     ??OS_Pend_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x87C8             STRH     R0,[R1, #+62]
    898                  OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x6308             STR      R0,[R1, #+48]
    899              }
    900          #if OS_CFG_DBG_EN > 0u
    901              OS_PendDbgNameAdd(p_obj,
    902                                OSTCBCurPtr);
   \                     ??OS_Pend_1: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       OS_PendDbgNameAdd
    903          #endif
    904          }
   \   00000072   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    905          
    906          /*$PAGE*/
    907          /*
    908          ************************************************************************************************************************
    909          *                                                     ABORT PENDING
    910          *
    911          * Description: This function is called by OSxxxPendAbort() functions to abort pending on an event.
    912          *
    913          * Arguments  : p_obj          Is a pointer to the object to pend abort.
    914          *              -----
    915          *
    916          *              p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
    917          *              -----
    918          *
    919          *              ts             The is a timestamp as to when the pend abort occurred
    920          *
    921          * Returns    : none
    922          *
    923          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    924          ************************************************************************************************************************
    925          */
    926          

   \                                 In section .text, align 2, keep-with-next
    927          void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
    928                              OS_TCB       *p_tcb,
    929                              CPU_TS        ts)
    930          {
   \                     OS_PendAbort: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    931              switch (p_tcb->TaskState) {
   \   00000008   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00B             BEQ.N    ??OS_PendAbort_0
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD00A             BEQ.N    ??OS_PendAbort_1
   \   00000014   0xD308             BCC.N    ??OS_PendAbort_0
   \   00000016   0x2804             CMP      R0,#+4
   \   00000018   0xD006             BEQ.N    ??OS_PendAbort_0
   \   0000001A   0xD306             BCC.N    ??OS_PendAbort_1
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xD025             BEQ.N    ??OS_PendAbort_2
   \   00000020   0xD302             BCC.N    ??OS_PendAbort_0
   \   00000022   0x2807             CMP      R0,#+7
   \   00000024   0xD022             BEQ.N    ??OS_PendAbort_2
   \   00000026   0xE042             B.N      ??OS_PendAbort_3
    932                  case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
    933                  case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
    934                  case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
    935                  case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
    936                       break;
   \                     ??OS_PendAbort_0: (+1)
   \   00000028   0xE041             B.N      ??OS_PendAbort_4
    937          
    938                  case OS_TASK_STATE_PEND:
    939                  case OS_TASK_STATE_PEND_TIMEOUT:
    940                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendAbort_1: (+1)
   \   0000002A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD104             BNE.N    ??OS_PendAbort_5
    941                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    942                                         p_tcb,
    943                                         ts);
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_PendAbort1
    944                       }
    945          #if (OS_MSG_EN > 0u)
    946                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_PendAbort_5: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x65E8             STR      R0,[R5, #+92]
    947                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF8A5 0x0060      STRH     R0,[R5, #+96]
    948          #endif
    949                       p_tcb->TS         = ts;
   \   00000046   0x642E             STR      R6,[R5, #+64]
    950                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD002             BEQ.N    ??OS_PendAbort_6
    951                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       OS_PendListRemove
    952                       }
    953                       OS_TaskRdy(p_tcb);
   \                     ??OS_PendAbort_6: (+1)
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       OS_TaskRdy
    954                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF885 0x0036      STRB     R0,[R5, #+54]
    955                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF885 0x0035      STRB     R0,[R5, #+53]
    956                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF885 0x0034      STRB     R0,[R5, #+52]
    957                       break;
   \   0000006A   0xE020             B.N      ??OS_PendAbort_4
    958          
    959                  case OS_TASK_STATE_PEND_SUSPENDED:
    960                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    961                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendAbort_2: (+1)
   \   0000006C   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000070   0x2803             CMP      R0,#+3
   \   00000072   0xD104             BNE.N    ??OS_PendAbort_7
    962                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    963                                         p_tcb,
    964                                         ts);
   \   00000074   0x0032             MOVS     R2,R6
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       OS_PendAbort1
    965                       }
    966          #if (OS_MSG_EN > 0u)
    967                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_PendAbort_7: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x65E8             STR      R0,[R5, #+92]
    968                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF8A5 0x0060      STRH     R0,[R5, #+96]
    969          #endif
    970                       p_tcb->TS         = ts;
   \   00000088   0x642E             STR      R6,[R5, #+64]
    971                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD002             BEQ.N    ??OS_PendAbort_8
    972                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
   \   0000008E   0x0028             MOVS     R0,R5
   \   00000090   0x.... 0x....      BL       OS_PendListRemove
    973                       }
    974                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   \                     ??OS_PendAbort_8: (+1)
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0x.... 0x....      BL       OS_TickListRemove
    975                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
   \   0000009A   0x2004             MOVS     R0,#+4
   \   0000009C   0xF885 0x0036      STRB     R0,[R5, #+54]
    976                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF885 0x0035      STRB     R0,[R5, #+53]
    977                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF885 0x0034      STRB     R0,[R5, #+52]
    978                       break;
   \   000000AC   0xE7FF             B.N      ??OS_PendAbort_4
    979          
    980                  default:
    981                       break;
    982              }
    983          }
   \                     ??OS_PendAbort_3: (+1)
   \                     ??OS_PendAbort_4: (+1)
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    984          
    985          /*$PAGE*/
    986          /*
    987          ************************************************************************************************************************
    988          *                                           PEND ABORT A TASK PENDING ON MULTIPLE OBJECTS
    989          *
    990          * Description: This function is called when a task is pending on multiple objects and one of the objects has been pend
    991          *              aborted.  This function needs to indicate to the caller which object was pend aborted by placing the
    992          *              address of the object in the OS_PEND_DATA table corresponding to the pend aborted object.
    993          *
    994          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
    995          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries of the
    996          *              OS_TCB would be set to six (6) in this case.  As shown, when the pend call returns because a task pend
    997          *              aborted 'Obj C' then, only the one entry contains the .RdyObjPtr filled in data and the other entries
    998          *              contains NULL pointers and zero data.
    999          *
   1000          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1001          *
   1002          *
   1003          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1004          *                                         +--------------+--------------+--------------+--------------+--------------+
   1005          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1006          *                                         +--------------+--------------+--------------+--------------+--------------+
   1007          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1008          *                                         +--------------+--------------+--------------+--------------+--------------+
   1009          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
   1010          *                                         +--------------+--------------+--------------+--------------+--------------+
   1011          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1012          *                                         +--------------+--------------+--------------+--------------+--------------+
   1013          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1014          *                                         +--------------+--------------+--------------+--------------+--------------+
   1015          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1016          *                                         +--------------+--------------+--------------+--------------+--------------+
   1017          *
   1018          *
   1019          * Arguments  : p_obj        is a pointer to the object being pend aborted to
   1020          *              -----
   1021          *
   1022          *              p_tcb        is a pointer to the OS_TCB of the task that we'll abort he pend for
   1023          *              -----
   1024          *
   1025          *              ts           is the time stamp of when the pend abort occurred
   1026          *
   1027          * Returns    : none
   1028          *
   1029          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1030          ************************************************************************************************************************
   1031          */
   1032          

   \                                 In section .text, align 2, keep-with-next
   1033          void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
   1034                               OS_TCB       *p_tcb,
   1035                               CPU_TS        ts)
   1036          {
   \                     OS_PendAbort1: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1037              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1038              OS_PEND_DATA   *p_pend_data;
   1039          
   1040          
   1041          
   1042              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000002   0x6B0D             LDR      R5,[R1, #+48]
   \   00000004   0x002C             MOVS     R4,R5
   1043              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000006   0x8FCD             LDRH     R5,[R1, #+62]
   \   00000008   0x002B             MOVS     R3,R5
   1044          
   1045              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   \                     ??OS_PendAbort1_0: (+1)
   \   0000000A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD008             BEQ.N    ??OS_PendAbort1_1
   1046                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
   \   00000010   0x68E5             LDR      R5,[R4, #+12]
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xD102             BNE.N    ??OS_PendAbort1_2
   1047                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   \   00000016   0x6120             STR      R0,[R4, #+16]
   1048                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
   \   00000018   0x61E2             STR      R2,[R4, #+28]
   1049                      break;
   \   0000001A   0xE002             B.N      ??OS_PendAbort1_1
   1050                  }
   1051                  p_pend_data++;
   \                     ??OS_PendAbort1_2: (+1)
   \   0000001C   0x3420             ADDS     R4,R4,#+32
   1052                  n_pend_list--;
   \   0000001E   0x1E5B             SUBS     R3,R3,#+1
   \   00000020   0xE7F3             B.N      ??OS_PendAbort1_0
   1053              }
   1054          }
   \                     ??OS_PendAbort1_1: (+1)
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
   1055          
   1056          /*$PAGE*/
   1057          /*
   1058          ************************************************************************************************************************
   1059          *                                              INITIALIZE A WAIT LIST TABLE
   1060          *
   1061          * Description: This function is called to initialize the fields of a table of OS_PEND_DATA entries.  It's assumed that
   1062          *              the .PendObjPtr field of each entry in the table is set by the caller and thus will NOT be touched by
   1063          *              this function.
   1064          *
   1065          * Arguments  : p_tcb              is a pointer to the TCB of the task that we want to pend abort.
   1066          *              -----
   1067          *
   1068          *              p_pend_data_tbl    is a pointer to a table (see below) of OS_PEND_DATA elements to initialize.
   1069          *              ---------------
   1070          *
   1071          *                                  .PendObjPtr .RdyObjPtr .RdyMsgPtr .RdyMsgSize .RdyTS .TCBPtr .NextPtr .PrevPtr
   1072          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    ^
   1073          *               p_pend_data_tbl-> |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1074          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1075          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1076          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1077          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1078          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+  size
   1079          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1080          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1081          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1082          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1083          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1084          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    V
   1085          *
   1086          *              tbl_size           is the size of the table in number of entries
   1087          *
   1088          * Returns    : none
   1089          *
   1090          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1091          *
   1092          *              2) It's possible for the table to be of size 1 when multi-pend is not used
   1093          *
   1094          *              3) Note that the .PendObjPtr is NOT touched because it's assumed to be set by the caller.
   1095          ************************************************************************************************************************
   1096          */
   1097          

   \                                 In section .text, align 2, keep-with-next
   1098          void  OS_PendDataInit (OS_TCB        *p_tcb,
   1099                                 OS_PEND_DATA  *p_pend_data_tbl,
   1100                                 OS_OBJ_QTY     tbl_size)
   1101          {
   \                     OS_PendDataInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1102              OS_OBJ_QTY  i;
   1103          
   1104          
   1105          
   1106              p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
   \   00000002   0x87C2             STRH     R2,[R0, #+62]
   1107              p_tcb->PendDataTblPtr     = p_pend_data_tbl;
   \   00000004   0x6301             STR      R1,[R0, #+48]
   1108          
   1109              for (i = 0u; i < tbl_size; i++) {
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x0023             MOVS     R3,R4
   \                     ??OS_PendDataInit_0: (+1)
   \   0000000A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   0x4293             CMP      R3,R2
   \   00000010   0xD20F             BCS.N    ??OS_PendDataInit_1
   1110                  p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x604C             STR      R4,[R1, #+4]
   1111                  p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0x600C             STR      R4,[R1, #+0]
   1112                  p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x610C             STR      R4,[R1, #+16]
   1113                  p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x614C             STR      R4,[R1, #+20]
   1114                  p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0x830C             STRH     R4,[R1, #+24]
   1115                  p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x61CC             STR      R4,[R1, #+28]
   1116                  p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
   \   0000002A   0x6088             STR      R0,[R1, #+8]
   1117                  p_pend_data_tbl++;
   \   0000002C   0x3120             ADDS     R1,R1,#+32
   1118              }
   \   0000002E   0x1C5B             ADDS     R3,R3,#+1
   \   00000030   0xE7EB             B.N      ??OS_PendDataInit_0
   1119          }
   \                     ??OS_PendDataInit_1: (+1)
   \   00000032   0xBC10             POP      {R4}
   \   00000034   0x4770             BX       LR               ;; return
   1120          
   1121          /*$PAGE*/
   1122          /*
   1123          ************************************************************************************************************************
   1124          *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
   1125          *
   1126          * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
   1127          *              using a kernel aware tool.
   1128          *
   1129          * Arguments  : p_obj              is a pointer to the object being pended on
   1130          *
   1131          *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
   1132          *
   1133          * Returns    : none
   1134          *
   1135          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
   1136          ************************************************************************************************************************
   1137          */
   1138          
   1139          
   1140          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1141          void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
   1142                                   OS_TCB       *p_tcb)
   1143          {
   \                     OS_PendDbgNameAdd: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1144              OS_PEND_LIST  *p_pend_list;
   1145              OS_PEND_DATA  *p_pend_data;
   1146              OS_TCB        *p_tcb1;
   1147          
   1148          
   1149              if (p_obj != (OS_PEND_OBJ *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00C             BEQ.N    ??OS_PendDbgNameAdd_0
   1150                  p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
   \   00000006   0x6845             LDR      R5,[R0, #+4]
   \   00000008   0xF8C1 0x50C4      STR      R5,[R1, #+196]
   1151                  p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
   \   0000000C   0xF110 0x0508      ADDS     R5,R0,#+8
   \   00000010   0x002A             MOVS     R2,R5
   1152                  p_pend_data       =  p_pend_list->HeadPtr;
   \   00000012   0x6815             LDR      R5,[R2, #+0]
   \   00000014   0x002B             MOVS     R3,R5
   1153                  p_tcb1            =  p_pend_data->TCBPtr;
   \   00000016   0x689D             LDR      R5,[R3, #+8]
   \   00000018   0x002C             MOVS     R4,R5
   1154                  p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
   \   0000001A   0x6A25             LDR      R5,[R4, #+32]
   \   0000001C   0x61C5             STR      R5,[R0, #+28]
   \   0000001E   0xE013             B.N      ??OS_PendDbgNameAdd_1
   1155              } else {
   1156                  switch (p_tcb->PendOn) {
   \                     ??OS_PendDbgNameAdd_0: (+1)
   \   00000020   0xF891 0x5034      LDRB     R5,[R1, #+52]
   \   00000024   0x2D02             CMP      R5,#+2
   \   00000026   0xD002             BEQ.N    ??OS_PendDbgNameAdd_2
   \   00000028   0x2D07             CMP      R5,#+7
   \   0000002A   0xD005             BEQ.N    ??OS_PendDbgNameAdd_3
   \   0000002C   0xE009             B.N      ??OS_PendDbgNameAdd_4
   1157                      case OS_TASK_PEND_ON_TASK_Q:
   1158                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   \                     ??OS_PendDbgNameAdd_2: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R5,??DataTable22_11
   \   00000032   0xF8C1 0x50C4      STR      R5,[R1, #+196]
   1159                           break;
   \   00000036   0xE007             B.N      ??OS_PendDbgNameAdd_1
   1160          
   1161                      case OS_TASK_PEND_ON_TASK_SEM:
   1162                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   \                     ??OS_PendDbgNameAdd_3: (+1)
   \   00000038   0x.... 0x....      LDR.W    R5,??DataTable22_12
   \   0000003C   0xF8C1 0x50C4      STR      R5,[R1, #+196]
   1163                           break;
   \   00000040   0xE002             B.N      ??OS_PendDbgNameAdd_1
   1164          
   1165                      default:
   1166                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   \                     ??OS_PendDbgNameAdd_4: (+1)
   \   00000042   0x....             ADR.N    R5,??DataTable13  ;; " "
   \   00000044   0xF8C1 0x50C4      STR      R5,[R1, #+196]
   1167                           break;
   1168                  }
   1169              }
   1170          }
   \                     ??OS_PendDbgNameAdd_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
   1171          
   1172          
   1173          

   \                                 In section .text, align 2, keep-with-next
   1174          void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
   1175                                      OS_TCB       *p_tcb)
   1176          {
   \                     OS_PendDbgNameRemove: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1177              OS_PEND_LIST  *p_pend_list;
   1178              OS_PEND_DATA  *p_pend_data;
   1179              OS_TCB        *p_tcb1;
   1180          
   1181          
   1182              p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
   \   00000002   0x....             ADR.N    R5,??DataTable13  ;; " "
   \   00000004   0xF8C1 0x50C4      STR      R5,[R1, #+196]
   1183              p_pend_list       = &p_obj->PendList;
   \   00000008   0xF110 0x0508      ADDS     R5,R0,#+8
   \   0000000C   0x002A             MOVS     R2,R5
   1184              p_pend_data       =  p_pend_list->HeadPtr;
   \   0000000E   0x6815             LDR      R5,[R2, #+0]
   \   00000010   0x002B             MOVS     R3,R5
   1185              if (p_pend_data  != (OS_PEND_DATA *)0) {
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD004             BEQ.N    ??OS_PendDbgNameRemove_0
   1186                  p_tcb1            = p_pend_data->TCBPtr;
   \   00000016   0x689D             LDR      R5,[R3, #+8]
   \   00000018   0x002C             MOVS     R4,R5
   1187                  p_obj->DbgNamePtr = p_tcb1->NamePtr;
   \   0000001A   0x6A25             LDR      R5,[R4, #+32]
   \   0000001C   0x61C5             STR      R5,[R0, #+28]
   \   0000001E   0xE001             B.N      ??OS_PendDbgNameRemove_1
   1188              } else {
   1189                  p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
   \                     ??OS_PendDbgNameRemove_0: (+1)
   \   00000020   0x....             ADR.N    R5,??DataTable13  ;; " "
   \   00000022   0x61C5             STR      R5,[R0, #+28]
   1190              }
   1191          }
   \                     ??OS_PendDbgNameRemove_1: (+1)
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
   1192          #endif
   1193          
   1194          /*$PAGE*/
   1195          /*
   1196          ************************************************************************************************************************
   1197          *                               CHANGE THE PRIORITY OF A TASK WAITING IN ONE OR MORE PEND LISTS
   1198          *
   1199          * Description: This function is called to change the position of a task waiting in one or more pend lists.  Because a
   1200          *              task can be waiting on multiple objects then each pend list needs to be updated.  Specifically, the
   1201          *              task can be the highest priority task waiting on one pend list, the lowest priority task waiting in yet
   1202          *              another pend list or somewhere else in another pend list.  Because of this, we need to be able to change
   1203          *              each of those pend lists individually.
   1204          *
   1205          *              The drawing below shows an example of a task (OS_TCB) that belongs to 3 separate pend lists.  Each
   1206          *              pend list can contain multiple tasks (the .PrevPtr and .NextPtr show a '?' to indicate this).  The OS_TCB
   1207          *              contains a pointer (.PendDataTblPtr) to the first entry in the list of pend lists.
   1208          *
   1209          *                                                                                                          OS_TCB
   1210          *                                                                                                   +--------------------+
   1211          *                                                                                                   |                    |
   1212          *                                                                                                   +--------------------+
   1213          *                                                                                                   | PendDataTblEntries |
   1214          *                                      Point to first entry in the OS_PEND_DATA table (i.e. [0])    +--------------------+
   1215          *                                          /-----------------------------<------------------------- | PendDataTblPtr     |
   1216          *                                          |                                                        +--------------------+
   1217          *                                          |                                                                 ^
   1218          *              OS_PEND_LIST                |                                                                 |
   1219          *              +------------+              |                                                                 |
   1220          *              | TailPtr    |              |                                                                 |
   1221          *              +------------+              |                                                                 |
   1222          *              | HeadPtr    |              |                                                                 |
   1223          *              +------------+              |                                        /---------->-------------/
   1224          *              | NbrEntries |              |                                        |                        |
   1225          *              +------------+     [0]      V   OS_PEND_DATA                         |                        |
   1226          *                                     +---------+------------+-------+---------+--------+---------+          |
   1227          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1228          *                                     +---------+------------+-------+---------+--------+---------+          |
   1229          *                                                                                                            |
   1230          *                                                                                                            |
   1231          *                                                                                                            |
   1232          *                                                                                                            |
   1233          *                                                                                                            |
   1234          *              OS_PEND_LIST                                                                Point back to TCB |
   1235          *              +------------+                                                                                |
   1236          *              | TailPtr    |                                                                                |
   1237          *              +------------+                                                                                |
   1238          *              | HeadPtr    |                                                                                |
   1239          *              +------------+                                                      /----------->-------------/
   1240          *              | NbrEntries |                                                      |                         |
   1241          *              +------------+     [1]          OS_PEND_DATA                        |                         |
   1242          *                                     +---------+------------+-------+---------+--------+---------+          |
   1243          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1244          *                                     +---------+------------+-------+---------+--------+---------+          |
   1245          *                                                                                                            |
   1246          *                                                                                                            |
   1247          *                                                                                                            |
   1248          *                                                                                                            |
   1249          *                                                                                                            |
   1250          *              OS_PEND_LIST                                                                                  |
   1251          *              +------------+                                                                                |
   1252          *              | TailPtr    |                                                                                |
   1253          *              +------------+                                                                                |
   1254          *              | HeadPtr    |                                                                                |
   1255          *              +------------+                                                      /----------->-------------/
   1256          *              | NbrEntries |                                                      |
   1257          *              +------------+     [2]          OS_PEND_DATA                        |
   1258          *                                     +---------+------------+-------+---------+--------+---------+
   1259          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | ----> ?
   1260          *                                     +---------+------------+-------+---------+--------+---------+
   1261          *
   1262          *
   1263          * Arguments  : p_tcb       is a pointer to the TCB of the task to move
   1264          *              -----
   1265          *
   1266          *              prio_new    is the new priority for the task
   1267          *
   1268          * Returns    : none
   1269          *
   1270          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1271          *
   1272          *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1273          ************************************************************************************************************************
   1274          */
   1275          

   \                                 In section .text, align 2, keep-with-next
   1276          void  OS_PendListChangePrio (OS_TCB   *p_tcb,
   1277                                       OS_PRIO   prio_new)
   1278          {
   \                     OS_PendListChangePrio: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1279              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1280              OS_PEND_DATA   *p_pend_data;
   1281              OS_PEND_LIST   *p_pend_list;
   1282              OS_PEND_OBJ    *p_obj;
   1283          
   1284          
   1285              p_tcb->Prio = prio_new;
   \   00000008   0xF884 0x5037      STRB     R5,[R4, #+55]
   1286              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
   \   0000000C   0x6B20             LDR      R0,[R4, #+48]
   \   0000000E   0x0007             MOVS     R7,R0
   1287              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
   \   00000010   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000012   0x0006             MOVS     R6,R0
   1288          
   1289              while (n_pend_list > 0u) {
   \                     ??OS_PendListChangePrio_0: (+1)
   \   00000014   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD013             BEQ.N    ??OS_PendListChangePrio_1
   1290                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   \   0000001A   0x68F8             LDR      R0,[R7, #+12]
   \   0000001C   0x4681             MOV      R9,R0
   1291                  p_pend_list = &p_obj->PendList;
   \   0000001E   0xF119 0x0008      ADDS     R0,R9,#+8
   \   00000022   0x4680             MOV      R8,R0
   1292                  if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
   \   00000024   0xF8B8 0x0008      LDRH     R0,[R8, #+8]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD307             BCC.N    ??OS_PendListChangePrio_2
   1293                      OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
   1294                                         p_pend_data);
   \   0000002C   0x0039             MOVS     R1,R7
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0x.... 0x....      BL       OS_PendListRemove1
   1295                      OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
   1296                                            p_pend_data);
   \   00000034   0x0039             MOVS     R1,R7
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       OS_PendListInsertPrio
   1297                  }
   1298                  p_pend_data++;                                              /* Point to next wait list                        */
   \                     ??OS_PendListChangePrio_2: (+1)
   \   0000003C   0x3720             ADDS     R7,R7,#+32
   1299                  n_pend_list--;
   \   0000003E   0x1E76             SUBS     R6,R6,#+1
   \   00000040   0xE7E8             B.N      ??OS_PendListChangePrio_0
   1300              }
   1301          }
   \                     ??OS_PendListChangePrio_1: (+1)
   \   00000042   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1302          
   1303          /*$PAGE*/
   1304          /*
   1305          ************************************************************************************************************************
   1306          *                                                INITIALIZE A WAIT LIST
   1307          *
   1308          * Description: This function is called to initialize the fields of an OS_PEND_LIST.
   1309          *
   1310          * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
   1311          *              -----------
   1312          *
   1313          * Returns    : none
   1314          *
   1315          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1316          ************************************************************************************************************************
   1317          */
   1318          

   \                                 In section .text, align 2, keep-with-next
   1319          void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
   1320          {
   1321              p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
   \                     OS_PendListInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1322              p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
   1323              p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
   1324          }
   \   0000000C   0x4770             BX       LR               ;; return
   1325          
   1326          /*$PAGE*/
   1327          /*
   1328          ************************************************************************************************************************
   1329          *                                     INSERT PEND DATA AT THE BEGINNING OF A WAIT LIST
   1330          *
   1331          * Description: This function is called to place an OS_PEND_DATA entry at the beginning of a linked list as follows:
   1332          *
   1333          *              CASE 0: Insert in an empty list.
   1334          *
   1335          *                     OS_PEND_LIST
   1336          *                     +--------------+
   1337          *                     | TailPtr      |-> 0
   1338          *                     +--------------+
   1339          *                     | HeadPtr      |-> 0
   1340          *                     +--------------+
   1341          *                     | NbrEntries=0 |
   1342          *                     +--------------+
   1343          *
   1344          *
   1345          *
   1346          *              CASE 1: Insert BEFORE the current head of list
   1347          *
   1348          *                     OS_PEND_LIST
   1349          *                     +--------------+         OS_PEND_DATA
   1350          *                     | TailPtr      |--+---> +------------+
   1351          *                     +--------------+  |     | NextPtr    |->0
   1352          *                     | HeadPtr      |--/     +------------+
   1353          *                     +--------------+     0<-| PrevPtr    |
   1354          *                     | NbrEntries=1 |        +------------+
   1355          *                     +--------------+        |            |
   1356          *                                             +------------+
   1357          *                                             |            |
   1358          *                                             +------------+
   1359          *
   1360          *
   1361          * Arguments  : p_pend_list    is a pointer to a wait list found inside an object.  The OS_PEND_DATA entry will be
   1362          *              -----------    inserted at the head of the list.
   1363          *
   1364          *              p_pend_data    is a pointer to the OS_PEND_DATA entry to add to the list
   1365          *              -----------
   1366          *
   1367          * Returns    : none
   1368          *
   1369          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1370          ************************************************************************************************************************
   1371          */
   1372          

   \                                 In section .text, align 2, keep-with-next
   1373          void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
   1374                                       OS_PEND_DATA  *p_pend_data)
   1375          {
   1376              OS_PEND_DATA  *p_pend_data_next;
   1377          
   1378          
   1379          
   1380              p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
   \                     OS_PendListInsertHead: (+1)
   \   00000000   0x8903             LDRH     R3,[R0, #+8]
   \   00000002   0x1C5B             ADDS     R3,R3,#+1
   \   00000004   0x8103             STRH     R3,[R0, #+8]
   1381              p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x604B             STR      R3,[R1, #+4]
   1382              p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x600B             STR      R3,[R1, #+0]
   1383              p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
   \   0000000E   0x6803             LDR      R3,[R0, #+0]
   \   00000010   0x001A             MOVS     R2,R3
   1384              if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD000             BEQ.N    ??OS_PendListInsertHead_0
   1385                  p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1386              }
   1387              p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
   \                     ??OS_PendListInsertHead_0: (+1)
   \   00000018   0x6001             STR      R1,[R0, #+0]
   1388              if (p_pend_list->NbrEntries == 1u) {
   \   0000001A   0x8903             LDRH     R3,[R0, #+8]
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD100             BNE.N    ??OS_PendListInsertHead_1
   1389                  p_pend_list->TailPtr = p_pend_data;
   \   00000020   0x6041             STR      R1,[R0, #+4]
   1390              }
   1391          }
   \                     ??OS_PendListInsertHead_1: (+1)
   \   00000022   0x4770             BX       LR               ;; return
   1392          
   1393          /*$PAGE*/
   1394          /*
   1395          ************************************************************************************************************************
   1396          *                                   INSERT PEND DATA BASED ON IT'S PRIORITY IN A LIST
   1397          *
   1398          * Description: This function is called to place an OS_PEND_DATA entry in a linked list based on its priority.  The
   1399          *              highest priority being placed at the head of the list.  It's assumed that the OS_PEND_DATA entry to
   1400          *              insert points to the TCB of the task being inserted.  The TCB is also assumed to contain the priority
   1401          *              of the task in its .Prio field.
   1402          *
   1403          *              CASE 0: Insert in an empty list.
   1404          *
   1405          *                     OS_PEND_LIST
   1406          *                     +---------------+
   1407          *                     | TailPtr       |-> 0
   1408          *                     +---------------+
   1409          *                     | HeadPtr       |-> 0
   1410          *                     +---------------+
   1411          *                     | NbrEntries=0  |
   1412          *                     +---------------+
   1413          *
   1414          *
   1415          *
   1416          *              CASE 1: Insert BEFORE or AFTER an OS_TCB
   1417          *
   1418          *                     OS_PEND_LIST
   1419          *                     +--------------+         OS_PEND_DATA
   1420          *                     | TailPtr      |--+---> +------------+
   1421          *                     +--------------+  |     | NextPtr    |->0
   1422          *                     | HeadPtr      |--/     +------------+
   1423          *                     +--------------+     0<-| PrevPtr    |
   1424          *                     | NbrEntries=1 |        +------------+
   1425          *                     +--------------+        |            |
   1426          *                                             +------------+
   1427          *                                             |            |
   1428          *                                             +------------+
   1429          *
   1430          *
   1431          *                     OS_PEND_LIST
   1432          *                     +--------------+
   1433          *                     | TailPtr      |-----------------------------------------------+
   1434          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1435          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1436          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1437          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1438          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1439          *                                             +------------+       +------------+        +------------+
   1440          *                                             |            |       |            |        |            |
   1441          *                                             +------------+       +------------+        +------------+
   1442          *                                             |            |       |            |        |            |
   1443          *                                             +------------+       +------------+        +------------+
   1444          *
   1445          *
   1446          * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_PEND_DATA entry will be inserted
   1447          *              -----------
   1448          *
   1449          *              p_pend_data    is the OS_PEND_DATA to insert in the list
   1450          *              -----------
   1451          *
   1452          * Returns    : none
   1453          *
   1454          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1455          *
   1456          *              2) 'p_pend_data->TCBPtr->Prio' contains the priority of the TCB associated with the entry to insert.
   1457          *                 We can compare this priority with the priority of other entries in the list.
   1458          ************************************************************************************************************************
   1459          */
   1460          

   \                                 In section .text, align 2, keep-with-next
   1461          void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
   1462                                       OS_PEND_DATA  *p_pend_data)
   1463          {
   \                     OS_PendListInsertPrio: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1464              OS_PRIO        prio;
   1465              OS_TCB        *p_tcb;
   1466              OS_TCB        *p_tcb_next;
   1467              OS_PEND_DATA  *p_pend_data_prev;
   1468              OS_PEND_DATA  *p_pend_data_next;
   1469          
   1470          
   1471          
   1472              p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
   \   00000002   0x688F             LDR      R7,[R1, #+8]
   \   00000004   0x003B             MOVS     R3,R7
   1473              prio  = p_tcb->Prio;
   \   00000006   0xF893 0x7037      LDRB     R7,[R3, #+55]
   \   0000000A   0x003A             MOVS     R2,R7
   1474              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
   \   0000000C   0x8907             LDRH     R7,[R0, #+8]
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD108             BNE.N    ??OS_PendListInsertPrio_0
   1475                  p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
   \   00000012   0x2701             MOVS     R7,#+1
   \   00000014   0x8107             STRH     R7,[R0, #+8]
   1476                  p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0x604F             STR      R7,[R1, #+4]
   1477                  p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
   \   0000001A   0x2700             MOVS     R7,#+0
   \   0000001C   0x600F             STR      R7,[R1, #+0]
   1478                  p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   1479                  p_pend_list->TailPtr    = p_pend_data;
   \   00000020   0x6041             STR      R1,[R0, #+4]
   \   00000022   0xE028             B.N      ??OS_PendListInsertPrio_1
   1480              } else {
   1481                  p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
   \                     ??OS_PendListInsertPrio_0: (+1)
   \   00000024   0x8907             LDRH     R7,[R0, #+8]
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \   00000028   0x8107             STRH     R7,[R0, #+8]
   1482                  p_pend_data_next = p_pend_list->HeadPtr;
   \   0000002A   0x6807             LDR      R7,[R0, #+0]
   \   0000002C   0x003E             MOVS     R6,R7
   1483                  while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
   \                     ??OS_PendListInsertPrio_2: (+1)
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD008             BEQ.N    ??OS_PendListInsertPrio_3
   1484                      p_tcb_next   = p_pend_data_next->TCBPtr;
   \   00000032   0x68B7             LDR      R7,[R6, #+8]
   \   00000034   0x003C             MOVS     R4,R7
   1485                      if (prio < p_tcb_next->Prio) {
   \   00000036   0xF894 0x7037      LDRB     R7,[R4, #+55]
   \   0000003A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003C   0x42BA             CMP      R2,R7
   \   0000003E   0xD301             BCC.N    ??OS_PendListInsertPrio_3
   1486                          break;                                                /*         Found! ... insert BEFORE current     */
   1487                      } else {
   1488                          p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
   \                     ??OS_PendListInsertPrio_4: (+1)
   \   00000040   0x6876             LDR      R6,[R6, #+4]
   \   00000042   0xE7F4             B.N      ??OS_PendListInsertPrio_2
   1489                      }
   1490                  }
   1491                  if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
   \                     ??OS_PendListInsertPrio_3: (+1)
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD107             BNE.N    ??OS_PendListInsertPrio_5
   1492                      p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
   \   00000048   0x2700             MOVS     R7,#+0
   \   0000004A   0x604F             STR      R7,[R1, #+4]
   1493                      p_pend_data_prev          = p_pend_list->TailPtr;
   \   0000004C   0x6847             LDR      R7,[R0, #+4]
   \   0000004E   0x003D             MOVS     R5,R7
   1494                      p_pend_data->PrevPtr      = p_pend_data_prev;
   \   00000050   0x600D             STR      R5,[R1, #+0]
   1495                      p_pend_data_prev->NextPtr = p_pend_data;
   \   00000052   0x6069             STR      R1,[R5, #+4]
   1496                      p_pend_list->TailPtr      = p_pend_data;
   \   00000054   0x6041             STR      R1,[R0, #+4]
   \   00000056   0xE00E             B.N      ??OS_PendListInsertPrio_1
   1497                  } else {
   1498                      if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
   \                     ??OS_PendListInsertPrio_5: (+1)
   \   00000058   0x6837             LDR      R7,[R6, #+0]
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD105             BNE.N    ??OS_PendListInsertPrio_6
   1499                          p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
   \   0000005E   0x6031             STR      R1,[R6, #+0]
   1500                          p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
   \   00000060   0x2700             MOVS     R7,#+0
   \   00000062   0x600F             STR      R7,[R1, #+0]
   1501                          p_pend_data->NextPtr       = p_pend_data_next;
   \   00000064   0x604E             STR      R6,[R1, #+4]
   1502                          p_pend_list->HeadPtr       = p_pend_data;
   \   00000066   0x6001             STR      R1,[R0, #+0]
   \   00000068   0xE005             B.N      ??OS_PendListInsertPrio_1
   1503                      } else {
   1504                          p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
   \                     ??OS_PendListInsertPrio_6: (+1)
   \   0000006A   0x6837             LDR      R7,[R6, #+0]
   \   0000006C   0x003D             MOVS     R5,R7
   1505                          p_pend_data->PrevPtr       = p_pend_data_prev;
   \   0000006E   0x600D             STR      R5,[R1, #+0]
   1506                          p_pend_data->NextPtr       = p_pend_data_next;
   \   00000070   0x604E             STR      R6,[R1, #+4]
   1507                          p_pend_data_prev->NextPtr  = p_pend_data;
   \   00000072   0x6069             STR      R1,[R5, #+4]
   1508                          p_pend_data_next->PrevPtr  = p_pend_data;
   \   00000074   0x6031             STR      R1,[R6, #+0]
   1509                      }
   1510                  }
   1511              }
   1512          }
   \                     ??OS_PendListInsertPrio_1: (+1)
   \   00000076   0xBCF0             POP      {R4-R7}
   \   00000078   0x4770             BX       LR               ;; return
   1513          
   1514          /*$PAGE*/
   1515          /*
   1516          ************************************************************************************************************************
   1517          *                           REMOVE TASK FROM PEND LIST(s) KNOWING ONLY WHICH TCB TO REMOVE
   1518          *
   1519          * Description: This function is called to remove a task from a pend list knowing only the TCB of the task to remove
   1520          *
   1521          *
   1522          *              CASE 0: OS_PEND_DATA list is empty, nothing to do.
   1523          *
   1524          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1525          *
   1526          *                     OS_PEND_LIST
   1527          *                     +--------------+         OS_PEND_DATA
   1528          *                     | TailPtr      |--+---> +------------+
   1529          *                     +--------------+  |     | NextPtr    |->0
   1530          *                     | HeadPtr      |--/     +------------+
   1531          *                     +--------------+     0<-| PrevPtr    |
   1532          *                     | NbrEntries=1 |        +------------+
   1533          *                     +--------------+        |            |
   1534          *                                             +------------+
   1535          *                                             |            |
   1536          *                                             +------------+
   1537          *
   1538          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1539          *
   1540          *                     OS_PEND_LIST
   1541          *                     +--------------+
   1542          *                     | TailPtr      |-----------------------------------------------+
   1543          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1544          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1545          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1546          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1547          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1548          *                                             +------------+       +------------+        +------------+
   1549          *                                             |            |       |            |        |            |
   1550          *                                             +------------+       +------------+        +------------+
   1551          *                                             |            |       |            |        |            |
   1552          *                                             +------------+       +------------+        +------------+
   1553          *
   1554          *
   1555          * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from all pend lists
   1556          *              -----
   1557          *
   1558          * Returns    : none
   1559          *
   1560          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1561          ************************************************************************************************************************
   1562          */
   1563          

   \                                 In section .text, align 2, keep-with-next
   1564          void  OS_PendListRemove (OS_TCB  *p_tcb)
   1565          {
   \                     OS_PendListRemove: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1566              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1567              OS_PEND_DATA   *p_pend_data;
   1568              OS_PEND_LIST   *p_pend_list;
   1569              OS_PEND_OBJ    *p_obj;
   1570          
   1571          
   1572          
   1573              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000006   0x6B20             LDR      R0,[R4, #+48]
   \   00000008   0x0006             MOVS     R6,R0
   1574              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   0000000A   0x8FE0             LDRH     R0,[R4, #+62]
   \   0000000C   0x0005             MOVS     R5,R0
   1575          
   1576              while (n_pend_list > (OS_OBJ_QTY)0) {
   \                     ??OS_PendListRemove_0: (+1)
   \   0000000E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD00B             BEQ.N    ??OS_PendListRemove_1
   1577                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   \   00000014   0x68F0             LDR      R0,[R6, #+12]
   \   00000016   0x4680             MOV      R8,R0
   1578                  p_pend_list = &p_obj->PendList;
   \   00000018   0xF118 0x0008      ADDS     R0,R8,#+8
   \   0000001C   0x0007             MOVS     R7,R0
   1579                  OS_PendListRemove1(p_pend_list,
   1580                                     p_pend_data);
   \   0000001E   0x0031             MOVS     R1,R6
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       OS_PendListRemove1
   1581                  p_pend_data++;
   \   00000026   0x3620             ADDS     R6,R6,#+32
   1582                  n_pend_list--;
   \   00000028   0x1E6D             SUBS     R5,R5,#+1
   \   0000002A   0xE7F0             B.N      ??OS_PendListRemove_0
   1583              }
   1584              p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
   \                     ??OS_PendListRemove_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x87E0             STRH     R0,[R4, #+62]
   1585              p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6320             STR      R0,[R4, #+48]
   1586          }
   \   00000034   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1587          
   1588          /*$PAGE*/
   1589          /*
   1590          ************************************************************************************************************************
   1591          *                               REMOVE AN 'OS_PEND_DATA' ENTRY from a 'OS_PEND_LIST'
   1592          *
   1593          * Description: This function is called to remove a task from a wait list knowing only the TCB of the task to remove
   1594          *
   1595          *
   1596          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1597          *
   1598          *                     OS_PEND_LIST
   1599          *                     +--------------+         OS_PEND_DATA
   1600          *                     | TailPtr      |--+---> +------------+
   1601          *                     +--------------+  |     | NextPtr    |->0
   1602          *                     | HeadPtr      |--/      +------------+
   1603          *                     +--------------+     0<-| PrevPtr    |
   1604          *                     | NbrEntries=1 |        +------------+
   1605          *                     +--------------+        |            |
   1606          *                                             +------------+
   1607          *                                             |            |
   1608          *                                             +------------+
   1609          *
   1610          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1611          *
   1612          *                     OS_PEND_LIST
   1613          *                     +--------------+
   1614          *                     | TailPtr      |-----------------------------------------------+
   1615          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1616          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1617          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1618          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1619          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1620          *                                             +------------+       +------------+        +------------+
   1621          *                                             |            |       |            |        |            |
   1622          *                                             +------------+       +------------+        +------------+
   1623          *                                             |            |       |            |        |            |
   1624          *                                             +------------+       +------------+        +------------+
   1625          *
   1626          *
   1627          * Arguments  : p_pend_list     is a pointer to the pend list where 'p_pend_data' will be removed from
   1628          *              -----------
   1629          *
   1630          *              p_pend_data     is a pointer to the OS_PEND_DATA to remove from the pend list
   1631          *              -----------
   1632          *
   1633          * Returns    : none
   1634          *
   1635          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1636          ************************************************************************************************************************
   1637          */
   1638          

   \                                 In section .text, align 2, keep-with-next
   1639          void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
   1640                                    OS_PEND_DATA  *p_pend_data)
   1641          {
   \                     OS_PendListRemove1: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1642              OS_PEND_DATA  *p_prev;
   1643              OS_PEND_DATA  *p_next;
   1644          
   1645          
   1646          
   1647              if (p_pend_list->NbrEntries == 1u) {
   \   00000002   0x8904             LDRH     R4,[R0, #+8]
   \   00000004   0x2C01             CMP      R4,#+1
   \   00000006   0xD104             BNE.N    ??OS_PendListRemove1_0
   1648                  p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x6004             STR      R4,[R0, #+0]
   1649                  p_pend_list->TailPtr = (OS_PEND_DATA *)0;
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x6044             STR      R4,[R0, #+4]
   \   00000010   0xE017             B.N      ??OS_PendListRemove1_1
   1650          
   1651              } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
   \                     ??OS_PendListRemove1_0: (+1)
   \   00000012   0x680C             LDR      R4,[R1, #+0]
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD105             BNE.N    ??OS_PendListRemove1_2
   1652                  p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
   \   00000018   0x684C             LDR      R4,[R1, #+4]
   \   0000001A   0x0023             MOVS     R3,R4
   1653                  p_next->PrevPtr      = (OS_PEND_DATA *)0;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x601C             STR      R4,[R3, #+0]
   1654                  p_pend_list->HeadPtr = p_next;
   \   00000020   0x6003             STR      R3,[R0, #+0]
   \   00000022   0xE00E             B.N      ??OS_PendListRemove1_1
   1655          
   1656              } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
   \                     ??OS_PendListRemove1_2: (+1)
   \   00000024   0x684C             LDR      R4,[R1, #+4]
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD105             BNE.N    ??OS_PendListRemove1_3
   1657                  p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
   \   0000002A   0x680C             LDR      R4,[R1, #+0]
   \   0000002C   0x0022             MOVS     R2,R4
   1658                  p_prev->NextPtr      = (OS_PEND_DATA *)0;
   \   0000002E   0x2400             MOVS     R4,#+0
   \   00000030   0x6054             STR      R4,[R2, #+4]
   1659                  p_pend_list->TailPtr = p_prev;
   \   00000032   0x6042             STR      R2,[R0, #+4]
   \   00000034   0xE005             B.N      ??OS_PendListRemove1_1
   1660          
   1661              } else {
   1662                  p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
   \                     ??OS_PendListRemove1_3: (+1)
   \   00000036   0x680C             LDR      R4,[R1, #+0]
   \   00000038   0x0022             MOVS     R2,R4
   1663                  p_next               = p_pend_data->NextPtr;
   \   0000003A   0x684C             LDR      R4,[R1, #+4]
   \   0000003C   0x0023             MOVS     R3,R4
   1664                  p_prev->NextPtr      = p_next;
   \   0000003E   0x6053             STR      R3,[R2, #+4]
   1665                  p_next->PrevPtr      = p_prev;
   \   00000040   0x601A             STR      R2,[R3, #+0]
   1666              }
   1667              p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
   \                     ??OS_PendListRemove1_1: (+1)
   \   00000042   0x8904             LDRH     R4,[R0, #+8]
   \   00000044   0x1E64             SUBS     R4,R4,#+1
   \   00000046   0x8104             STRH     R4,[R0, #+8]
   1668              p_pend_data->NextPtr = (OS_PEND_DATA *)0;
   \   00000048   0x2400             MOVS     R4,#+0
   \   0000004A   0x604C             STR      R4,[R1, #+4]
   1669              p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
   \   0000004C   0x2400             MOVS     R4,#+0
   \   0000004E   0x600C             STR      R4,[R1, #+0]
   1670          }
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
   1671          
   1672          /*$PAGE*/
   1673          /*
   1674          ************************************************************************************************************************
   1675          *                                READY A TASK THAT WAS PENDING ON AN OBJECT BEING DELETED
   1676          *
   1677          * Description: This function is called to make a task ready-to-run because an object is being deleted
   1678          *
   1679          * Arguments  : p_obj          is a pointer to the object being deleted
   1680          *              -----
   1681          *
   1682          *              p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   1683          *              -----
   1684          *
   1685          *              ts             is a timestamp to indicate when the object was deleted
   1686          *
   1687          * Returns    : none
   1688          *
   1689          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1690          ************************************************************************************************************************
   1691          */
   1692          

   \                                 In section .text, align 2, keep-with-next
   1693          void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
   1694                               OS_TCB       *p_tcb,
   1695                               CPU_TS        ts)
   1696          {
   \                     OS_PendObjDel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1697              switch (p_tcb->TaskState) {
   \   00000008   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00B             BEQ.N    ??OS_PendObjDel_0
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD00A             BEQ.N    ??OS_PendObjDel_1
   \   00000014   0xD308             BCC.N    ??OS_PendObjDel_0
   \   00000016   0x2804             CMP      R0,#+4
   \   00000018   0xD006             BEQ.N    ??OS_PendObjDel_0
   \   0000001A   0xD306             BCC.N    ??OS_PendObjDel_1
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xD023             BEQ.N    ??OS_PendObjDel_2
   \   00000020   0xD302             BCC.N    ??OS_PendObjDel_0
   \   00000022   0x2807             CMP      R0,#+7
   \   00000024   0xD020             BEQ.N    ??OS_PendObjDel_2
   \   00000026   0xE03E             B.N      ??OS_PendObjDel_3
   1698                  case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
   1699                  case OS_TASK_STATE_DLY:
   1700                  case OS_TASK_STATE_SUSPENDED:
   1701                  case OS_TASK_STATE_DLY_SUSPENDED:
   1702                       break;
   \                     ??OS_PendObjDel_0: (+1)
   \   00000028   0xE03D             B.N      ??OS_PendObjDel_4
   1703          
   1704                  case OS_TASK_STATE_PEND:
   1705                  case OS_TASK_STATE_PEND_TIMEOUT:
   1706                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendObjDel_1: (+1)
   \   0000002A   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD104             BNE.N    ??OS_PendObjDel_5
   1707                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1708                                          p_tcb,
   1709                                          ts);
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_PendObjDel1
   1710                       }
   1711          #if (OS_MSG_EN > 0u)
   1712                       p_tcb->MsgPtr     = (void *)0;
   \                     ??OS_PendObjDel_5: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x65E8             STR      R0,[R5, #+92]
   1713                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF8A5 0x0060      STRH     R0,[R5, #+96]
   1714          #endif
   1715                       p_tcb->TS         = ts;
   \   00000046   0x642E             STR      R6,[R5, #+64]
   1716                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       OS_PendListRemove
   1717                       OS_TaskRdy(p_tcb);
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       OS_TaskRdy
   1718                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF885 0x0036      STRB     R0,[R5, #+54]
   1719                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0xF885 0x0035      STRB     R0,[R5, #+53]
   1720                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF885 0x0034      STRB     R0,[R5, #+52]
   1721                       break;
   \   00000066   0xE01E             B.N      ??OS_PendObjDel_4
   1722          
   1723                  case OS_TASK_STATE_PEND_SUSPENDED:
   1724                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1725                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_PendObjDel_2: (+1)
   \   00000068   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000006C   0x2803             CMP      R0,#+3
   \   0000006E   0xD104             BNE.N    ??OS_PendObjDel_6
   1726                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1727                                          p_tcb,
   1728                                          ts);
   \   00000070   0x0032             MOVS     R2,R6
   \   00000072   0x0029             MOVS     R1,R5
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       OS_PendObjDel1
   1729                       }
   1730          #if (OS_MSG_EN > 0u)
   1731                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_PendObjDel_6: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x65E8             STR      R0,[R5, #+92]
   1732                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF8A5 0x0060      STRH     R0,[R5, #+96]
   1733          #endif
   1734                       p_tcb->TS         = ts;
   \   00000084   0x642E             STR      R6,[R5, #+64]
   1735                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       OS_TickListRemove
   1736                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0x.... 0x....      BL       OS_PendListRemove
   1737                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
   \   00000092   0x2004             MOVS     R0,#+4
   \   00000094   0xF885 0x0036      STRB     R0,[R5, #+54]
   1738                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xF885 0x0035      STRB     R0,[R5, #+53]
   1739                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF885 0x0034      STRB     R0,[R5, #+52]
   1740                       break;
   \   000000A4   0xE7FF             B.N      ??OS_PendObjDel_4
   1741          
   1742                  default:
   1743                       break;
   1744              }
   1745          }
   \                     ??OS_PendObjDel_3: (+1)
   \                     ??OS_PendObjDel_4: (+1)
   \   000000A6   0xBD70             POP      {R4-R6,PC}       ;; return
   1746          
   1747          /*$PAGE*/
   1748          /*
   1749          ************************************************************************************************************************
   1750          *                                    DELETE AN OBJECT FROM A TASK PENDING ON MULTIPLE OBJECTS
   1751          *
   1752          * Description: This function is called when a task is pending on multiple objects and the object is being deleted.
   1753          *              This function needs to indicate to the caller which object was deleted by placing the address of the
   1754          *              object in the OS_PEND_DATA table corresponding to the deleted object.
   1755          *
   1756          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1757          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1758          *              set to six (6) in this case.  As shown, when the pend call returns because a task deleted 'Obj C' then,
   1759          *              only the one entry contains the filled in data and the other entries contains NULL pointers and zero
   1760          *              data.
   1761          *
   1762          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1763          *
   1764          *
   1765          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1766          *                                         +--------------+--------------+--------------+--------------+--------------+
   1767          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1768          *                                         +--------------+--------------+--------------+--------------+--------------+
   1769          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1770          *                                         +--------------+--------------+--------------+--------------+--------------+
   1771          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
   1772          *                                         +--------------+--------------+--------------+--------------+--------------+
   1773          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1774          *                                         +--------------+--------------+--------------+--------------+--------------+
   1775          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1776          *                                         +--------------+--------------+--------------+--------------+--------------+
   1777          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1778          *                                         +--------------+--------------+--------------+--------------+--------------+
   1779          *
   1780          *
   1781          * Arguments  : p_obj        is a pointer to the object being deleted
   1782          *              -----
   1783          *
   1784          *              p_tcb        is the OS_TCB of the task pending on the object being deleted
   1785          *              -----
   1786          *
   1787          *              ts           is the time stamp of when the object was deleted
   1788          *
   1789          * Returns    : none
   1790          *
   1791          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1792          ************************************************************************************************************************
   1793          */
   1794          

   \                                 In section .text, align 2, keep-with-next
   1795          void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
   1796                                OS_TCB       *p_tcb,
   1797                                CPU_TS        ts)
   1798          {
   \                     OS_PendObjDel1: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1799              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1800              OS_PEND_DATA   *p_pend_data;
   1801          
   1802          
   1803          
   1804              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000002   0x6B0D             LDR      R5,[R1, #+48]
   \   00000004   0x002C             MOVS     R4,R5
   1805              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000006   0x8FCD             LDRH     R5,[R1, #+62]
   \   00000008   0x002B             MOVS     R3,R5
   1806          
   1807              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   \                     ??OS_PendObjDel1_0: (+1)
   \   0000000A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD008             BEQ.N    ??OS_PendObjDel1_1
   1808                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
   \   00000010   0x68E5             LDR      R5,[R4, #+12]
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xD102             BNE.N    ??OS_PendObjDel1_2
   1809                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   \   00000016   0x6120             STR      R0,[R4, #+16]
   1810                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
   \   00000018   0x61E2             STR      R2,[R4, #+28]
   1811                      break;
   \   0000001A   0xE002             B.N      ??OS_PendObjDel1_1
   1812                  }
   1813                  p_pend_data++;
   \                     ??OS_PendObjDel1_2: (+1)
   \   0000001C   0x3420             ADDS     R4,R4,#+32
   1814                  n_pend_list--;
   \   0000001E   0x1E5B             SUBS     R3,R3,#+1
   \   00000020   0xE7F3             B.N      ??OS_PendObjDel1_0
   1815              }
   1816          }
   \                     ??OS_PendObjDel1_1: (+1)
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
   1817          
   1818          /*$PAGE*/
   1819          /*
   1820          ************************************************************************************************************************
   1821          *                                                   POST TO A TASK
   1822          *
   1823          * Description: This function is called to post to a task.  This function exist because it is common to a number of
   1824          *              OSxxxPost() services.
   1825          *
   1826          * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
   1827          *              -----
   1828          *
   1829          *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
   1830          *              -----
   1831          *
   1832          *              p_void         If we are posting a message to a task, this is the message that the task will receive
   1833          *
   1834          *              msg_size       If we are posting a message to a task, this is the size of the message
   1835          *
   1836          *              ts             The timestamp as to when the post occurred
   1837          *
   1838          * Returns    : none
   1839          *
   1840          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1841          ************************************************************************************************************************
   1842          */
   1843          

   \                                 In section .text, align 2, keep-with-next
   1844          void  OS_Post (OS_PEND_OBJ  *p_obj,
   1845                         OS_TCB       *p_tcb,
   1846                         void         *p_void,
   1847                         OS_MSG_SIZE   msg_size,
   1848                         CPU_TS        ts)
   1849          {
   \                     OS_Post: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   1850              switch (p_tcb->TaskState) {
   \   00000012   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD00B             BEQ.N    ??OS_Post_0
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD00A             BEQ.N    ??OS_Post_1
   \   0000001E   0xD308             BCC.N    ??OS_Post_0
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xD006             BEQ.N    ??OS_Post_0
   \   00000024   0xD306             BCC.N    ??OS_Post_1
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xD02D             BEQ.N    ??OS_Post_2
   \   0000002A   0xD302             BCC.N    ??OS_Post_0
   \   0000002C   0x2807             CMP      R0,#+7
   \   0000002E   0xD02A             BEQ.N    ??OS_Post_2
   \   00000030   0xE052             B.N      ??OS_Post_3
   1851                  case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
   1852                  case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
   1853                  case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
   1854                  case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
   1855                       break;
   \                     ??OS_Post_0: (+1)
   \   00000032   0xE051             B.N      ??OS_Post_4
   1856          
   1857                  case OS_TASK_STATE_PEND:
   1858                  case OS_TASK_STATE_PEND_TIMEOUT:
   1859                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_Post_1: (+1)
   \   00000034   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD109             BNE.N    ??OS_Post_5
   1860                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1861                                    p_tcb,
   1862                                    p_void,
   1863                                    msg_size,
   1864                                    ts);
   \   0000003C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000040   0x003B             MOVS     R3,R7
   \   00000042   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000044   0x0032             MOVS     R2,R6
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       OS_Post1
   \   0000004E   0xE004             B.N      ??OS_Post_6
   1865                       } else {
   1866          #if (OS_MSG_EN > 0u)
   1867                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   \                     ??OS_Post_5: (+1)
   \   00000050   0x65EE             STR      R6,[R5, #+92]
   1868                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   \   00000052   0xF8A5 0x7060      STRH     R7,[R5, #+96]
   1869          #endif
   1870                           p_tcb->TS      = ts;
   \   00000056   0xF8C5 0x8040      STR      R8,[R5, #+64]
   1871                       }
   1872                       if (p_obj != (OS_PEND_OBJ *)0) {
   \                     ??OS_Post_6: (+1)
   \   0000005A   0x2C00             CMP      R4,#+0
   \   0000005C   0xD006             BEQ.N    ??OS_Post_7
   1873                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       OS_PendListRemove
   1874          #if OS_CFG_DBG_EN > 0u
   1875                           OS_PendDbgNameRemove(p_obj,
   1876                                                p_tcb);
   \   00000064   0x0029             MOVS     R1,R5
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       OS_PendDbgNameRemove
   1877          #endif
   1878                       }
   1879                       OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
   \                     ??OS_Post_7: (+1)
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0x.... 0x....      BL       OS_TaskRdy
   1880                       p_tcb->TaskState  = OS_TASK_STATE_RDY;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF885 0x0036      STRB     R0,[R5, #+54]
   1881                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF885 0x0035      STRB     R0,[R5, #+53]
   1882                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF885 0x0034      STRB     R0,[R5, #+52]
   1883                       break;
   \   00000084   0xE028             B.N      ??OS_Post_4
   1884          
   1885                  case OS_TASK_STATE_PEND_SUSPENDED:
   1886                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1887                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_Post_2: (+1)
   \   00000086   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000008A   0x2803             CMP      R0,#+3
   \   0000008C   0xD109             BNE.N    ??OS_Post_8
   1888                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1889                                    p_tcb,
   1890                                    p_void,
   1891                                    msg_size,
   1892                                    ts);
   \   0000008E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000092   0x003B             MOVS     R3,R7
   \   00000094   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000096   0x0032             MOVS     R2,R6
   \   00000098   0x0029             MOVS     R1,R5
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       OS_Post1
   \   000000A0   0xE004             B.N      ??OS_Post_9
   1893                       } else {
   1894          #if (OS_MSG_EN > 0u)
   1895                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   \                     ??OS_Post_8: (+1)
   \   000000A2   0x65EE             STR      R6,[R5, #+92]
   1896                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   \   000000A4   0xF8A5 0x7060      STRH     R7,[R5, #+96]
   1897          #endif
   1898                           p_tcb->TS      = ts;
   \   000000A8   0xF8C5 0x8040      STR      R8,[R5, #+64]
   1899                       }
   1900                       OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
   \                     ??OS_Post_9: (+1)
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0x.... 0x....      BL       OS_TickListRemove
   1901                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   000000B2   0x2C00             CMP      R4,#+0
   \   000000B4   0xD006             BEQ.N    ??OS_Post_10
   1902                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   \   000000B6   0x0028             MOVS     R0,R5
   \   000000B8   0x.... 0x....      BL       OS_PendListRemove
   1903          #if OS_CFG_DBG_EN > 0u
   1904                           OS_PendDbgNameRemove(p_obj,
   1905                                                p_tcb);
   \   000000BC   0x0029             MOVS     R1,R5
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       OS_PendDbgNameRemove
   1906          #endif
   1907                       }
   1908                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_Post_10: (+1)
   \   000000C4   0x2004             MOVS     R0,#+4
   \   000000C6   0xF885 0x0036      STRB     R0,[R5, #+54]
   1909                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF885 0x0035      STRB     R0,[R5, #+53]
   1910                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF885 0x0034      STRB     R0,[R5, #+52]
   1911                       break;
   \   000000D6   0xE7FF             B.N      ??OS_Post_4
   1912          
   1913                  default:
   1914                       break;
   1915              }
   1916          }
   \                     ??OS_Post_3: (+1)
   \                     ??OS_Post_4: (+1)
   \   000000D8   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   1917          
   1918          /*$PAGE*/
   1919          /*
   1920          ************************************************************************************************************************
   1921          *                                           POST TO A TASK PENDING ON MULTIPLE OBJECTS
   1922          *
   1923          * Description: This function is called when a task is pending on multiple objects and the object has been posted to.
   1924          *              This function needs to indicate to the caller which object was posted to by placing the address of the
   1925          *              object in the OS_PEND_DATA table corresponding to the posted object.
   1926          *
   1927          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1928          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1929          *              set to six (6) in this case.  As shown, when the pend call returns because a task or an ISR posted to
   1930          *              'Obj C' then, only the one entry contains the filled in data and the other entries contains NULL pointers
   1931          *              and zero data.
   1932          *
   1933          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1934          *
   1935          *
   1936          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1937          *                                         +--------------+--------------+--------------+--------------+--------------+
   1938          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1939          *                                         +--------------+--------------+--------------+--------------+--------------+
   1940          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1941          *                                         +--------------+--------------+--------------+--------------+--------------+
   1942          *                                         |  Obj C       |  Obj C       | Msg Ptr      | Msg Size     | TS           |
   1943          *                                         +--------------+--------------+--------------+--------------+--------------+
   1944          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1945          *                                         +--------------+--------------+--------------+--------------+--------------+
   1946          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1947          *                                         +--------------+--------------+--------------+--------------+--------------+
   1948          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1949          *                                         +--------------+--------------+--------------+--------------+--------------+
   1950          *
   1951          *
   1952          * Arguments  : p_obj        is a pointer to the object being posted to
   1953          *              -----
   1954          *
   1955          *              p_tcb        is the OS_TCB of the task receiving the signal or the message
   1956          *              -----
   1957          *
   1958          *              p_void       is the actual message (assuming posting to a message queue).  A NULL pointer otherwise.
   1959          *
   1960          *              msg_size     is the size of the message sent (if posted to a message queue)
   1961          *
   1962          *              ts           is the time stamp of when the post occurred
   1963          *
   1964          * Returns    : none
   1965          *
   1966          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1967          ************************************************************************************************************************
   1968          */
   1969          

   \                                 In section .text, align 2, keep-with-next
   1970          void  OS_Post1 (OS_PEND_OBJ  *p_obj,
   1971                          OS_TCB       *p_tcb,
   1972                          void         *p_void,
   1973                          OS_MSG_SIZE   msg_size,
   1974                          CPU_TS        ts)
   1975          {
   \                     OS_Post1: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
   1976              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1977              OS_PEND_DATA   *p_pend_data;
   1978          
   1979          
   1980          
   1981              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   00000004   0x6B0F             LDR      R7,[R1, #+48]
   \   00000006   0x003E             MOVS     R6,R7
   1982              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   00000008   0x8FCF             LDRH     R7,[R1, #+62]
   \   0000000A   0x003D             MOVS     R5,R7
   1983          
   1984              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   \                     ??OS_Post1_0: (+1)
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD00A             BEQ.N    ??OS_Post1_1
   1985                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
   \   00000012   0x68F7             LDR      R7,[R6, #+12]
   \   00000014   0x42B8             CMP      R0,R7
   \   00000016   0xD104             BNE.N    ??OS_Post1_2
   1986                      p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
   \   00000018   0x6130             STR      R0,[R6, #+16]
   1987                      p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
   \   0000001A   0x6172             STR      R2,[R6, #+20]
   1988                      p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
   \   0000001C   0x8333             STRH     R3,[R6, #+24]
   1989                      p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
   \   0000001E   0x61F4             STR      R4,[R6, #+28]
   1990                      break;
   \   00000020   0xE002             B.N      ??OS_Post1_1
   1991                  }
   1992                  p_pend_data++;
   \                     ??OS_Post1_2: (+1)
   \   00000022   0x3620             ADDS     R6,R6,#+32
   1993                  n_pend_list--;
   \   00000024   0x1E6D             SUBS     R5,R5,#+1
   \   00000026   0xE7F1             B.N      ??OS_Post1_0
   1994              }
   1995          }
   \                     ??OS_Post1_1: (+1)
   \   00000028   0xBCF0             POP      {R4-R7}
   \   0000002A   0x4770             BX       LR               ;; return
   1996          
   1997          /*$PAGE*/
   1998          /*
   1999          ************************************************************************************************************************
   2000          *                                                    INITIALIZATION
   2001          *                                               READY LIST INITIALIZATION
   2002          *
   2003          * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
   2004          *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
   2005          *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
   2006          *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   2007          *
   2008          *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
   2009          *              to.
   2010          *
   2011          *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   2012          *
   2013          *                               +---------------+--------------+
   2014          *                               |               | TailPtr      |-----> 0
   2015          *                          [0]  | NbrEntries=0  +--------------+
   2016          *                               |               | HeadPtr      |-----> 0
   2017          *                               +---------------+--------------+
   2018          *                               |               | TailPtr      |-----> 0
   2019          *                          [1]  | NbrEntries=0  +--------------+
   2020          *                               |               | HeadPtr      |-----> 0
   2021          *                               +---------------+--------------+
   2022          *                                       :              :
   2023          *                                       :              :
   2024          *                                       :              :
   2025          *                               +---------------+--------------+
   2026          *                               |               | TailPtr      |-----> 0
   2027          *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   2028          *                               |               | HeadPtr      |-----> 0
   2029          *                               +---------------+--------------+
   2030          *
   2031          *
   2032          * Arguments  : none
   2033          *
   2034          * Returns    : none
   2035          *
   2036          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2037          ************************************************************************************************************************
   2038          */
   2039          

   \                                 In section .text, align 2, keep-with-next
   2040          void  OS_RdyListInit (void)
   2041          {
   2042              OS_PRIO       i;
   2043              OS_RDY_LIST  *p_rdy_list;
   2044          
   2045          
   2046          
   2047              for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
   \                     OS_RdyListInit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x0010             MOVS     R0,R2
   \                     ??OS_RdyListInit_0: (+1)
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2820             CMP      R0,#+32
   \   00000008   0xD20D             BCS.N    ??OS_RdyListInit_1
   2048                  p_rdy_list = &OSRdyList[i];
   \   0000000A   0x....             LDR.N    R2,??DataTable21_1
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x230C             MOVS     R3,#+12
   \   00000010   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000014   0x0011             MOVS     R1,R2
   2049                  p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x810A             STRH     R2,[R1, #+8]
   2050                  p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x600A             STR      R2,[R1, #+0]
   2051                  p_rdy_list->TailPtr    = (OS_TCB   *)0;
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x604A             STR      R2,[R1, #+4]
   2052              }
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xE7EE             B.N      ??OS_RdyListInit_0
   2053          }
   \                     ??OS_RdyListInit_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
   2054          
   2055          /*$PAGE*/
   2056          /*
   2057          ************************************************************************************************************************
   2058          *                                             INSERT TCB IN THE READY LIST
   2059          *
   2060          * Description: This function is called to insert a TCB in the ready list.
   2061          *
   2062          *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
   2063          *              current task.  The TCB is inserted at the head of the list if not.
   2064          *
   2065          * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
   2066          *              -----
   2067          *
   2068          * Returns    : none
   2069          *
   2070          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2071          ************************************************************************************************************************
   2072          */
   2073          

   \                                 In section .text, align 2, keep-with-next
   2074          void  OS_RdyListInsert (OS_TCB  *p_tcb)
   2075          {
   \                     OS_RdyListInsert: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2076              OS_PrioInsert(p_tcb->Prio);
   \   00000004   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000008   0x.... 0x....      BL       OS_PrioInsert
   2077              if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
   \   0000000C   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000010   0x....             LDR.N    R1,??DataTable16_1
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD103             BNE.N    ??OS_RdyListInsert_0
   2078                  OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       OS_RdyListInsertTail
   \   0000001E   0xE002             B.N      ??OS_RdyListInsert_1
   2079              } else {
   2080                  OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
   \                     ??OS_RdyListInsert_0: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       OS_RdyListInsertHead
   2081              }
   2082          }
   \                     ??OS_RdyListInsert_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   2083          
   2084          
   2085          /*
   2086          ************************************************************************************************************************
   2087          *                                          INSERT TCB AT THE BEGINNING OF A LIST
   2088          *
   2089          * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
   2090          *
   2091          *              CASE 0: Insert in an empty list.
   2092          *
   2093          *                     OS_RDY_LIST
   2094          *                     +--------------+
   2095          *                     | TailPtr      |-> 0
   2096          *                     +--------------+
   2097          *                     | HeadPtr      |-> 0
   2098          *                     +--------------+
   2099          *                     | NbrEntries=0 |
   2100          *                     +--------------+
   2101          *
   2102          *
   2103          *
   2104          *              CASE 1: Insert BEFORE the current head of list
   2105          *
   2106          *                     OS_RDY_LIST
   2107          *                     +--------------+          OS_TCB
   2108          *                     | TailPtr      |--+---> +------------+
   2109          *                     +--------------+  |     | NextPtr    |->0
   2110          *                     | HeadPtr      |--/     +------------+
   2111          *                     +--------------+     0<-| PrevPtr    |
   2112          *                     | NbrEntries=1 |        +------------+
   2113          *                     +--------------+        :            :
   2114          *                                             :            :
   2115          *                                             +------------+
   2116          *
   2117          *
   2118          *                     OS_RDY_LIST
   2119          *                     +--------------+
   2120          *                     | TailPtr      |-----------------------------------------------+
   2121          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2122          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2123          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2124          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2125          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2126          *                                             +------------+       +------------+        +------------+
   2127          *                                             :            :       :            :        :            :
   2128          *                                             :            :       :            :        :            :
   2129          *                                             +------------+       +------------+        +------------+
   2130          *
   2131          *
   2132          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2133          *              -----
   2134          *
   2135          * Returns    : none
   2136          *
   2137          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2138          ************************************************************************************************************************
   2139          */
   2140          

   \                                 In section .text, align 2, keep-with-next
   2141          void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
   2142          {
   \                     OS_RdyListInsertHead: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2143              OS_RDY_LIST  *p_rdy_list;
   2144              OS_TCB       *p_tcb2;
   2145          
   2146          
   2147          
   2148              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \   00000002   0x....             LDR.N    R3,??DataTable21_1
   \   00000004   0xF890 0x4037      LDRB     R4,[R0, #+55]
   \   00000008   0x250C             MOVS     R5,#+12
   \   0000000A   0xFB05 0x3304      MLA      R3,R5,R4,R3
   \   0000000E   0x0019             MOVS     R1,R3
   2149              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   \   00000010   0x890B             LDRH     R3,[R1, #+8]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD108             BNE.N    ??OS_RdyListInsertHead_0
   2150                  p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x810B             STRH     R3,[R1, #+8]
   2151                  p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x60C3             STR      R3,[R0, #+12]
   2152                  p_tcb->PrevPtr         =  (OS_TCB   *)0;
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6103             STR      R3,[R0, #+16]
   2153                  p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   \   00000022   0x6008             STR      R0,[R1, #+0]
   2154                  p_rdy_list->TailPtr    =  p_tcb;
   \   00000024   0x6048             STR      R0,[R1, #+4]
   \   00000026   0xE00A             B.N      ??OS_RdyListInsertHead_1
   2155              } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
   2156                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   \                     ??OS_RdyListInsertHead_0: (+1)
   \   00000028   0x890B             LDRH     R3,[R1, #+8]
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \   0000002C   0x810B             STRH     R3,[R1, #+8]
   2157                  p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
   \   0000002E   0x680B             LDR      R3,[R1, #+0]
   \   00000030   0x60C3             STR      R3,[R0, #+12]
   2158                  p_tcb->PrevPtr         = (OS_TCB    *)0;
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x6103             STR      R3,[R0, #+16]
   2159                  p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
   \   00000036   0x680B             LDR      R3,[R1, #+0]
   \   00000038   0x001A             MOVS     R2,R3
   2160                  p_tcb2->PrevPtr        = p_tcb;
   \   0000003A   0x6110             STR      R0,[R2, #+16]
   2161                  p_rdy_list->HeadPtr    = p_tcb;
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   2162              }
   2163          }
   \                     ??OS_RdyListInsertHead_1: (+1)
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
   2164          
   2165          /*$PAGE*/
   2166          /*
   2167          ************************************************************************************************************************
   2168          *                                           INSERT TCB AT THE END OF A LIST
   2169          *
   2170          * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
   2171          *
   2172          *              CASE 0: Insert in an empty list.
   2173          *
   2174          *                     OS_RDY_LIST
   2175          *                     +--------------+
   2176          *                     | TailPtr      |-> 0
   2177          *                     +--------------+
   2178          *                     | HeadPtr      |-> 0
   2179          *                     +--------------+
   2180          *                     | NbrEntries=0 |
   2181          *                     +--------------+
   2182          *
   2183          *
   2184          *
   2185          *              CASE 1: Insert AFTER the current tail of list
   2186          *
   2187          *                     OS_RDY_LIST
   2188          *                     +--------------+          OS_TCB
   2189          *                     | TailPtr      |--+---> +------------+
   2190          *                     +--------------+  |     | NextPtr    |->0
   2191          *                     | HeadPtr      |--/     +------------+
   2192          *                     +--------------+     0<-| PrevPtr    |
   2193          *                     | NbrEntries=1 |        +------------+
   2194          *                     +--------------+        :            :
   2195          *                                             :            :
   2196          *                                             +------------+
   2197          *
   2198          *
   2199          *                     OS_RDY_LIST
   2200          *                     +--------------+
   2201          *                     | TailPtr      |-----------------------------------------------+
   2202          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2203          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2204          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2205          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2206          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2207          *                                             +------------+       +------------+        +------------+
   2208          *                                             :            :       :            :        :            :
   2209          *                                             :            :       :            :        :            :
   2210          *                                             +------------+       +------------+        +------------+
   2211          *
   2212          *
   2213          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2214          *              -----
   2215          *
   2216          * Returns    : none
   2217          *
   2218          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2219          ************************************************************************************************************************
   2220          */
   2221          

   \                                 In section .text, align 2, keep-with-next
   2222          void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
   2223          {
   \                     OS_RdyListInsertTail: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2224              OS_RDY_LIST  *p_rdy_list;
   2225              OS_TCB       *p_tcb2;
   2226          
   2227          
   2228          
   2229              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \   00000002   0x....             LDR.N    R3,??DataTable21_1
   \   00000004   0xF890 0x4037      LDRB     R4,[R0, #+55]
   \   00000008   0x250C             MOVS     R5,#+12
   \   0000000A   0xFB05 0x3304      MLA      R3,R5,R4,R3
   \   0000000E   0x0019             MOVS     R1,R3
   2230              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   \   00000010   0x890B             LDRH     R3,[R1, #+8]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD108             BNE.N    ??OS_RdyListInsertTail_0
   2231                  p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x810B             STRH     R3,[R1, #+8]
   2232                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x60C3             STR      R3,[R0, #+12]
   2233                  p_tcb->PrevPtr          = (OS_TCB   *)0;
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6103             STR      R3,[R0, #+16]
   2234                  p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   \   00000022   0x6008             STR      R0,[R1, #+0]
   2235                  p_rdy_list->TailPtr     = p_tcb;
   \   00000024   0x6048             STR      R0,[R1, #+4]
   \   00000026   0xE009             B.N      ??OS_RdyListInsertTail_1
   2236              } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
   2237                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   \                     ??OS_RdyListInsertTail_0: (+1)
   \   00000028   0x890B             LDRH     R3,[R1, #+8]
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \   0000002C   0x810B             STRH     R3,[R1, #+8]
   2238                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x60C3             STR      R3,[R0, #+12]
   2239                  p_tcb2                  = p_rdy_list->TailPtr;
   \   00000032   0x684B             LDR      R3,[R1, #+4]
   \   00000034   0x001A             MOVS     R2,R3
   2240                  p_tcb->PrevPtr          = p_tcb2;
   \   00000036   0x6102             STR      R2,[R0, #+16]
   2241                  p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
   \   00000038   0x60D0             STR      R0,[R2, #+12]
   2242                  p_rdy_list->TailPtr     = p_tcb;
   \   0000003A   0x6048             STR      R0,[R1, #+4]
   2243              }
   2244          }
   \                     ??OS_RdyListInsertTail_1: (+1)
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
   2245          
   2246          /*$PAGE*/
   2247          /*
   2248          ************************************************************************************************************************
   2249          *                                                MOVE TCB AT HEAD TO TAIL
   2250          *
   2251          * Description: This function is called to move the current head of a list to the tail of the list.
   2252          *
   2253          *
   2254          *              CASE 0: TCB list is empty, nothing to do.
   2255          *
   2256          *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   2257          *
   2258          *              CASE 2: Only 2 OS_TCBs in the list.
   2259          *
   2260          *                     OS_RDY_LIST
   2261          *                     +--------------+
   2262          *                     | TailPtr      |--------------------------+
   2263          *                     +--------------+          OS_TCB          |     OS_TCB
   2264          *                     | HeadPtr      |------> +------------+    +-> +------------+
   2265          *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
   2266          *                     | NbrEntries=2 |        +------------+        +------------+
   2267          *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
   2268          *                                             +------------+        +------------+
   2269          *                                             :            :        :            :
   2270          *                                             :            :        :            :
   2271          *                                             +------------+        +------------+
   2272          *
   2273          *
   2274          *              CASE N: More than 2 OS_TCBs in the list.
   2275          *
   2276          *                     OS_RDY_LIST
   2277          *                     +--------------+
   2278          *                     | TailPtr      |-----------------------------------------------+
   2279          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2280          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2281          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2282          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2283          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2284          *                                             +------------+       +------------+        +------------+
   2285          *                                             :            :       :            :        :            :
   2286          *                                             :            :       :            :        :            :
   2287          *                                             +------------+       +------------+        +------------+
   2288          *
   2289          *
   2290          * Arguments  : p_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
   2291          *              ------
   2292          *
   2293          * Returns    : none
   2294          *
   2295          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2296          ************************************************************************************************************************
   2297          */
   2298          

   \                                 In section .text, align 2, keep-with-next
   2299          void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
   2300          {
   \                     OS_RdyListMoveHeadToTail: (+1)
   \   00000000   0xB410             PUSH     {R4}
   2301              OS_TCB  *p_tcb1;
   2302              OS_TCB  *p_tcb2;
   2303              OS_TCB  *p_tcb3;
   2304          
   2305          
   2306          
   2307              switch (p_rdy_list->NbrEntries) {
   \   00000002   0x8904             LDRH     R4,[R0, #+8]
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD002             BEQ.N    ??OS_RdyListMoveHeadToTail_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD001             BEQ.N    ??OS_RdyListMoveHeadToTail_1
   \   0000000C   0xD20D             BCS.N    ??OS_RdyListMoveHeadToTail_2
   2308                  case 0:
   2309                  case 1:
   2310                       break;
   \                     ??OS_RdyListMoveHeadToTail_0: (+1)
   \   0000000E   0xE01A             B.N      ??OS_RdyListMoveHeadToTail_3
   2311          
   2312                  case 2:                                             /* SWAP the TCBs                                          */
   2313                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   \                     ??OS_RdyListMoveHeadToTail_1: (+1)
   \   00000010   0x6804             LDR      R4,[R0, #+0]
   \   00000012   0x0021             MOVS     R1,R4
   2314                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   \   00000014   0x6844             LDR      R4,[R0, #+4]
   \   00000016   0x0022             MOVS     R2,R4
   2315                       p_tcb1->PrevPtr     = p_tcb2;
   \   00000018   0x610A             STR      R2,[R1, #+16]
   2316                       p_tcb1->NextPtr     = (OS_TCB *)0;
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x60CC             STR      R4,[R1, #+12]
   2317                       p_tcb2->PrevPtr     = (OS_TCB *)0;
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x6114             STR      R4,[R2, #+16]
   2318                       p_tcb2->NextPtr     = p_tcb1;
   \   00000022   0x60D1             STR      R1,[R2, #+12]
   2319                       p_rdy_list->HeadPtr = p_tcb2;
   \   00000024   0x6002             STR      R2,[R0, #+0]
   2320                       p_rdy_list->TailPtr = p_tcb1;
   \   00000026   0x6041             STR      R1,[R0, #+4]
   2321                       break;
   \   00000028   0xE00D             B.N      ??OS_RdyListMoveHeadToTail_3
   2322          
   2323                  default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
   2324                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   \                     ??OS_RdyListMoveHeadToTail_2: (+1)
   \   0000002A   0x6804             LDR      R4,[R0, #+0]
   \   0000002C   0x0021             MOVS     R1,R4
   2325                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   \   0000002E   0x6844             LDR      R4,[R0, #+4]
   \   00000030   0x0022             MOVS     R2,R4
   2326                       p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
   \   00000032   0x68CC             LDR      R4,[R1, #+12]
   \   00000034   0x0023             MOVS     R3,R4
   2327                       p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
   \   00000036   0x2400             MOVS     R4,#+0
   \   00000038   0x611C             STR      R4,[R3, #+16]
   2328                       p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0x60CC             STR      R4,[R1, #+12]
   2329                       p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
   \   0000003E   0x610A             STR      R2,[R1, #+16]
   2330                       p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
   \   00000040   0x60D1             STR      R1,[R2, #+12]
   2331                       p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
   \   00000042   0x6003             STR      R3,[R0, #+0]
   2332                       p_rdy_list->TailPtr = p_tcb1;
   \   00000044   0x6041             STR      R1,[R0, #+4]
   2333                       break;
   2334              }
   2335          }
   \                     ??OS_RdyListMoveHeadToTail_3: (+1)
   \   00000046   0xBC10             POP      {R4}
   \   00000048   0x4770             BX       LR               ;; return
   2336          
   2337          /*$PAGE*/
   2338          /*
   2339          ************************************************************************************************************************
   2340          *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
   2341          *
   2342          * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
   2343          *              remove.
   2344          *
   2345          *
   2346          *              CASE 0: TCB list is empty, nothing to do.
   2347          *
   2348          *              CASE 1: Only 1 OS_TCBs in the list.
   2349          *
   2350          *                     OS_RDY_LIST
   2351          *                     +--------------+          OS_TCB
   2352          *                     | TailPtr      |--+---> +------------+
   2353          *                     +--------------+  |     | NextPtr    |->0
   2354          *                     | HeadPtr      |--/     +------------+
   2355          *                     +--------------+     0<-| PrevPtr    |
   2356          *                     | NbrEntries=1 |        +------------+
   2357          *                     +--------------+        :            :
   2358          *                                             :            :
   2359          *                                             +------------+
   2360          *
   2361          *              CASE N: Two or more OS_TCBs in the list.
   2362          *
   2363          *                     OS_RDY_LIST
   2364          *                     +--------------+
   2365          *                     | TailPtr      |-----------------------------------------------+
   2366          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2367          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2368          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2369          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2370          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2371          *                                             +------------+       +------------+        +------------+
   2372          *                                             :            :       :            :        :            :
   2373          *                                             :            :       :            :        :            :
   2374          *                                             +------------+       +------------+        +------------+
   2375          *
   2376          *
   2377          * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
   2378          *              -----
   2379          *
   2380          * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
   2381          *
   2382          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2383          ************************************************************************************************************************
   2384          */
   2385          

   \                                 In section .text, align 2, keep-with-next
   2386          void  OS_RdyListRemove (OS_TCB  *p_tcb)
   2387          {
   \                     OS_RdyListRemove: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2388              OS_RDY_LIST  *p_rdy_list;
   2389              OS_TCB       *p_tcb1;
   2390              OS_TCB       *p_tcb2;
   2391          
   2392          
   2393          
   2394              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \   00000004   0x....             LDR.N    R0,??DataTable21_1
   \   00000006   0xF894 0x1037      LDRB     R1,[R4, #+55]
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000010   0x0005             MOVS     R5,R0
   2395              p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
   \   00000012   0x6920             LDR      R0,[R4, #+16]
   \   00000014   0x0006             MOVS     R6,R0
   2396              p_tcb2     = p_tcb->NextPtr;
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x0007             MOVS     R7,R0
   2397              if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD113             BNE.N    ??OS_RdyListRemove_0
   2398                  if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD10A             BNE.N    ??OS_RdyListRemove_1
   2399                      p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x8128             STRH     R0,[R5, #+8]
   2400                      p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6028             STR      R0,[R5, #+0]
   2401                      p_rdy_list->TailPtr    = (OS_TCB   *)0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6068             STR      R0,[R5, #+4]
   2402                      OS_PrioRemove(p_tcb->Prio);
   \   0000002E   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   00000032   0x.... 0x....      BL       OS_PrioRemove
   \   00000036   0xE00F             B.N      ??OS_RdyListRemove_2
   2403                  } else {
   2404                      p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
   \                     ??OS_RdyListRemove_1: (+1)
   \   00000038   0x8928             LDRH     R0,[R5, #+8]
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x8128             STRH     R0,[R5, #+8]
   2405                      p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6138             STR      R0,[R7, #+16]
   2406                      p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
   \   00000042   0x602F             STR      R7,[R5, #+0]
   \   00000044   0xE008             B.N      ??OS_RdyListRemove_2
   2407                  }
   2408              } else {
   2409                  p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
   \                     ??OS_RdyListRemove_0: (+1)
   \   00000046   0x8928             LDRH     R0,[R5, #+8]
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   \   0000004A   0x8128             STRH     R0,[R5, #+8]
   2410                  p_tcb1->NextPtr = p_tcb2;
   \   0000004C   0x60F7             STR      R7,[R6, #+12]
   2411                  if (p_tcb2 == (OS_TCB *)0) {
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD101             BNE.N    ??OS_RdyListRemove_3
   2412                      p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
   \   00000052   0x606E             STR      R6,[R5, #+4]
   \   00000054   0xE000             B.N      ??OS_RdyListRemove_2
   2413                  } else {
   2414                      p_tcb2->PrevPtr     = p_tcb1;
   \                     ??OS_RdyListRemove_3: (+1)
   \   00000056   0x613E             STR      R6,[R7, #+16]
   2415                  }
   2416              }
   2417              p_tcb->PrevPtr = (OS_TCB *)0;
   \                     ??OS_RdyListRemove_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6120             STR      R0,[R4, #+16]
   2418              p_tcb->NextPtr = (OS_TCB *)0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x60E0             STR      R0,[R4, #+12]
   2419          }
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2420          
   2421          /*$PAGE*/
   2422          /*
   2423          ************************************************************************************************************************
   2424          *                                             SCHEDULE THE ISR HANDLER TASK
   2425          *
   2426          * Description: This function is called by other uC/OS-III services to schedule task at priority 0 which is always the
   2427          *              ISR handler task.
   2428          *
   2429          * Arguments  : none
   2430          *
   2431          * Returns    : none
   2432          *
   2433          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2434          ************************************************************************************************************************
   2435          */
   2436          
   2437          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2438          void  OS_Sched0 (void)
   2439          {
   \                     OS_Sched0: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2440              CPU_SR_ALLOC();
   \   00000002   0x2400             MOVS     R4,#+0
   2441          
   2442          
   2443          
   2444              CPU_INT_DIS();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
   \   00000008   0x0004             MOVS     R4,R0
   2445              OSPrioHighRdy   = (OS_PRIO)0;                           /* Force the priority to 0                                */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable22_13
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   2446              OSTCBHighRdyPtr = &OSIntQTaskTCB;                       /* Always schedule the ISR handler task                   */
   \   00000010   0x....             LDR.N    R0,??DataTable22_14
   \   00000012   0x....             LDR.N    R1,??DataTable22_15
   \   00000014   0x6008             STR      R0,[R1, #+0]
   2447          #if OS_CFG_TASK_PROFILE_EN > 0u
   2448              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
   \   00000016   0x....             LDR.N    R0,??DataTable22_15
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF8D0 0x0090      LDR      R0,[R0, #+144]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable22_15
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0xF8C1 0x0090      STR      R0,[R1, #+144]
   2449          #endif
   2450              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   \   00000028   0x....             LDR.N    R0,??DataTable22
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable22
   \   00000030   0x6008             STR      R0,[R1, #+0]
   2451              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   \   00000032   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000036   0x....             LDR.N    R1,??DataTable22_1  ;; 0xe000ed04
   \   00000038   0x6008             STR      R0,[R1, #+0]
   2452              CPU_INT_EN();
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
   2453          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   2454          #endif
   2455          
   2456          /*$PAGE*/
   2457          /*
   2458          ************************************************************************************************************************
   2459          *                                               SCHEDULER LOCK TIME MEASUREMENT
   2460          *
   2461          * Description: These functions are used to measure the peak amount of time that the scheduler is locked
   2462          *
   2463          * Arguments  : none
   2464          *
   2465          * Returns    : none
   2466          *
   2467          * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
   2468          *
   2469          *              2) It's assumed that these functions are called when interrupts are disabled.
   2470          *
   2471          *              3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer.  The reason is that we
   2472          *                 don't expect to have the scheduler locked for 65536 counts even at the rate the TS timer is updated.
   2473          *                 In other words, locking the scheduler for longer than 65536 count would not be a good thing for a
   2474          *                 real-time system.
   2475          ************************************************************************************************************************
   2476          */
   2477          
   2478          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2479          void  OS_SchedLockTimeMeasStart (void)
   2480          {
   \                     OS_SchedLockTimeMeasStart: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2481              if (OSSchedLockNestingCtr == 1u) {
   \   00000002   0x....             LDR.N    R0,??DataTable22_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD103             BNE.N    ??OS_SchedLockTimeMeasStart_0
   2482                  OSSchedLockTimeBegin = CPU_TS_TmrRd();
   \   0000000A   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000000E   0x....             LDR.N    R1,??DataTable22_16
   \   00000010   0x6008             STR      R0,[R1, #+0]
   2483              }
   2484          }
   \                     ??OS_SchedLockTimeMeasStart_0: (+1)
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   2485          
   2486          
   2487          
   2488          

   \                                 In section .text, align 2, keep-with-next
   2489          void  OS_SchedLockTimeMeasStop (void)
   2490          {
   \                     OS_SchedLockTimeMeasStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2491              CPU_TS_TMR  delta;
   2492          
   2493          
   2494              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
   \   00000002   0x....             LDR.N    R0,??DataTable22_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD111             BNE.N    ??OS_SchedLockTimeMeasStop_0
   2495                  delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
   2496                        - OSSchedLockTimeBegin;
   \   0000000A   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000000E   0x....             LDR.N    R1,??DataTable22_16
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014   0x0004             MOVS     R4,R0
   2497                  if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
   \   00000016   0x....             LDR.N    R0,??DataTable22_17
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD201             BCS.N    ??OS_SchedLockTimeMeasStop_1
   2498                      OSSchedLockTimeMax    = delta;
   \   0000001E   0x....             LDR.N    R0,??DataTable22_17
   \   00000020   0x6004             STR      R4,[R0, #+0]
   2499                  }
   2500                  if (OSSchedLockTimeMaxCur < delta) {                /* Detect peak value (for resettable value)               */
   \                     ??OS_SchedLockTimeMeasStop_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable22_18
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x42A0             CMP      R0,R4
   \   00000028   0xD201             BCS.N    ??OS_SchedLockTimeMeasStop_0
   2501                      OSSchedLockTimeMaxCur = delta;
   \   0000002A   0x....             LDR.N    R0,??DataTable22_18
   \   0000002C   0x6004             STR      R4,[R0, #+0]
   2502                  }
   2503              }
   2504          }
   \                     ??OS_SchedLockTimeMeasStop_0: (+1)
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2505          #endif
   2506          
   2507          /*$PAGE*/
   2508          /*
   2509          ************************************************************************************************************************
   2510          *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
   2511          *
   2512          * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
   2513          *
   2514          *
   2515          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
   2516          *              ----------
   2517          *
   2518          * Returns    : none
   2519          *
   2520          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2521          ************************************************************************************************************************
   2522          */
   2523          
   2524          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2525          void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
   2526          {
   \                     OS_SchedRoundRobin: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2527              OS_TCB   *p_tcb;
   2528              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
   2529          
   2530          
   2531          
   2532              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
   \   00000006   0x....             LDR.N    R0,??DataTable22_19
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD14C             BNE.N    ??OS_SchedRoundRobin_0
   2533                  return;
   2534              }
   2535          
   2536              CPU_CRITICAL_ENTER();
   \                     ??OS_SchedRoundRobin_1: (+1)
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x0006             MOVS     R6,R0
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStart
   2537              p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x0005             MOVS     R5,R0
   2538          
   2539              if (p_tcb == (OS_TCB *)0) {
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD105             BNE.N    ??OS_SchedRoundRobin_2
   2540                  CPU_CRITICAL_EXIT();
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
   2541                  return;
   \   0000002A   0xE03D             B.N      ??OS_SchedRoundRobin_0
   2542              }
   2543          
   2544              if (p_tcb == &OSIdleTaskTCB) {
   \                     ??OS_SchedRoundRobin_2: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable22_10
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD105             BNE.N    ??OS_SchedRoundRobin_3
   2545                  CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
   2546                  return;
   \   0000003C   0xE034             B.N      ??OS_SchedRoundRobin_0
   2547              }
   2548          
   2549              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
   \                     ??OS_SchedRoundRobin_3: (+1)
   \   0000003E   0x6DA8             LDR      R0,[R5, #+88]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD002             BEQ.N    ??OS_SchedRoundRobin_4
   2550                  p_tcb->TimeQuantaCtr--;
   \   00000044   0x6DA8             LDR      R0,[R5, #+88]
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0x65A8             STR      R0,[R5, #+88]
   2551              }
   2552          
   2553              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
   \                     ??OS_SchedRoundRobin_4: (+1)
   \   0000004A   0x6DA8             LDR      R0,[R5, #+88]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD005             BEQ.N    ??OS_SchedRoundRobin_5
   2554                  CPU_CRITICAL_EXIT();
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000054   0x0030             MOVS     R0,R6
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
   2555                  return;
   \   0000005A   0xE025             B.N      ??OS_SchedRoundRobin_0
   2556              }
   2557          
   2558              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
   \                     ??OS_SchedRoundRobin_5: (+1)
   \   0000005C   0x8920             LDRH     R0,[R4, #+8]
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xDA05             BGE.N    ??OS_SchedRoundRobin_6
   2559                  CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
   2560                  return;
   \   0000006C   0xE01C             B.N      ??OS_SchedRoundRobin_0
   2561              }
   2562          
   2563              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
   \                     ??OS_SchedRoundRobin_6: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable22_2
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD005             BEQ.N    ??OS_SchedRoundRobin_7
   2564                  CPU_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
   2565                  return;
   \   00000080   0xE012             B.N      ??OS_SchedRoundRobin_0
   2566              }
   2567          
   2568              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
   \                     ??OS_SchedRoundRobin_7: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
   2569              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x0005             MOVS     R5,R0
   2570              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
   \   0000008C   0x6D68             LDR      R0,[R5, #+84]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD103             BNE.N    ??OS_SchedRoundRobin_8
   2571                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   00000092   0x....             LDR.N    R0,??DataTable22_20
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x65A8             STR      R0,[R5, #+88]
   \   00000098   0xE001             B.N      ??OS_SchedRoundRobin_9
   2572              } else {
   2573                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
   \                     ??OS_SchedRoundRobin_8: (+1)
   \   0000009A   0x6D68             LDR      R0,[R5, #+84]
   \   0000009C   0x65A8             STR      R0,[R5, #+88]
   2574              }
   2575              CPU_CRITICAL_EXIT();
   \                     ??OS_SchedRoundRobin_9: (+1)
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
   2576          }
   \                     ??OS_SchedRoundRobin_0: (+1)
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
   2577          #endif
   2578          
   2579          /*$PAGE*/
   2580          /*
   2581          ************************************************************************************************************************
   2582          *                                                     BLOCK A TASK
   2583          *
   2584          * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
   2585          *              the specified timeout is non-zero.
   2586          *
   2587          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
   2588          *              -----
   2589          *
   2590          *              timeout        is the desired timeout
   2591          *
   2592          * Returns    : none
   2593          *
   2594          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2595          ************************************************************************************************************************
   2596          */
   2597          

   \                                 In section .text, align 2, keep-with-next
   2598          void  OS_TaskBlock (OS_TCB   *p_tcb,
   2599                              OS_TICK   timeout)
   2600          {
   \                     OS_TaskBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2601              OS_ERR  err;
   2602          
   2603          
   2604              if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD011             BEQ.N    ??OS_TaskBlock_0
   2605                  OS_TickListInsert(p_tcb,
   2606                                    timeout,
   2607                                    OS_OPT_TIME_TIMEOUT,
   2608                                   &err);
   \   0000000A   0x466B             MOV      R3,SP
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       OS_TickListInsert
   2609                  if (err == OS_ERR_NONE) {
   \   00000016   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD103             BNE.N    ??OS_TaskBlock_1
   2610                      p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   00000024   0xE006             B.N      ??OS_TaskBlock_2
   2611                  } else {
   2612                      p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_1: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   0000002C   0xE002             B.N      ??OS_TaskBlock_2
   2613                  }
   2614              } else {
   2615                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_0: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF884 0x0036      STRB     R0,[R4, #+54]
   2616              }
   2617              OS_RdyListRemove(p_tcb);
   \                     ??OS_TaskBlock_2: (+1)
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       OS_RdyListRemove
   2618          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2619          
   2620          /*$PAGE*/
   2621          /*
   2622          ************************************************************************************************************************
   2623          *                                                     READY A TASK
   2624          *
   2625          * Description: This function is called to make a task ready-to-run.
   2626          *
   2627          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   2628          *              -----
   2629          *
   2630          * Returns    : none
   2631          *
   2632          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2633          ************************************************************************************************************************
   2634          */
   2635          

   \                                 In section .text, align 2, keep-with-next
   2636          void  OS_TaskRdy (OS_TCB  *p_tcb)
   2637          {
   \                     OS_TaskRdy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2638              OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       OS_TickListRemove
   2639              if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
   \   0000000A   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000000E   0x0740             LSLS     R0,R0,#+29
   \   00000010   0xD402             BMI.N    ??OS_TaskRdy_0
   2640                  OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       OS_RdyListInsert
   2641              }
   2642          }
   \                     ??OS_TaskRdy_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     OSPrioSaved

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     OSSchedLockTimeBegin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     OSSchedLockTimeMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     OSSchedLockTimeMaxCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     OSSchedRoundRobinEn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x........         DC32     OSIdleTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x........         DC32     OSStatTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x........         DC32     OS_IdleTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \   00000000   0x........         DC32     OSIntQTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \   00000000   0x........         DC32     OSSchedLockTimeBegin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_17:
   \   00000000   0x........         DC32     OSSchedLockTimeMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_18:
   \   00000000   0x........         DC32     OSSchedLockTimeMaxCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_19:
   \   00000000   0x........         DC32     OSSchedRoundRobinEn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_20:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-III Idle Task"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x49 0x20    
   \              0x49 0x64    
   \              0x6C 0x65    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x61          DC8 "Task Q"
   \              0x73 0x6B    
   \              0x20 0x51    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x54 0x61          DC8 "Task Sem"
   \              0x73 0x6B    
   \              0x20 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSInit
        16   -> OSCfg_Init
        16   -> OSInitHook
        16   -> OS_Dbg_Init
        16   -> OS_FlagInit
        16   -> OS_IdleTaskInit
        16   -> OS_IntQTaskInit
        16   -> OS_MemInit
        16   -> OS_MsgPoolInit
        16   -> OS_MutexInit
        16   -> OS_PrioInit
        16   -> OS_QInit
        16   -> OS_RdyListInit
        16   -> OS_SemInit
        16   -> OS_StatTaskInit
        16   -> OS_TaskInit
        16   -> OS_TickTaskInit
        16   -> OS_TmrInit
       0   OSIntEnter
       8   OSIntExit
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
       8   OSSched
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PrioGetHighest
      16   OSSchedLock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_SchedLockTimeMeasStart
      24   OSSchedRoundRobinCfg
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSSchedRoundRobinYield
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListMoveHeadToTail
      16   OSSchedUnlock
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_SchedLockTimeMeasStop
       8   OSStart
         8   -> OSStartHighRdy
         8   -> OS_PrioGetHighest
       0   OSVersion
      16   OS_IdleTask
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSIdleTaskHook
      48   OS_IdleTaskInit
        48   -> OSTaskCreate
      24   OS_Pend
        24   -> OS_PendDataInit
        24   -> OS_PendDbgNameAdd
        24   -> OS_PendListInsertPrio
        24   -> OS_TaskBlock
      16   OS_PendAbort
        16   -> OS_PendAbort1
        16   -> OS_PendListRemove
        16   -> OS_TaskRdy
        16   -> OS_TickListRemove
       8   OS_PendAbort1
       4   OS_PendDataInit
       8   OS_PendDbgNameAdd
       8   OS_PendDbgNameRemove
      32   OS_PendListChangePrio
        32   -> OS_PendListInsertPrio
        32   -> OS_PendListRemove1
       0   OS_PendListInit
       0   OS_PendListInsertHead
      16   OS_PendListInsertPrio
      24   OS_PendListRemove
        24   -> OS_PendListRemove1
       4   OS_PendListRemove1
      16   OS_PendObjDel
        16   -> OS_PendListRemove
        16   -> OS_PendObjDel1
        16   -> OS_TaskRdy
        16   -> OS_TickListRemove
       8   OS_PendObjDel1
      32   OS_Post
        32   -> OS_PendDbgNameRemove
        32   -> OS_PendListRemove
        32   -> OS_Post1
        32   -> OS_TaskRdy
        32   -> OS_TickListRemove
      16   OS_Post1
       0   OS_RdyListInit
       8   OS_RdyListInsert
         8   -> OS_PrioInsert
         8   -> OS_RdyListInsertHead
         8   -> OS_RdyListInsertTail
       8   OS_RdyListInsertHead
       8   OS_RdyListInsertTail
       4   OS_RdyListMoveHeadToTail
      24   OS_RdyListRemove
        24   -> OS_PrioRemove
       8   OS_Sched0
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   OS_SchedLockTimeMeasStart
         8   -> CPU_TS_TmrRd
       8   OS_SchedLockTimeMeasStop
         8   -> CPU_TS_TmrRd
      16   OS_SchedRoundRobin
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_RdyListMoveHeadToTail
      16   OS_TaskBlock
        16   -> OS_RdyListRemove
        16   -> OS_TickListInsert
       8   OS_TaskRdy
         8   -> OS_RdyListInsert
         8   -> OS_TickListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       4  ??DataTable18
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      20  ?_0
       8  ?_1
      12  ?_2
       2  ?_3
     392  OSInit
      36  OSIntEnter
     200  OSIntExit
     142  OSSched
     104  OSSchedLock
      90  OSSchedRoundRobinCfg
     162  OSSchedRoundRobinYield
     136  OSSchedUnlock
     100  OSStart
      12  OSVersion
      60  OS_IdleTask
      82  OS_IdleTaskInit
     118  OS_Pend
     176  OS_PendAbort
      38  OS_PendAbort1
      54  OS_PendDataInit
      76  OS_PendDbgNameAdd
      40  OS_PendDbgNameRemove
      70  OS_PendListChangePrio
      14  OS_PendListInit
      36  OS_PendListInsertHead
     122  OS_PendListInsertPrio
      56  OS_PendListRemove
      84  OS_PendListRemove1
     168  OS_PendObjDel
      38  OS_PendObjDel1
     220  OS_Post
      44  OS_Post1
      40  OS_RdyListInit
      40  OS_RdyListInsert
      66  OS_RdyListInsertHead
      64  OS_RdyListInsertTail
      74  OS_RdyListMoveHeadToTail
      98  OS_RdyListRemove
      66  OS_Sched0
      20  OS_SchedLockTimeMeasStart
      48  OS_SchedLockTimeMeasStop
     170  OS_SchedRoundRobin
      60  OS_TaskBlock
      26  OS_TaskRdy

 
    42 bytes in section .rodata
 3 830 bytes in section .text
 
 3 830 bytes of CODE  memory
    42 bytes of CONST memory

Errors: none
Warnings: none
