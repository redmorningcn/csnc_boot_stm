###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_sem.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_sem.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_sem.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_sem.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_sem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                 SEMAPHORE MANAGEMENT
     10          *
     11          * File    : OS_SEM.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_sem__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_SEM_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                                  CREATE A SEMAPHORE
     45          *
     46          * Description: This function creates a semaphore.
     47          *
     48          * Arguments  : p_sem         is a pointer to the semaphore to initialize.  Your application is responsible for
     49          *                            allocating storage for the semaphore.
     50          *
     51          *              p_name        is a pointer to the name you would like to give the semaphore.
     52          *
     53          *              cnt           is the initial value for the semaphore.
     54          *                            If used to share resources, you should initialize to the number of resources available.
     55          *                            If used to signal the occurrence of event(s) then you should initialize to 0.
     56          *
     57          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     58          *
     59          *                                OS_ERR_NONE                    if the call was successful
     60          *                                OS_ERR_CREATE_ISR              if you called this function from an ISR
     61          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the semaphore after you
     62          *                                                                 called OSSafetyCriticalStart().
     63          *                                OS_ERR_NAME                    if 'p_name' is a NULL pointer
     64          *                                OS_ERR_OBJ_CREATED             if the semaphore has already been created
     65          *                                OS_ERR_OBJ_PTR_NULL            if 'p_sem'  is a NULL pointer
     66          *                                OS_ERR_OBJ_TYPE                if 'p_sem' has already been initialized to a different
     67          *                                                               object type
     68          *
     69          * Returns    : none
     70          ************************************************************************************************************************
     71          */
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void  OSSemCreate (OS_SEM      *p_sem,
     74                             CPU_CHAR    *p_name,
     75                             OS_SEM_CTR   cnt,
     76                             OS_ERR      *p_err)
     77          {
   \                     OSSemCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     78              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
     79          
     80          
     81          
     82          #ifdef OS_SAFETY_CRITICAL
     83              if (p_err == (OS_ERR *)0) {
     84                  OS_SAFETY_CRITICAL_EXCEPTION();
     85                  return;
     86              }
     87          #endif
     88          
     89          #ifdef OS_SAFETY_CRITICAL_IEC61508
     90              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     91                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     92                  return;
     93              }
     94          #endif
     95          
     96          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     97              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??OSSemCreate_0
     98                 *p_err = OS_ERR_CREATE_ISR;
   \   0000001A   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
     99                  return;
   \   00000020   0xE04C             B.N      ??OSSemCreate_1
    100              }
    101          #endif
    102          
    103          #if OS_CFG_ARG_CHK_EN > 0u
    104              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemCreate_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??OSSemCreate_2
    105                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8038             STRH     R0,[R7, #+0]
    106                  return;
   \   0000002C   0xE046             B.N      ??OSSemCreate_1
    107              }
    108          #endif
    109          
    110              OS_CRITICAL_ENTER();
   \                     ??OSSemCreate_2: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x4680             MOV      R8,R0
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD101             BNE.N    ??OSSemCreate_3
   \   00000050   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSSemCreate_3: (+1)
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    111              p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable10_3  ;; 0x414d4553
   \   00000062   0x6020             STR      R0,[R4, #+0]
    112              p_sem->Ctr     = cnt;                                   /* Set semaphore value                                    */
   \   00000064   0x6226             STR      R6,[R4, #+32]
    113              p_sem->TS      = (CPU_TS)0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6260             STR      R0,[R4, #+36]
    114              p_sem->NamePtr = p_name;                                /* Save the name of the semaphore                         */
   \   0000006A   0x6065             STR      R5,[R4, #+4]
    115              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \   0000006C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000070   0x.... 0x....      BL       OS_PendListInit
    116          
    117          #if OS_CFG_DBG_EN > 0u
    118              OS_SemDbgListAdd(p_sem);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       OS_SemDbgListAdd
    119          #endif
    120              OSSemQty++;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   0000007E   0x8800             LDRH     R0,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   00000086   0x8008             STRH     R0,[R1, #+0]
    121          
    122              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000088   0x.... 0x....      BL       CPU_SR_Save
   \   0000008C   0x4680             MOV      R8,R0
   \   0000008E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x1E40             SUBS     R0,R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD101             BNE.N    ??OSSemCreate_4
   \   000000AA   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSSemCreate_4: (+1)
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
    123             *p_err = OS_ERR_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x8038             STRH     R0,[R7, #+0]
    124          }
   \                     ??OSSemCreate_1: (+1)
   \   000000BC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    125          
    126          /*$PAGE*/
    127          /*
    128          ************************************************************************************************************************
    129          *                                                  DELETE A SEMAPHORE
    130          *
    131          * Description: This function deletes a semaphore.
    132          *
    133          * Arguments  : p_sem         is a pointer to the semaphore to delete
    134          *
    135          *              opt           determines delete options as follows:
    136          *
    137          *                                OS_OPT_DEL_NO_PEND          Delete semaphore ONLY if no task pending
    138          *                                OS_OPT_DEL_ALWAYS           Deletes the semaphore even if tasks are waiting.
    139          *                                                            In this case, all the tasks pending will be readied.
    140          *
    141          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    142          *
    143          *                                OS_ERR_NONE                 The call was successful and the semaphore was deleted
    144          *                                OS_ERR_DEL_ISR              If you attempted to delete the semaphore from an ISR
    145          *                                OS_ERR_OBJ_PTR_NULL         If 'p_sem' is a NULL pointer.
    146          *                                OS_ERR_OBJ_TYPE             If 'p_sem' is not pointing at a semaphore
    147          *                                OS_ERR_OPT_INVALID          An invalid option was specified
    148          *                                OS_ERR_TASK_WAITING         One or more tasks were waiting on the semaphore
    149          *
    150          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    151          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    152          *
    153          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the semaphore
    154          *                 MUST check the return code of OSSemPend().
    155          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted.
    156          *              3) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in applications where
    157          *                 the semaphore is used for mutual exclusion because the resource(s) will no longer be guarded by the
    158          *                 semaphore.
    159          ************************************************************************************************************************
    160          */
    161          
    162          #if OS_CFG_SEM_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    163          OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
    164                                OS_OPT   opt,
    165                                OS_ERR  *p_err)
    166          {
   \                     OSSemDel: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    167              OS_OBJ_QTY     cnt;
    168              OS_OBJ_QTY     nbr_tasks;
    169              OS_PEND_DATA  *p_pend_data;
    170              OS_PEND_LIST  *p_pend_list;
    171              OS_TCB        *p_tcb;
    172              CPU_TS         ts;
    173              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    174          
    175          
    176          
    177          #ifdef OS_SAFETY_CRITICAL
    178              if (p_err == (OS_ERR *)0) {
    179                  OS_SAFETY_CRITICAL_EXCEPTION();
    180                  return ((OS_OBJ_QTY)0);
    181              }
    182          #endif
    183          
    184          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    185              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSSemDel_0
    186                 *p_err = OS_ERR_DEL_ISR;
   \   0000001A   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    187                  return ((OS_OBJ_QTY)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE0AA             B.N      ??OSSemDel_1
    188              }
    189          #endif
    190          
    191          #if OS_CFG_ARG_CHK_EN > 0u
    192              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemDel_0: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD104             BNE.N    ??OSSemDel_2
    193                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
    194                  return ((OS_OBJ_QTY)0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE0A3             B.N      ??OSSemDel_1
    195              }
    196              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemDel_2: (+1)
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD805             BHI.N    ??OSSemDel_3
    197                  case OS_OPT_DEL_NO_PEND:
    198                  case OS_OPT_DEL_ALWAYS:
    199                       break;
    200          
    201                  default:
    202                      *p_err = OS_ERR_OPT_INVALID;
    203                       return ((OS_OBJ_QTY)0);
    204              }
    205          #endif
    206          
    207          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    208              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemDel_4: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0x414d4553
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD105             BNE.N    ??OSSemDel_5
   \   00000046   0xE009             B.N      ??OSSemDel_6
   \                     ??OSSemDel_3: (+1)
   \   00000048   0xF645 0x6025      MOVW     R0,#+24101
   \   0000004C   0x8030             STRH     R0,[R6, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE093             B.N      ??OSSemDel_1
    209                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSSemDel_5: (+1)
   \   00000052   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    210                  return ((OS_OBJ_QTY)0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE08E             B.N      ??OSSemDel_1
    211              }
    212          #endif
    213          
    214              CPU_CRITICAL_ENTER();
   \                     ??OSSemDel_6: (+1)
   \   0000005C   0x.... 0x....      BL       CPU_SR_Save
   \   00000060   0x4683             MOV      R11,R0
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStart
    215              p_pend_list = &p_sem->PendList;
   \   00000066   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000006A   0x4681             MOV      R9,R0
    216              cnt         = p_pend_list->NbrEntries;
   \   0000006C   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   00000070   0x0007             MOVS     R7,R0
    217              nbr_tasks   = cnt;
   \   00000072   0x46B8             MOV      R8,R7
    218              switch (opt) {
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD002             BEQ.N    ??OSSemDel_7
   \   0000007A   0x2D01             CMP      R5,#+1
   \   0000007C   0xD023             BEQ.N    ??OSSemDel_8
   \   0000007E   0xE072             B.N      ??OSSemDel_9
    219                  case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
    220                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSSemDel_7: (+1)
   \   00000080   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000084   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000088   0xD114             BNE.N    ??OSSemDel_10
    221          #if OS_CFG_DBG_EN > 0u
    222                           OS_SemDbgListRemove(p_sem);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       OS_SemDbgListRemove
    223          #endif
    224                           OSSemQty--;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000094   0x8800             LDRH     R0,[R0, #+0]
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   0000009C   0x8008             STRH     R0,[R1, #+0]
    225                           OS_SemClr(p_sem);
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       OS_SemClr
    226                           CPU_CRITICAL_EXIT();
   \   000000A4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A8   0x4658             MOV      R0,R11
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    227                          *p_err = OS_ERR_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x8030             STRH     R0,[R6, #+0]
   \   000000B2   0xE007             B.N      ??OSSemDel_11
    228                       } else {
    229                           CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_10: (+1)
   \   000000B4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B8   0x4658             MOV      R0,R11
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    230                          *p_err = OS_ERR_TASK_WAITING;
   \   000000BE   0xF247 0x105F      MOVW     R0,#+29023
   \   000000C2   0x8030             STRH     R0,[R6, #+0]
    231                       }
    232                       break;
   \                     ??OSSemDel_11: (+1)
   \   000000C4   0xE057             B.N      ??OSSemDel_12
    233          
    234                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
    235                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemDel_8: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD101             BNE.N    ??OSSemDel_13
   \   000000DE   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSSemDel_13: (+1)
   \   000000E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E6   0x4658             MOV      R0,R11
   \   000000E8   0x.... 0x....      BL       CPU_SR_Restore
    236                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
   \   000000EC   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000F0   0x9000             STR      R0,[SP, #+0]
    237                       while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
   \                     ??OSSemDel_14: (+1)
   \   000000F2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000F4   0x2F00             CMP      R7,#+0
   \   000000F6   0xD00C             BEQ.N    ??OSSemDel_15
    238                           p_pend_data = p_pend_list->HeadPtr;
   \   000000F8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000FC   0x9001             STR      R0,[SP, #+4]
    239                           p_tcb       = p_pend_data->TCBPtr;
   \   000000FE   0x9801             LDR      R0,[SP, #+4]
   \   00000100   0x6880             LDR      R0,[R0, #+8]
   \   00000102   0x4682             MOV      R10,R0
    240                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
    241                                         p_tcb,
    242                                         ts);
   \   00000104   0x9A00             LDR      R2,[SP, #+0]
   \   00000106   0x4651             MOV      R1,R10
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       OS_PendObjDel
    243                           cnt--;
   \   0000010E   0x1E7F             SUBS     R7,R7,#+1
   \   00000110   0xE7EF             B.N      ??OSSemDel_14
    244                       }
    245          #if OS_CFG_DBG_EN > 0u
    246                       OS_SemDbgListRemove(p_sem);
   \                     ??OSSemDel_15: (+1)
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       OS_SemDbgListRemove
    247          #endif
    248                       OSSemQty--;
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   0000011C   0x8800             LDRH     R0,[R0, #+0]
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   00000124   0x8008             STRH     R0,[R1, #+0]
    249                       OS_SemClr(p_sem);
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       OS_SemClr
    250                       OS_CRITICAL_EXIT_NO_SCHED();
   \   0000012C   0x.... 0x....      BL       CPU_SR_Save
   \   00000130   0x4683             MOV      R11,R0
   \   00000132   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0x1E40             SUBS     R0,R0,#+1
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000142   0x7008             STRB     R0,[R1, #+0]
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD101             BNE.N    ??OSSemDel_16
   \   0000014E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSSemDel_16: (+1)
   \   00000152   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000156   0x4658             MOV      R0,R11
   \   00000158   0x.... 0x....      BL       CPU_SR_Restore
    251                       OSSched();                                     /* Find highest priority task ready to run                */
   \   0000015C   0x.... 0x....      BL       OSSched
    252                      *p_err = OS_ERR_NONE;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x8030             STRH     R0,[R6, #+0]
    253                       break;
   \   00000164   0xE007             B.N      ??OSSemDel_12
    254          
    255                  default:
    256                       CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_9: (+1)
   \   00000166   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016A   0x4658             MOV      R0,R11
   \   0000016C   0x.... 0x....      BL       CPU_SR_Restore
    257                      *p_err = OS_ERR_OPT_INVALID;
   \   00000170   0xF645 0x6025      MOVW     R0,#+24101
   \   00000174   0x8030             STRH     R0,[R6, #+0]
    258                       break;
    259              }
    260              return ((OS_OBJ_QTY)nbr_tasks);
   \                     ??OSSemDel_12: (+1)
   \   00000176   0x4640             MOV      R0,R8
   \   00000178   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemDel_1: (+1)
   \   0000017A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    261          }
    262          #endif
    263          
    264          /*$PAGE*/
    265          /*
    266          ************************************************************************************************************************
    267          *                                                  PEND ON SEMAPHORE
    268          *
    269          * Description: This function waits for a semaphore.
    270          *
    271          * Arguments  : p_sem         is a pointer to the semaphore
    272          *
    273          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    274          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    275          *                            0, however, your task will wait forever at the specified semaphore or, until the resource
    276          *                            becomes available (or the event occurs).
    277          *
    278          *              opt           determines whether the user wants to block if the semaphore is not available or not:
    279          *
    280          *                                OS_OPT_PEND_BLOCKING
    281          *                                OS_OPT_PEND_NON_BLOCKING
    282          *
    283          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
    284          *                            or pend aborted or the semaphore deleted.  If you pass a NULL pointer (i.e. (CPU_TS*)0)
    285          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid
    286          *                            and indicates that you don't need the timestamp.
    287          *
    288          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    289          *
    290          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    291          *                                                          or, the event you are waiting for occurred.
    292          *                                OS_ERR_OBJ_DEL            If 'p_sem' was deleted
    293          *                                OS_ERR_OBJ_PTR_NULL       If 'p_sem' is a NULL pointer.
    294          *                                OS_ERR_OBJ_TYPE           If 'p_sem' is not pointing at a semaphore
    295          *                                OS_ERR_OPT_INVALID        If you specified an invalid value for 'opt'
    296          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    297          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    298          *                                                          would lead to a suspension.
    299          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the semaphore was not
    300          *                                                          available.
    301          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    302          *                                OS_ERR_STATUS_INVALID     Pend status is invalid
    303          *                                OS_ERR_TIMEOUT            The semaphore was not received within the specified
    304          *                                                          timeout.
    305          *
    306          *
    307          * Returns    : The current value of the semaphore counter or 0 if not available.
    308          ************************************************************************************************************************
    309          */
    310          

   \                                 In section .text, align 2, keep-with-next
    311          OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
    312                                 OS_TICK   timeout,
    313                                 OS_OPT    opt,
    314                                 CPU_TS   *p_ts,
    315                                 OS_ERR   *p_err)
    316          {
   \                     OSSemPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8040      LDR      R8,[SP, #+64]
    317              OS_SEM_CTR    ctr;
    318              OS_PEND_DATA  pend_data;
    319              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0A00      MOVS     R10,#+0
    320          
    321          
    322          
    323          #ifdef OS_SAFETY_CRITICAL
    324              if (p_err == (OS_ERR *)0) {
    325                  OS_SAFETY_CRITICAL_EXCEPTION();
    326                  return ((OS_SEM_CTR)0);
    327              }
    328          #endif
    329          
    330          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    331              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??OSSemPend_0
    332                 *p_err = OS_ERR_PEND_ISR;
   \   00000020   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000024   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    333                  return ((OS_SEM_CTR)0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE0E2             B.N      ??OSSemPend_1
    334              }
    335          #endif
    336          
    337          #if OS_CFG_ARG_CHK_EN > 0u
    338              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemPend_0: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD105             BNE.N    ??OSSemPend_2
    339                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000030   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000034   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    340                  return ((OS_SEM_CTR)0);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE0DA             B.N      ??OSSemPend_1
    341              }
    342              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPend_2: (+1)
   \   0000003C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD002             BEQ.N    ??OSSemPend_3
   \   00000044   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000048   0xD105             BNE.N    ??OSSemPend_4
    343                  case OS_OPT_PEND_BLOCKING:
    344                  case OS_OPT_PEND_NON_BLOCKING:
    345                       break;
    346          
    347                  default:
    348                      *p_err = OS_ERR_OPT_INVALID;
    349                       return ((OS_SEM_CTR)0);
    350              }
    351          #endif
    352          
    353          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    354              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPend_3: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0x414d4553
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD106             BNE.N    ??OSSemPend_5
   \   00000054   0xE00B             B.N      ??OSSemPend_6
   \                     ??OSSemPend_4: (+1)
   \   00000056   0xF645 0x6025      MOVW     R0,#+24101
   \   0000005A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE0C7             B.N      ??OSSemPend_1
    355                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSSemPend_5: (+1)
   \   00000062   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000066   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    356                  return ((OS_SEM_CTR)0);
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE0C1             B.N      ??OSSemPend_1
    357              }
    358          #endif
    359          
    360              if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_6: (+1)
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD001             BEQ.N    ??OSSemPend_7
    361                 *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6038             STR      R0,[R7, #+0]
    362              }
    363              CPU_CRITICAL_ENTER();
   \                     ??OSSemPend_7: (+1)
   \   00000076   0x.... 0x....      BL       CPU_SR_Save
   \   0000007A   0x4682             MOV      R10,R0
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStart
    364              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
   \   00000080   0x6A20             LDR      R0,[R4, #+32]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD012             BEQ.N    ??OSSemPend_8
    365                  p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
   \   00000086   0x6A20             LDR      R0,[R4, #+32]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x6220             STR      R0,[R4, #+32]
    366                  if (p_ts != (CPU_TS *)0) {
   \   0000008C   0x2F00             CMP      R7,#+0
   \   0000008E   0xD001             BEQ.N    ??OSSemPend_9
    367                     *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
   \   00000090   0x6A60             LDR      R0,[R4, #+36]
   \   00000092   0x6038             STR      R0,[R7, #+0]
    368                  }
    369                  ctr   = p_sem->Ctr;
   \                     ??OSSemPend_9: (+1)
   \   00000094   0x6A20             LDR      R0,[R4, #+32]
   \   00000096   0x4681             MOV      R9,R0
    370                  CPU_CRITICAL_EXIT();
   \   00000098   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009C   0x4650             MOV      R0,R10
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
    371                 *p_err = OS_ERR_NONE;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    372                  return (ctr);
   \   000000A8   0x4648             MOV      R0,R9
   \   000000AA   0xE0A2             B.N      ??OSSemPend_1
    373              }
    374          
    375              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSSemPend_8: (+1)
   \   000000AC   0x0430             LSLS     R0,R6,#+16
   \   000000AE   0xD50C             BPL.N    ??OSSemPend_10
    376                  ctr   = p_sem->Ctr;                                 /* No                                                     */
   \   000000B0   0x6A20             LDR      R0,[R4, #+32]
   \   000000B2   0x4681             MOV      R9,R0
    377                  CPU_CRITICAL_EXIT();
   \   000000B4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B8   0x4650             MOV      R0,R10
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    378                 *p_err = OS_ERR_PEND_WOULD_BLOCK;
   \   000000BE   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000C2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    379                  return (ctr);
   \   000000C6   0x4648             MOV      R0,R9
   \   000000C8   0xE093             B.N      ??OSSemPend_1
    380              } else {                                                /* Yes                                                    */
    381                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSSemPend_10: (+1)
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD00A             BEQ.N    ??OSSemPend_11
    382                      CPU_CRITICAL_EXIT();
   \   000000D4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D8   0x4650             MOV      R0,R10
   \   000000DA   0x.... 0x....      BL       CPU_SR_Restore
    383                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000DE   0xF646 0x5063      MOVW     R0,#+28003
   \   000000E2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    384                      return ((OS_SEM_CTR)0);
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xE083             B.N      ??OSSemPend_1
    385                  }
    386              }
    387                                                                      /* Lock the scheduler/re-enable interrupts                */
    388              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPend_11: (+1)
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x1C40             ADDS     R0,R0,#+1
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x2801             CMP      R0,#+1
   \   00000100   0xD101             BNE.N    ??OSSemPend_12
   \   00000102   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSSemPend_12: (+1)
   \   00000106   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010A   0x4650             MOV      R0,R10
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
    389              OS_Pend(&pend_data,                                     /* Block task pending on Semaphore                        */
    390                      (OS_PEND_OBJ *)((void *)p_sem),
    391                      OS_TASK_PEND_ON_SEM,
    392                      timeout);
   \   00000110   0x002B             MOVS     R3,R5
   \   00000112   0x2206             MOVS     R2,#+6
   \   00000114   0x0021             MOVS     R1,R4
   \   00000116   0x4668             MOV      R0,SP
   \   00000118   0x.... 0x....      BL       OS_Pend
    393          
    394              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000011C   0x.... 0x....      BL       CPU_SR_Save
   \   00000120   0x4682             MOV      R10,R0
   \   00000122   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000012A   0x7800             LDRB     R0,[R0, #+0]
   \   0000012C   0x1E40             SUBS     R0,R0,#+1
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000132   0x7008             STRB     R0,[R1, #+0]
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD101             BNE.N    ??OSSemPend_13
   \   0000013E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSSemPend_13: (+1)
   \   00000142   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000146   0x4650             MOV      R0,R10
   \   00000148   0x.... 0x....      BL       CPU_SR_Restore
    395          
    396              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   0000014C   0x.... 0x....      BL       OSSched
    397          
    398              CPU_CRITICAL_ENTER();
   \   00000150   0x.... 0x....      BL       CPU_SR_Save
   \   00000154   0x4682             MOV      R10,R0
   \   00000156   0x.... 0x....      BL       CPU_IntDisMeasStart
    399              switch (OSTCBCurPtr->PendStatus) {
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000015E   0x6800             LDR      R0,[R0, #+0]
   \   00000160   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD005             BEQ.N    ??OSSemPend_14
   \   00000168   0x2802             CMP      R0,#+2
   \   0000016A   0xD023             BEQ.N    ??OSSemPend_15
   \   0000016C   0xD30D             BCC.N    ??OSSemPend_16
   \   0000016E   0x2803             CMP      R0,#+3
   \   00000170   0xD017             BEQ.N    ??OSSemPend_17
   \   00000172   0xE02B             B.N      ??OSSemPend_18
    400                  case OS_STATUS_PEND_OK:                             /* We got the semaphore                                   */
    401                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_14: (+1)
   \   00000174   0x2F00             CMP      R7,#+0
   \   00000176   0xD004             BEQ.N    ??OSSemPend_19
    402                          *p_ts  =  OSTCBCurPtr->TS;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0x6C00             LDR      R0,[R0, #+64]
   \   00000180   0x6038             STR      R0,[R7, #+0]
    403                       }
    404                      *p_err = OS_ERR_NONE;
   \                     ??OSSemPend_19: (+1)
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    405                       break;
   \   00000188   0xE02B             B.N      ??OSSemPend_20
    406          
    407                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    408                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_16: (+1)
   \   0000018A   0x2F00             CMP      R7,#+0
   \   0000018C   0xD004             BEQ.N    ??OSSemPend_21
    409                          *p_ts  =  OSTCBCurPtr->TS;
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0x6C00             LDR      R0,[R0, #+64]
   \   00000196   0x6038             STR      R0,[R7, #+0]
    410                       }
    411                      *p_err = OS_ERR_PEND_ABORT;
   \                     ??OSSemPend_21: (+1)
   \   00000198   0xF246 0x10A9      MOVW     R0,#+25001
   \   0000019C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    412                       break;
   \   000001A0   0xE01F             B.N      ??OSSemPend_20
    413          
    414                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
    415                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_17: (+1)
   \   000001A2   0x2F00             CMP      R7,#+0
   \   000001A4   0xD001             BEQ.N    ??OSSemPend_22
    416                          *p_ts  = (CPU_TS  )0;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x6038             STR      R0,[R7, #+0]
    417                       }
    418                      *p_err = OS_ERR_TIMEOUT;
   \                     ??OSSemPend_22: (+1)
   \   000001AA   0xF247 0x20D9      MOVW     R0,#+29401
   \   000001AE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    419                       break;
   \   000001B2   0xE016             B.N      ??OSSemPend_20
    420          
    421                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    422                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_15: (+1)
   \   000001B4   0x2F00             CMP      R7,#+0
   \   000001B6   0xD004             BEQ.N    ??OSSemPend_23
    423                          *p_ts  =  OSTCBCurPtr->TS;
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   000001BC   0x6800             LDR      R0,[R0, #+0]
   \   000001BE   0x6C00             LDR      R0,[R0, #+64]
   \   000001C0   0x6038             STR      R0,[R7, #+0]
    424                       }
    425                      *p_err = OS_ERR_OBJ_DEL;
   \                     ??OSSemPend_23: (+1)
   \   000001C2   0xF645 0x50C2      MOVW     R0,#+24002
   \   000001C6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    426                       break;
   \   000001CA   0xE00A             B.N      ??OSSemPend_20
    427          
    428                  default:
    429                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSSemPend_18: (+1)
   \   000001CC   0xF646 0x602E      MOVW     R0,#+28206
   \   000001D0   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    430                       CPU_CRITICAL_EXIT();
   \   000001D4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001D8   0x4650             MOV      R0,R10
   \   000001DA   0x.... 0x....      BL       CPU_SR_Restore
    431                       return ((OS_SEM_CTR)0);
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0xE007             B.N      ??OSSemPend_1
    432              }
    433              ctr = p_sem->Ctr;
   \                     ??OSSemPend_20: (+1)
   \   000001E2   0x6A20             LDR      R0,[R4, #+32]
   \   000001E4   0x4681             MOV      R9,R0
    434              CPU_CRITICAL_EXIT();
   \   000001E6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001EA   0x4650             MOV      R0,R10
   \   000001EC   0x.... 0x....      BL       CPU_SR_Restore
    435              return (ctr);
   \   000001F0   0x4648             MOV      R0,R9
   \                     ??OSSemPend_1: (+1)
   \   000001F2   0xB008             ADD      SP,SP,#+32
   \   000001F4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    436          }
    437          
    438          /*$PAGE*/
    439          /*
    440          ************************************************************************************************************************
    441          *                                             ABORT WAITING ON A SEMAPHORE
    442          *
    443          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function should be used
    444          *              to fault-abort the wait on the semaphore, rather than to normally signal the semaphore via OSSemPost().
    445          *
    446          * Arguments  : p_sem     is a pointer to the semaphore
    447          *
    448          *              opt       determines the type of ABORT performed:
    449          *
    450          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the semaphore
    451          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the semaphore
    452          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    453          *
    454          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    455          *
    456          *                            OS_ERR_NONE                  At least one task waiting on the semaphore was readied and
    457          *                                                         informed of the aborted wait; check return value for the
    458          *                                                         number of tasks whose wait on the semaphore was aborted.
    459          *                            OS_ERR_OBJ_PTR_NULL          If 'p_sem' is a NULL pointer.
    460          *                            OS_ERR_OBJ_TYPE              If 'p_sem' is not pointing at a semaphore
    461          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    462          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    463          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    464          *
    465          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    466          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    467          ************************************************************************************************************************
    468          */
    469          
    470          #if OS_CFG_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    471          OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
    472                                      OS_OPT   opt,
    473                                      OS_ERR  *p_err)
    474          {
   \                     OSSemPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    475              OS_PEND_LIST  *p_pend_list;
    476              OS_TCB        *p_tcb;
    477              CPU_TS         ts;
    478              OS_OBJ_QTY     nbr_tasks;
    479              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    480          
    481          
    482          
    483          #ifdef OS_SAFETY_CRITICAL
    484              if (p_err == (OS_ERR *)0) {
    485                  OS_SAFETY_CRITICAL_EXCEPTION();
    486                  return ((OS_OBJ_QTY)0u);
    487              }
    488          #endif
    489          
    490          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    491              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSSemPendAbort_0
    492                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000018   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    493                  return ((OS_OBJ_QTY)0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE07B             B.N      ??OSSemPendAbort_1
    494              }
    495          #endif
    496          
    497          #if OS_CFG_ARG_CHK_EN > 0u
    498              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemPendAbort_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSSemPendAbort_2
    499                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    500                  return ((OS_OBJ_QTY)0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE074             B.N      ??OSSemPendAbort_1
    501              }
    502              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPendAbort_2: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??OSSemPendAbort_3
   \   00000038   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003C   0xD005             BEQ.N    ??OSSemPendAbort_3
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD002             BEQ.N    ??OSSemPendAbort_3
   \   00000044   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000048   0xD105             BNE.N    ??OSSemPendAbort_4
    503                  case OS_OPT_PEND_ABORT_1:
    504                  case OS_OPT_PEND_ABORT_ALL:
    505                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    506                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    507                       break;
    508          
    509                  default:
    510                      *p_err =  OS_ERR_OPT_INVALID;
    511                       return ((OS_OBJ_QTY)0u);
    512              }
    513          #endif
    514          
    515          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    516              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPendAbort_3: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0x414d4553
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD105             BNE.N    ??OSSemPendAbort_5
   \   00000054   0xE009             B.N      ??OSSemPendAbort_6
   \                     ??OSSemPendAbort_4: (+1)
   \   00000056   0xF645 0x6025      MOVW     R0,#+24101
   \   0000005A   0x8030             STRH     R0,[R6, #+0]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE05C             B.N      ??OSSemPendAbort_1
    517                 *p_err =  OS_ERR_OBJ_TYPE;
   \                     ??OSSemPendAbort_5: (+1)
   \   00000060   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000064   0x8030             STRH     R0,[R6, #+0]
    518                  return ((OS_OBJ_QTY)0u);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE057             B.N      ??OSSemPendAbort_1
    519              }
    520          #endif
    521          
    522              CPU_CRITICAL_ENTER();
   \                     ??OSSemPendAbort_6: (+1)
   \   0000006A   0x.... 0x....      BL       CPU_SR_Save
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStart
    523              p_pend_list = &p_sem->PendList;
   \   00000074   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000078   0x0007             MOVS     R7,R0
    524              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
   \   0000007A   0x8938             LDRH     R0,[R7, #+8]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD109             BNE.N    ??OSSemPendAbort_7
    525                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    526                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   0000008A   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000008E   0x8030             STRH     R0,[R6, #+0]
    527                  return ((OS_OBJ_QTY)0u);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE042             B.N      ??OSSemPendAbort_1
    528              }
    529          
    530              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPendAbort_7: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable10_2
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x1C40             ADDS     R0,R0,#+1
   \   0000009A   0x....             LDR.N    R1,??DataTable10_2
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   \   0000009E   0x....             LDR.N    R0,??DataTable10_2
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD101             BNE.N    ??OSSemPendAbort_8
   \   000000A6   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSSemPendAbort_8: (+1)
   \   000000AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AE   0x4658             MOV      R0,R11
   \   000000B0   0x.... 0x....      BL       CPU_SR_Restore
    531              nbr_tasks = 0u;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x4682             MOV      R10,R0
    532              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
   \   000000B8   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000BC   0x4681             MOV      R9,R0
    533              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSSemPendAbort_9: (+1)
   \   000000BE   0x8938             LDRH     R0,[R7, #+8]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD00D             BEQ.N    ??OSSemPendAbort_10
    534                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
   \   000000C4   0x6838             LDR      R0,[R7, #+0]
   \   000000C6   0x6880             LDR      R0,[R0, #+8]
   \   000000C8   0x4680             MOV      R8,R0
    535                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
    536                               p_tcb,
    537                               ts);
   \   000000CA   0x464A             MOV      R2,R9
   \   000000CC   0x4641             MOV      R1,R8
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       OS_PendAbort
    538                  nbr_tasks++;
   \   000000D4   0xF11A 0x0A01      ADDS     R10,R10,#+1
    539                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000D8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000DA   0xF5B5 0x7F80      CMP      R5,#+256
   \   000000DE   0xD0EE             BEQ.N    ??OSSemPendAbort_9
    540                      break;                                          /* No                                                     */
    541                  }
    542              }
    543              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSSemPendAbort_10: (+1)
   \   000000E0   0x.... 0x....      BL       CPU_SR_Save
   \   000000E4   0x4683             MOV      R11,R0
   \   000000E6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000EA   0x....             LDR.N    R0,??DataTable10_2
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x1E40             SUBS     R0,R0,#+1
   \   000000F0   0x....             LDR.N    R1,??DataTable10_2
   \   000000F2   0x7008             STRB     R0,[R1, #+0]
   \   000000F4   0x....             LDR.N    R0,??DataTable10_2
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD101             BNE.N    ??OSSemPendAbort_11
   \   000000FC   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSSemPendAbort_11: (+1)
   \   00000100   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000104   0x4658             MOV      R0,R11
   \   00000106   0x.... 0x....      BL       CPU_SR_Restore
    544          
    545              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   0000010A   0x0428             LSLS     R0,R5,#+16
   \   0000010C   0xD401             BMI.N    ??OSSemPendAbort_12
    546                  OSSched();                                          /* Run the scheduler                                      */
   \   0000010E   0x.... 0x....      BL       OSSched
    547              }
    548          
    549             *p_err = OS_ERR_NONE;
   \                     ??OSSemPendAbort_12: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x8030             STRH     R0,[R6, #+0]
    550              return (nbr_tasks);
   \   00000116   0x4650             MOV      R0,R10
   \   00000118   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemPendAbort_1: (+1)
   \   0000011A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    551          }
    552          #endif
    553          
    554          /*$PAGE*/
    555          /*
    556          ************************************************************************************************************************
    557          *                                                 POST TO A SEMAPHORE
    558          *
    559          * Description: This function signals a semaphore
    560          *
    561          * Arguments  : p_sem    is a pointer to the semaphore
    562          *
    563          *              opt      determines the type of POST performed:
    564          *
    565          *                           OS_OPT_POST_1            POST and ready only the highest priority task waiting on semaphore
    566          *                                                    (if tasks are waiting).
    567          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    568          *
    569          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    570          *
    571          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    572          *
    573          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    574          *
    575          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    576          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    577          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    578          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    579          *
    580          * Returns    : The current value of the semaphore counter or 0 upon error.
    581          ************************************************************************************************************************
    582          */
    583          

   \                                 In section .text, align 2, keep-with-next
    584          OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
    585                                 OS_OPT   opt,
    586                                 OS_ERR  *p_err)
    587          {
   \                     OSSemPost: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    588              OS_SEM_CTR  ctr;
    589              CPU_TS      ts;
    590          
    591          
    592          
    593          #ifdef OS_SAFETY_CRITICAL
    594              if (p_err == (OS_ERR *)0) {
    595                  OS_SAFETY_CRITICAL_EXCEPTION();
    596                  return ((OS_SEM_CTR)0);
    597              }
    598          #endif
    599          
    600          #if OS_CFG_ARG_CHK_EN > 0u
    601              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??OSSemPost_0
    602                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   0000000E   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000012   0x8030             STRH     R0,[R6, #+0]
    603                  return ((OS_SEM_CTR)0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE03B             B.N      ??OSSemPost_1
    604              }
    605              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPost_0: (+1)
   \   00000018   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD008             BEQ.N    ??OSSemPost_2
   \   00000020   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000024   0xD005             BEQ.N    ??OSSemPost_2
   \   00000026   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002A   0xD002             BEQ.N    ??OSSemPost_2
   \   0000002C   0xF5B0 0x4F02      CMP      R0,#+33280
   \   00000030   0xD104             BNE.N    ??OSSemPost_3
    606                  case OS_OPT_POST_1:
    607                  case OS_OPT_POST_ALL:
    608                  case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
    609                  case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    610                       break;
    611          
    612                  default:
    613                      *p_err =  OS_ERR_OPT_INVALID;
    614                       return ((OS_SEM_CTR)0u);
    615              }
    616          #endif
    617          
    618          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    619              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPost_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x....             LDR.N    R1,??DataTable10_3  ;; 0x414d4553
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD105             BNE.N    ??OSSemPost_4
   \   0000003A   0xE009             B.N      ??OSSemPost_5
   \                     ??OSSemPost_3: (+1)
   \   0000003C   0xF645 0x6025      MOVW     R0,#+24101
   \   00000040   0x8030             STRH     R0,[R6, #+0]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE024             B.N      ??OSSemPost_1
    620                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSSemPost_4: (+1)
   \   00000046   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
    621                  return ((OS_SEM_CTR)0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE01F             B.N      ??OSSemPost_1
    622              }
    623          #endif
    624          
    625              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSSemPost_5: (+1)
   \   00000050   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000054   0x4680             MOV      R8,R0
    626          
    627          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    628              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \   00000056   0x....             LDR.N    R0,??DataTable10_1
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD00F             BEQ.N    ??OSSemPost_6
    629                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_SEM,           /* Post to ISR queue                                      */
    630                              (void      *)p_sem,
    631                              (void      *)0,
    632                              (OS_MSG_SIZE)0,
    633                              (OS_FLAGS   )0,
    634                              (OS_OPT     )opt,
    635                              (CPU_TS     )ts,
    636                              (OS_ERR    *)p_err);
   \   0000005E   0x9603             STR      R6,[SP, #+12]
   \   00000060   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0x2300             MOVS     R3,#+0
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x0021             MOVS     R1,R4
   \   00000074   0x....             LDR.N    R0,??DataTable10_3  ;; 0x414d4553
   \   00000076   0x.... 0x....      BL       OS_IntQPost
    637                  return ((OS_SEM_CTR)0);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE008             B.N      ??OSSemPost_1
    638              }
    639          #endif
    640          
    641              ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
    642                               opt,
    643                               ts,
    644                               p_err);
   \                     ??OSSemPost_6: (+1)
   \   0000007E   0x0033             MOVS     R3,R6
   \   00000080   0x4642             MOV      R2,R8
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       OS_SemPost
   \   0000008C   0x0007             MOVS     R7,R0
    645          
    646              return (ctr);
   \   0000008E   0x0038             MOVS     R0,R7
   \                     ??OSSemPost_1: (+1)
   \   00000090   0xB004             ADD      SP,SP,#+16
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    647          }
    648          
    649          /*$PAGE*/
    650          /*
    651          ************************************************************************************************************************
    652          *                                                    SET SEMAPHORE
    653          *
    654          * Description: This function sets the semaphore count to the value specified as an argument.  Typically, this value
    655          *              would be 0 but of course, we can set the semaphore to any value.
    656          *
    657          *              You would typically use this function when a semaphore is used as a signaling mechanism
    658          *              and, you want to reset the count value.
    659          *
    660          * Arguments  : p_sem     is a pointer to the semaphore
    661          *
    662          *              cnt       is the new value for the semaphore count.  You would pass 0 to reset the semaphore count.
    663          *
    664          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    665          *
    666          *                            OS_ERR_NONE           The call was successful and the semaphore value was set.
    667          *                            OS_ERR_OBJ_PTR_NULL   If 'p_sem' is a NULL pointer.
    668          *                            OS_ERR_OBJ_TYPE       If 'p_sem' is not pointing to a semaphore.
    669          *                            OS_ERR_TASK_WAITING   If tasks are waiting on the semaphore.
    670          *
    671          * Returns    : None
    672          ************************************************************************************************************************
    673          */
    674          
    675          #if OS_CFG_SEM_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    676          void  OSSemSet (OS_SEM      *p_sem,
    677                          OS_SEM_CTR   cnt,
    678                          OS_ERR      *p_err)
    679          {
   \                     OSSemSet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    680              OS_PEND_LIST  *p_pend_list;
    681              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    682          
    683          
    684          
    685          #ifdef OS_SAFETY_CRITICAL
    686              if (p_err == (OS_ERR *)0) {
    687                  OS_SAFETY_CRITICAL_EXCEPTION();
    688                  return;
    689              }
    690          #endif
    691          
    692          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    693              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \   0000000E   0x....             LDR.N    R0,??DataTable10_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSSemSet_0
    694                 *p_err = OS_ERR_SET_ISR;
   \   00000016   0xF646 0x50C6      MOVW     R0,#+28102
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    695                  return;
   \   0000001C   0xE029             B.N      ??OSSemSet_1
    696              }
    697          #endif
    698          
    699          #if OS_CFG_ARG_CHK_EN > 0u
    700              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \                     ??OSSemSet_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD103             BNE.N    ??OSSemSet_2
    701                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8030             STRH     R0,[R6, #+0]
    702                  return;
   \   00000028   0xE023             B.N      ??OSSemSet_1
    703              }
    704          #endif
    705          
    706          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    707              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemSet_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable10_3  ;; 0x414d4553
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD003             BEQ.N    ??OSSemSet_3
    708                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000032   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000036   0x8030             STRH     R0,[R6, #+0]
    709                  return;
   \   00000038   0xE01B             B.N      ??OSSemSet_1
    710              }
    711          #endif
    712          
    713             *p_err = OS_ERR_NONE;
   \                     ??OSSemSet_3: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x8030             STRH     R0,[R6, #+0]
    714              CPU_CRITICAL_ENTER();
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x4680             MOV      R8,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
    715              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
   \   00000048   0x6A20             LDR      R0,[R4, #+32]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??OSSemSet_4
    716                  p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
   \   0000004E   0x6225             STR      R5,[R4, #+32]
   \   00000050   0xE00A             B.N      ??OSSemSet_5
    717              } else {
    718                  p_pend_list = &p_sem->PendList;                     /* No                                                     */
   \                     ??OSSemSet_4: (+1)
   \   00000052   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000056   0x0007             MOVS     R7,R0
    719                  if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
   \   00000058   0x8938             LDRH     R0,[R7, #+8]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD101             BNE.N    ??OSSemSet_6
    720                      p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
   \   0000005E   0x6225             STR      R5,[R4, #+32]
   \   00000060   0xE002             B.N      ??OSSemSet_5
    721                  } else {
    722                     *p_err      = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_6: (+1)
   \   00000062   0xF247 0x105F      MOVW     R0,#+29023
   \   00000066   0x8030             STRH     R0,[R6, #+0]
    723                  }
    724              }
    725              CPU_CRITICAL_EXIT();
   \                     ??OSSemSet_5: (+1)
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
    726          }
   \                     ??OSSemSet_1: (+1)
   \   00000072   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    727          #endif
    728          
    729          /*$PAGE*/
    730          /*
    731          ************************************************************************************************************************
    732          *                                           CLEAR THE CONTENTS OF A SEMAPHORE
    733          *
    734          * Description: This function is called by OSSemDel() to clear the contents of a semaphore
    735          *
    736          
    737          * Argument(s): p_sem      is a pointer to the semaphore to clear
    738          *              -----
    739          *
    740          * Returns    : none
    741          *
    742          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    743          ************************************************************************************************************************
    744          */
    745          

   \                                 In section .text, align 2, keep-with-next
    746          void  OS_SemClr (OS_SEM  *p_sem)
    747          {
   \                     OS_SemClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    748              p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
   \   00000004   0x....             LDR.N    R0,??DataTable10_6  ;; 0x454e4f4e
   \   00000006   0x6020             STR      R0,[R4, #+0]
    749              p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6220             STR      R0,[R4, #+32]
    750              p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6260             STR      R0,[R4, #+36]
    751              p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
   \   00000010   0x....             LDR.N    R0,??DataTable10_7
   \   00000012   0x6060             STR      R0,[R4, #+4]
    752              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \   00000014   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000018   0x.... 0x....      BL       OS_PendListInit
    753          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    754          
    755          /*$PAGE*/
    756          /*
    757          ************************************************************************************************************************
    758          *                                        ADD/REMOVE SEMAPHORE TO/FROM DEBUG LIST
    759          *
    760          * Description: These functions are called by uC/OS-III to add or remove a semaphore to/from the debug list.
    761          *
    762          * Arguments  : p_sem     is a pointer to the semaphore to add/remove
    763          *
    764          * Returns    : none
    765          *
    766          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    767          ************************************************************************************************************************
    768          */
    769          
    770          
    771          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    772          void  OS_SemDbgListAdd (OS_SEM  *p_sem)
    773          {
    774              p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_SemDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable10  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    775              p_sem->DbgPrevPtr               = (OS_SEM   *)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    776              if (OSSemDbgListPtr == (OS_SEM *)0) {
   \   00000008   0x....             LDR.N    R1,??DataTable10_8
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_SemDbgListAdd_0
    777                  p_sem->DbgNextPtr           = (OS_SEM   *)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_SemDbgListAdd_1
    778              } else {
    779                  p_sem->DbgNextPtr           =  OSSemDbgListPtr;
   \                     ??OS_SemDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable10_8
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    780                  OSSemDbgListPtr->DbgPrevPtr =  p_sem;
   \   0000001C   0x....             LDR.N    R1,??DataTable10_8
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    781              }
    782              OSSemDbgListPtr                 =  p_sem;
   \                     ??OS_SemDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable10_8
   \   00000024   0x6008             STR      R0,[R1, #+0]
    783          }
   \   00000026   0x4770             BX       LR               ;; return
    784          
    785          
    786          

   \                                 In section .text, align 2, keep-with-next
    787          void  OS_SemDbgListRemove (OS_SEM  *p_sem)
    788          {
    789              OS_SEM  *p_sem_next;
    790              OS_SEM  *p_sem_prev;
    791          
    792          
    793              p_sem_prev = p_sem->DbgPrevPtr;
   \                     OS_SemDbgListRemove: (+1)
   \   00000000   0x6943             LDR      R3,[R0, #+20]
   \   00000002   0x001A             MOVS     R2,R3
    794              p_sem_next = p_sem->DbgNextPtr;
   \   00000004   0x6983             LDR      R3,[R0, #+24]
   \   00000006   0x0019             MOVS     R1,R3
    795          
    796              if (p_sem_prev == (OS_SEM *)0) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??OS_SemDbgListRemove_0
    797                  OSSemDbgListPtr = p_sem_next;
   \   0000000C   0x....             LDR.N    R3,??DataTable10_8
   \   0000000E   0x6019             STR      R1,[R3, #+0]
    798                  if (p_sem_next != (OS_SEM *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??OS_SemDbgListRemove_1
    799                      p_sem_next->DbgPrevPtr = (OS_SEM *)0;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x614B             STR      R3,[R1, #+20]
    800                  }
    801                  p_sem->DbgNextPtr = (OS_SEM *)0;
   \                     ??OS_SemDbgListRemove_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6183             STR      R3,[R0, #+24]
   \   0000001C   0xE00C             B.N      ??OS_SemDbgListRemove_2
    802          
    803              } else if (p_sem_next == (OS_SEM *)0) {
   \                     ??OS_SemDbgListRemove_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_SemDbgListRemove_3
    804                  p_sem_prev->DbgNextPtr = (OS_SEM *)0;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x6193             STR      R3,[R2, #+24]
    805                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x6143             STR      R3,[R0, #+20]
   \   0000002A   0xE005             B.N      ??OS_SemDbgListRemove_2
    806          
    807              } else {
    808                  p_sem_prev->DbgNextPtr =  p_sem_next;
   \                     ??OS_SemDbgListRemove_3: (+1)
   \   0000002C   0x6191             STR      R1,[R2, #+24]
    809                  p_sem_next->DbgPrevPtr =  p_sem_prev;
   \   0000002E   0x614A             STR      R2,[R1, #+20]
    810                  p_sem->DbgNextPtr      = (OS_SEM *)0;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x6183             STR      R3,[R0, #+24]
    811                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x6143             STR      R3,[R0, #+20]
    812              }
    813          }
   \                     ??OS_SemDbgListRemove_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    814          #endif
    815          
    816          /*$PAGE*/
    817          /*
    818          ************************************************************************************************************************
    819          *                                                SEMAPHORE INITIALIZATION
    820          *
    821          * Description: This function is called by OSInit() to initialize the semaphore management.
    822          *
    823          
    824          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
    825          *
    826          *                                OS_ERR_NONE     the call was successful
    827          *
    828          * Returns    : none
    829          *
    830          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    831          ************************************************************************************************************************
    832          */
    833          

   \                                 In section .text, align 2, keep-with-next
    834          void  OS_SemInit (OS_ERR  *p_err)
    835          {
    836          #ifdef OS_SAFETY_CRITICAL
    837              if (p_err == (OS_ERR *)0) {
    838                  OS_SAFETY_CRITICAL_EXCEPTION();
    839                  return;
    840              }
    841          #endif
    842          
    843          #if OS_CFG_DBG_EN > 0u
    844              OSSemDbgListPtr = (OS_SEM *)0;
   \                     OS_SemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable10_8
   \   00000004   0x6011             STR      R1,[R2, #+0]
    845          #endif
    846          
    847              OSSemQty        = (OS_OBJ_QTY)0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable10_4
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    848             *p_err           = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    849          }
   \   00000010   0x4770             BX       LR               ;; return
    850          
    851          /*$PAGE*/
    852          /*
    853          ************************************************************************************************************************
    854          *                                                 POST TO A SEMAPHORE
    855          *
    856          * Description: This function signals a semaphore
    857          *
    858          * Arguments  : p_sem    is a pointer to the semaphore
    859          *
    860          *              opt      determines the type of POST performed:
    861          *
    862          *                           OS_OPT_POST_1            POST to a single waiting task
    863          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    864          *
    865          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    866          *
    867          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    868          *
    869          *              ts       is a timestamp indicating when the post occurred.
    870          *
    871          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    872          *
    873          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    874          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    875          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    876          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    877          *
    878          * Returns    : The current value of the semaphore counter or 0 upon error.
    879          *
    880          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    881          ************************************************************************************************************************
    882          */
    883          

   \                                 In section .text, align 2, keep-with-next
    884          OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
    885                                  OS_OPT   opt,
    886                                  CPU_TS   ts,
    887                                  OS_ERR  *p_err)
    888          {
   \                     OS_SemPost: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    889              OS_OBJ_QTY     cnt;
    890              OS_SEM_CTR     ctr;
    891              OS_PEND_LIST  *p_pend_list;
    892              OS_PEND_DATA  *p_pend_data;
    893              OS_PEND_DATA  *p_pend_data_next;
    894              OS_TCB        *p_tcb;
    895              CPU_SR_ALLOC();
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
    896          
    897          
    898          
    899              CPU_CRITICAL_ENTER();
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   \   00000016   0x4682             MOV      R10,R0
   \   00000018   0x.... 0x....      BL       CPU_IntDisMeasStart
    900              p_pend_list = &p_sem->PendList;
   \   0000001C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000020   0x9001             STR      R0,[SP, #+4]
    901              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on semaphore?                         */
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0x8900             LDRH     R0,[R0, #+8]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD11C             BNE.N    ??OS_SemPost_0
    902                  switch (sizeof(OS_SEM_CTR)) {
    903                      case 1u:
    904                           if (p_sem->Ctr == DEF_INT_08U_MAX_VAL) {
    905                               CPU_CRITICAL_EXIT();
    906                              *p_err = OS_ERR_SEM_OVF;
    907                               return ((OS_SEM_CTR)0);
    908                           }
    909                           break;
    910          
    911                      case 2u:
    912                           if (p_sem->Ctr == DEF_INT_16U_MAX_VAL) {
    913                               CPU_CRITICAL_EXIT();
    914                              *p_err = OS_ERR_SEM_OVF;
    915                               return ((OS_SEM_CTR)0);
    916                           }
    917                           break;
    918          
    919                      case 4u:
    920                           if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
   \   0000002A   0x6A20             LDR      R0,[R4, #+32]
   \   0000002C   0xF110 0x0F01      CMN      R0,#+1
   \   00000030   0xD109             BNE.N    ??OS_SemPost_1
    921                               CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000036   0x4650             MOV      R0,R10
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
    922                              *p_err = OS_ERR_SEM_OVF;
   \   0000003C   0xF646 0x50C5      MOVW     R0,#+28101
   \   00000040   0x8038             STRH     R0,[R7, #+0]
    923                               return ((OS_SEM_CTR)0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE05E             B.N      ??OS_SemPost_2
    924                           }
    925                           break;
    926          
    927                      default:
    928                           break;
    929                  }
    930                  p_sem->Ctr++;                                       /* No                                                     */
   \                     ??OS_SemPost_1: (+1)
   \   00000046   0x6A20             LDR      R0,[R4, #+32]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0x6220             STR      R0,[R4, #+32]
    931                  ctr       = p_sem->Ctr;
   \   0000004C   0x6A20             LDR      R0,[R4, #+32]
   \   0000004E   0x4683             MOV      R11,R0
    932                  p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
   \   00000050   0x6266             STR      R6,[R4, #+36]
    933                  CPU_CRITICAL_EXIT();
   \   00000052   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000056   0x4650             MOV      R0,R10
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    934                 *p_err     = OS_ERR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8038             STRH     R0,[R7, #+0]
    935                  return (ctr);
   \   00000060   0x4658             MOV      R0,R11
   \   00000062   0xE04F             B.N      ??OS_SemPost_2
    936              }
    937          
    938              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OS_SemPost_0: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable10_2
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable10_2
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
   \   0000006E   0x....             LDR.N    R0,??DataTable10_2
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD101             BNE.N    ??OS_SemPost_3
   \   00000076   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_SemPost_3: (+1)
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007E   0x4650             MOV      R0,R10
   \   00000080   0x.... 0x....      BL       CPU_SR_Restore
    939              if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
   \   00000084   0x05A8             LSLS     R0,R5,#+22
   \   00000086   0xD503             BPL.N    ??OS_SemPost_4
    940                  cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
   \   00000088   0x9801             LDR      R0,[SP, #+4]
   \   0000008A   0x8900             LDRH     R0,[R0, #+8]
   \   0000008C   0x4680             MOV      R8,R0
   \   0000008E   0xE001             B.N      ??OS_SemPost_5
    941              } else {
    942                  cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
   \                     ??OS_SemPost_4: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x4680             MOV      R8,R0
    943              }
    944              p_pend_data = p_pend_list->HeadPtr;
   \                     ??OS_SemPost_5: (+1)
   \   00000094   0x9801             LDR      R0,[SP, #+4]
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x4681             MOV      R9,R0
    945              while (cnt > 0u) {
   \                     ??OS_SemPost_6: (+1)
   \   0000009A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000009E   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A2   0xD011             BEQ.N    ??OS_SemPost_7
    946                  p_tcb            = p_pend_data->TCBPtr;
   \   000000A4   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   000000A8   0x9002             STR      R0,[SP, #+8]
    947                  p_pend_data_next = p_pend_data->NextPtr;
   \   000000AA   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   000000AE   0x9003             STR      R0,[SP, #+12]
    948                  OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    949                          p_tcb,
    950                          (void      *)0,
    951                          (OS_MSG_SIZE)0,
    952                          ts);
   \   000000B0   0x9600             STR      R6,[SP, #+0]
   \   000000B2   0x2300             MOVS     R3,#+0
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x9902             LDR      R1,[SP, #+8]
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       OS_Post
    953                  p_pend_data = p_pend_data_next;
   \   000000BE   0x9803             LDR      R0,[SP, #+12]
   \   000000C0   0x4681             MOV      R9,R0
    954                  cnt--;
   \   000000C2   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000C6   0xE7E8             B.N      ??OS_SemPost_6
    955              }
    956              ctr = p_sem->Ctr;
   \                     ??OS_SemPost_7: (+1)
   \   000000C8   0x6A20             LDR      R0,[R4, #+32]
   \   000000CA   0x4683             MOV      R11,R0
    957              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000CC   0x.... 0x....      BL       CPU_SR_Save
   \   000000D0   0x4682             MOV      R10,R0
   \   000000D2   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000D6   0x....             LDR.N    R0,??DataTable10_2
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x1E40             SUBS     R0,R0,#+1
   \   000000DC   0x....             LDR.N    R1,??DataTable10_2
   \   000000DE   0x7008             STRB     R0,[R1, #+0]
   \   000000E0   0x....             LDR.N    R0,??DataTable10_2
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD101             BNE.N    ??OS_SemPost_8
   \   000000E8   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_SemPost_8: (+1)
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F0   0x4650             MOV      R0,R10
   \   000000F2   0x.... 0x....      BL       CPU_SR_Restore
    958              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   000000F6   0x0428             LSLS     R0,R5,#+16
   \   000000F8   0xD401             BMI.N    ??OS_SemPost_9
    959                  OSSched();                                          /* Run the scheduler                                      */
   \   000000FA   0x.... 0x....      BL       OSSched
    960              }
    961             *p_err = OS_ERR_NONE;
   \                     ??OS_SemPost_9: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x8038             STRH     R0,[R7, #+0]
    962              return (ctr);
   \   00000102   0x4658             MOV      R0,R11
   \                     ??OS_SemPost_2: (+1)
   \   00000104   0xB005             ADD      SP,SP,#+20
   \   00000106   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    963          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     OSSemDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x53          DC8 "?SEM"
   \              0x45 0x4D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
    964          
    965          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSSemCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_PendListInit
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
        24   -> OS_SemDbgListAdd
      48   OSSemDel
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_TS_TmrRd
        48   -> OSSched
        48   -> OS_PendObjDel
        48   -> OS_SchedLockTimeMeasStart
        48   -> OS_SchedLockTimeMeasStop
        48   -> OS_SemClr
        48   -> OS_SemDbgListRemove
      64   OSSemPend
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OS_Pend
        64   -> OS_SchedLockTimeMeasStart
        64   -> OS_SchedLockTimeMeasStop
      40   OSSemPendAbort
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_PendAbort
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
      40   OSSemPost
        40   -> CPU_TS_TmrRd
        40   -> OS_IntQPost
        40   -> OS_SemPost
      24   OSSemSet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       8   OS_SemClr
         8   -> OS_PendListInit
       0   OS_SemDbgListAdd
       0   OS_SemDbgListRemove
       0   OS_SemInit
      56   OS_SemPost
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> OSSched
        56   -> OS_Post
        56   -> OS_SchedLockTimeMeasStart
        56   -> OS_SchedLockTimeMeasStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       8  ?_0
       2  ?_1
     192  OSSemCreate
     382  OSSemDel
     504  OSSemPend
     286  OSSemPendAbort
     150  OSSemPost
     118  OSSemSet
      30  OS_SemClr
      40  OS_SemDbgListAdd
      58  OS_SemDbgListRemove
      18  OS_SemInit
     266  OS_SemPost

 
    10 bytes in section .rodata
 2 080 bytes in section .text
 
 2 080 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
