###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_time.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_time.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_time.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_time.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_time.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIME MANAGEMENT
     10          *
     11          * File    : OS_TIME.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_time__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                  DELAY TASK 'n' TICKS
     43          *
     44          * Description: This function is called to delay execution of the currently running task until the specified number of
     45          *              system ticks expires.  This, of course, directly equates to delaying the current task for some time to
     46          *              expire.  No delay will result if the specified delay is 0.  If the specified delay is greater than 0
     47          *              then, a context switch will result.
     48          *
     49          * Arguments  : dly       is a value in 'clock ticks' that the task will either delay for or, the target match value
     50          *                        of the tick counter (OSTickCtr).  Note that specifying 0 means the task is not to delay.
     51          *
     52          *                        depending on the option argument, the task will wake up when OSTickCtr reaches:
     53          *
     54          *                            OS_OPT_TIME_DLY      : OSTickCtr + dly
     55          *                            OS_OPT_TIME_TIMEOUT  : OSTickCtr + dly
     56          *                            OS_OPT_TIME_MATCH    : dly
     57          *                            OS_OPT_TIME_PERIODIC : OSTCBCurPtr->TickCtrPrev + dly
     58          *
     59          *              opt       specifies whether 'dly' represents absolute or relative time; default option marked with *** :
     60          *
     61          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
     62          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
     63          *                            OS_OPT_TIME_MATCH      indicates that 'dly' specifies the absolute value that OSTickCtr
     64          *                                                   must reach before the task will be resumed.
     65          *                            OS_OPT_TIME_PERIODIC   indicates that 'dly' specifies the periodic value that OSTickCtr
     66          *                                                   must reach before the task will be resumed.
     67          *
     68          *              p_err     is a pointer to a variable that will contain an error code from this call.
     69          *
     70          *                            OS_ERR_NONE            the call was successful and the delay occurred.
     71          *                            OS_ERR_OPT_INVALID     if you specified an invalid option for this function.
     72          *                            OS_ERR_SCHED_LOCKED    can't delay when the scheduler is locked.
     73          *                            OS_ERR_TIME_DLY_ISR    if you called this function from an ISR.
     74          *                            OS_ERR_TIME_ZERO_DLY   if you specified a delay of zero.
     75          *
     76          * Returns    : none
     77          ************************************************************************************************************************
     78          */
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void  OSTimeDly (OS_TICK   dly,
     81                           OS_OPT    opt,
     82                           OS_ERR   *p_err)
     83          {
   \                     OSTimeDly: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     84              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
     85          
     86          
     87          
     88          #ifdef OS_SAFETY_CRITICAL
     89              if (p_err == (OS_ERR *)0) {
     90                  OS_SAFETY_CRITICAL_EXCEPTION();
     91                  return;
     92              }
     93          #endif
     94          
     95          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     96              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSTimeDly_0
     97                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000014   0xF247 0x2075      MOVW     R0,#+29301
   \   00000018   0x8030             STRH     R0,[R6, #+0]
     98                  return;
   \   0000001A   0xE082             B.N      ??OSTimeDly_1
     99              }
    100          #endif
    101          
    102              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
   \                     ??OSTimeDly_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSTimeDly_2
    103                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000026   0xF646 0x5063      MOVW     R0,#+28003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    104                  return;
   \   0000002C   0xE079             B.N      ??OSTimeDly_1
    105              }
    106          
    107              switch (opt) {
   \                     ??OSTimeDly_2: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD005             BEQ.N    ??OSTimeDly_3
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD003             BEQ.N    ??OSTimeDly_3
   \   0000003A   0x2804             CMP      R0,#+4
   \   0000003C   0xD008             BEQ.N    ??OSTimeDly_4
   \   0000003E   0x2808             CMP      R0,#+8
   \   00000040   0xD107             BNE.N    ??OSTimeDly_5
    108                  case OS_OPT_TIME_DLY:
    109                  case OS_OPT_TIME_TIMEOUT:
    110                  case OS_OPT_TIME_PERIODIC:
    111                       if (dly == (OS_TICK)0u) {                      /* 0 means no delay!                                      */
   \                     ??OSTimeDly_3: (+1)
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD103             BNE.N    ??OSTimeDly_6
    112                          *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000046   0xF247 0x207E      MOVW     R0,#+29310
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
    113                           return;
   \   0000004C   0xE069             B.N      ??OSTimeDly_1
    114                       }
    115                       break;
   \                     ??OSTimeDly_6: (+1)
   \   0000004E   0xE004             B.N      ??OSTimeDly_7
    116          
    117                  case OS_OPT_TIME_MATCH:
    118                       break;
   \                     ??OSTimeDly_4: (+1)
   \   00000050   0xE003             B.N      ??OSTimeDly_7
    119          
    120                  default:
    121                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDly_5: (+1)
   \   00000052   0xF645 0x6025      MOVW     R0,#+24101
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    122                       return;
   \   00000058   0xE063             B.N      ??OSTimeDly_1
    123              }
    124          
    125              OS_CRITICAL_ENTER();
   \                     ??OSTimeDly_7: (+1)
   \   0000005A   0x.... 0x....      BL       CPU_SR_Save
   \   0000005E   0x0007             MOVS     R7,R0
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD101             BNE.N    ??OSTimeDly_8
   \   0000007C   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTimeDly_8: (+1)
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    126              OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0xF881 0x0036      STRB     R0,[R1, #+54]
    127              OS_TickListInsert(OSTCBCurPtr,
    128                                dly,
    129                                opt,
    130                                p_err);
   \   00000096   0x0033             MOVS     R3,R6
   \   00000098   0x002A             MOVS     R2,R5
   \   0000009A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000009C   0x0021             MOVS     R1,R4
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x.... 0x....      BL       OS_TickListInsert
    131              if (*p_err != OS_ERR_NONE) {
   \   000000A8   0x8830             LDRH     R0,[R6, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD018             BEQ.N    ??OSTimeDly_9
    132                   OS_CRITICAL_EXIT_NO_SCHED();
   \   000000AE   0x.... 0x....      BL       CPU_SR_Save
   \   000000B2   0x0007             MOVS     R7,R0
   \   000000B4   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x1E40             SUBS     R0,R0,#+1
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD101             BNE.N    ??OSTimeDly_10
   \   000000D0   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTimeDly_10: (+1)
   \   000000D4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D8   0x0038             MOVS     R0,R7
   \   000000DA   0x.... 0x....      BL       CPU_SR_Restore
    133                   return;
   \   000000DE   0xE020             B.N      ??OSTimeDly_1
    134              }
    135              OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                    */
   \                     ??OSTimeDly_9: (+1)
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x.... 0x....      BL       OS_RdyListRemove
    136              OS_CRITICAL_EXIT_NO_SCHED();
   \   000000EA   0x.... 0x....      BL       CPU_SR_Save
   \   000000EE   0x0007             MOVS     R7,R0
   \   000000F0   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   000000F8   0x7800             LDRB     R0,[R0, #+0]
   \   000000FA   0x1E40             SUBS     R0,R0,#+1
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   00000100   0x7008             STRB     R0,[R1, #+0]
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD101             BNE.N    ??OSTimeDly_11
   \   0000010C   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTimeDly_11: (+1)
   \   00000110   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000114   0x0038             MOVS     R0,R7
   \   00000116   0x.... 0x....      BL       CPU_SR_Restore
    137              OSSched();                                              /* Find next task to run!                                 */
   \   0000011A   0x.... 0x....      BL       OSSched
    138             *p_err = OS_ERR_NONE;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x8030             STRH     R0,[R6, #+0]
    139          }
   \                     ??OSTimeDly_1: (+1)
   \   00000122   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    140          
    141          /*$PAGE*/
    142          /*
    143          ************************************************************************************************************************
    144          *                                             DELAY TASK FOR SPECIFIED TIME
    145          *
    146          * Description: This function is called to delay execution of the currently running task until some time expires.  This
    147          *              call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
    148          *
    149          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 999 if the tick rate is
    150          *                        1000 Hz or less otherwise, a higher value would overflow a 32-bit unsigned counter).
    151          *
    152          *              minutes   specifies the number of minutes (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    153          *
    154          *              seconds   specifies the number of seconds (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    155          *
    156          *              milli     specifies the number of milliseconds (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    157          *
    158          *              opt       specifies time delay bit-field options logically OR'd; default options marked with *** :
    159          *
    160          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
    161          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
    162          *                            OS_OPT_TIME_MATCH      indicates that the delay specifies the absolute value that OSTickCtr
    163          *                                                   must reach before the task will be resumed.
    164          *                            OS_OPT_TIME_PERIODIC   indicates that the delay specifies the periodic value that OSTickCtr
    165          *                                                   must reach before the task will be resumed.
    166          *
    167          *                        *** OS_OPT_TIME_HMSM_STRICT            strictly allow only hours        (0...99)
    168          *                                                                                   minutes      (0...59)
    169          *                                                                                   seconds      (0...59)
    170          *                                                                                   milliseconds (0...999)
    171          *                            OS_OPT_TIME_HMSM_NON_STRICT        allow any value of  hours        (0...999)
    172          *                                                                                   minutes      (0...9999)
    173          *                                                                                   seconds      (0...65535)
    174          *                                                                                   milliseconds (0...4294967295)
    175          *
    176          *              p_err     is a pointer to a variable that will receive an error code from this call.
    177          *
    178          *                            OS_ERR_NONE                        If the function returns from the desired delay
    179          *                            OS_ERR_OPT_INVALID                 If you specified an invalid option for 'opt'
    180          *                            OS_ERR_SCHED_LOCKED                Can't delay when the scheduler is locked
    181          *                            OS_ERR_TIME_DLY_ISR                If called from an ISR
    182          *                            OS_ERR_TIME_INVALID_HOURS          If you didn't specify a valid value for 'hours'
    183          *                            OS_ERR_TIME_INVALID_MINUTES        If you didn't specify a valid value for 'minutes'
    184          *                            OS_ERR_TIME_INVALID_SECONDS        If you didn't specify a valid value for 'seconds'
    185          *                            OS_ERR_TIME_INVALID_MILLISECONDS   If you didn't specify a valid value for 'milli'
    186          *                            OS_ERR_TIME_ZERO_DLY               If hours, minutes, seconds and milli are all 0
    187          *
    188          * Returns    : none
    189          *
    190          * Note(s)    : 1) The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay
    191          *                 if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay
    192          *                 is rounded to the nearest tick.
    193          *
    194          *              2) Although this function allows you to delay a task for many, many hours, it's not recommended to put
    195          *                 a task to sleep for that long.
    196          ************************************************************************************************************************
    197          */
    198          
    199          #if OS_CFG_TIME_DLY_HMSM_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    200          void  OSTimeDlyHMSM (CPU_INT16U   hours,
    201                               CPU_INT16U   minutes,
    202                               CPU_INT16U   seconds,
    203                               CPU_INT32U   milli,
    204                               OS_OPT       opt,
    205                               OS_ERR      *p_err)
    206          {
   \                     OSTimeDlyHMSM: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4693             MOV      R11,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C0C             LDR      R4,[SP, #+48]
   \   0000000E   0xF8DD 0x8034      LDR      R8,[SP, #+52]
    207          #if OS_CFG_ARG_CHK_EN > 0u
    208              CPU_BOOLEAN  opt_invalid;
    209              CPU_BOOLEAN  opt_non_strict;
    210          #endif
    211              OS_OPT       opt_time;
    212              OS_RATE_HZ   tick_rate;
    213              OS_TICK      ticks;
    214              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0A00      MOVS     R10,#+0
    215          
    216          
    217          
    218          #ifdef OS_SAFETY_CRITICAL
    219              if (p_err == (OS_ERR *)0) {
    220                  OS_SAFETY_CRITICAL_EXCEPTION();
    221                  return;
    222              }
    223          #endif
    224          
    225          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    226              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??OSTimeDlyHMSM_0
    227                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000020   0xF247 0x2075      MOVW     R0,#+29301
   \   00000024   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    228                  return;
   \   00000028   0xE106             B.N      ??OSTimeDlyHMSM_1
    229              }
    230          #endif
    231          
    232              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
   \                     ??OSTimeDlyHMSM_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD004             BEQ.N    ??OSTimeDlyHMSM_2
    233                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000034   0xF646 0x5063      MOVW     R0,#+28003
   \   00000038   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    234                  return;
   \   0000003C   0xE0FC             B.N      ??OSTimeDlyHMSM_1
    235              }
    236          
    237              opt_time = opt & OS_OPT_TIME_MASK;                      /* Retrieve time options only.                            */
   \                     ??OSTimeDlyHMSM_2: (+1)
   \   0000003E   0xF014 0x000E      ANDS     R0,R4,#0xE
   \   00000042   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    238              switch (opt_time) {
   \   00000046   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD005             BEQ.N    ??OSTimeDlyHMSM_3
   \   0000004E   0x2802             CMP      R0,#+2
   \   00000050   0xD003             BEQ.N    ??OSTimeDlyHMSM_3
   \   00000052   0x2804             CMP      R0,#+4
   \   00000054   0xD014             BEQ.N    ??OSTimeDlyHMSM_4
   \   00000056   0x2808             CMP      R0,#+8
   \   00000058   0xD113             BNE.N    ??OSTimeDlyHMSM_5
    239                  case OS_OPT_TIME_DLY:
    240                  case OS_OPT_TIME_TIMEOUT:
    241                  case OS_OPT_TIME_PERIODIC:
    242                       if (milli == (CPU_INT32U)0u) {                 /* Make sure we didn't specify a 0 delay                  */
   \                     ??OSTimeDlyHMSM_3: (+1)
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD10F             BNE.N    ??OSTimeDlyHMSM_6
    243                           if (seconds == (CPU_INT16U)0u) {
   \   0000005E   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000062   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000066   0xD10A             BNE.N    ??OSTimeDlyHMSM_6
    244                               if (minutes == (CPU_INT16U)0u) {
   \   00000068   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD107             BNE.N    ??OSTimeDlyHMSM_6
    245                                   if (hours == (CPU_INT16U)0u) {
   \   0000006E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD104             BNE.N    ??OSTimeDlyHMSM_6
    246                                      *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000074   0xF247 0x207E      MOVW     R0,#+29310
   \   00000078   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    247                                       return;
   \   0000007C   0xE0DC             B.N      ??OSTimeDlyHMSM_1
    248                                   }
    249                               }
    250                           }
    251                       }
    252                       break;
   \                     ??OSTimeDlyHMSM_6: (+1)
   \   0000007E   0xE005             B.N      ??OSTimeDlyHMSM_7
    253          
    254                  case OS_OPT_TIME_MATCH:
    255                       break;
   \                     ??OSTimeDlyHMSM_4: (+1)
   \   00000080   0xE004             B.N      ??OSTimeDlyHMSM_7
    256          
    257                  default:
    258                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDlyHMSM_5: (+1)
   \   00000082   0xF645 0x6025      MOVW     R0,#+24101
   \   00000086   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    259                       return;
   \   0000008A   0xE0D5             B.N      ??OSTimeDlyHMSM_1
    260              }
    261          
    262          #if OS_CFG_ARG_CHK_EN > 0u                                  /* Validate arguments to be within range                  */
    263              opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
   \                     ??OSTimeDlyHMSM_7: (+1)
   \   0000008C   0xF64F 0x71E1      MOVW     R1,#+65505
   \   00000090   0x420C             TST      R4,R1
   \   00000092   0xD102             BNE.N    ??OSTimeDlyHMSM_8
   \   00000094   0xF05F 0x0900      MOVS     R9,#+0
   \   00000098   0xE001             B.N      ??OSTimeDlyHMSM_9
   \                     ??OSTimeDlyHMSM_8: (+1)
   \   0000009A   0xF05F 0x0901      MOVS     R9,#+1
    264              if (opt_invalid == DEF_YES) {
   \                     ??OSTimeDlyHMSM_9: (+1)
   \   0000009E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A2   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000A6   0xD104             BNE.N    ??OSTimeDlyHMSM_10
    265                 *p_err = OS_ERR_OPT_INVALID;
   \   000000A8   0xF645 0x6025      MOVW     R0,#+24101
   \   000000AC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    266                  return;
   \   000000B0   0xE0C2             B.N      ??OSTimeDlyHMSM_1
    267              }
    268          
    269              opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
   \                     ??OSTimeDlyHMSM_10: (+1)
   \   000000B2   0xF3C4 0x1000      UBFX     R0,R4,#+4,#+1
   \   000000B6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000BC   0xF88D 0x0002      STRB     R0,[SP, #+2]
    270              if (opt_non_strict != DEF_YES) {
   \   000000C0   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xD021             BEQ.N    ??OSTimeDlyHMSM_11
    271                   if (milli   > (CPU_INT32U)999u) {
   \   000000C8   0xF5B7 0x7F7A      CMP      R7,#+1000
   \   000000CC   0xD304             BCC.N    ??OSTimeDlyHMSM_12
    272                      *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
   \   000000CE   0xF247 0x207B      MOVW     R0,#+29307
   \   000000D2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    273                       return;
   \   000000D6   0xE0AF             B.N      ??OSTimeDlyHMSM_1
    274                   }
    275                   if (seconds > (CPU_INT16U)59u) {
   \                     ??OSTimeDlyHMSM_12: (+1)
   \   000000D8   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000DC   0xF1BB 0x0F3C      CMP      R11,#+60
   \   000000E0   0xDB04             BLT.N    ??OSTimeDlyHMSM_13
    276                      *p_err = OS_ERR_TIME_INVALID_SECONDS;
   \   000000E2   0xF247 0x207A      MOVW     R0,#+29306
   \   000000E6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    277                       return;
   \   000000EA   0xE0A5             B.N      ??OSTimeDlyHMSM_1
    278                   }
    279                   if (minutes > (CPU_INT16U)59u) {
   \                     ??OSTimeDlyHMSM_13: (+1)
   \   000000EC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000EE   0x2E3C             CMP      R6,#+60
   \   000000F0   0xDB04             BLT.N    ??OSTimeDlyHMSM_14
    280                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   000000F2   0xF247 0x2079      MOVW     R0,#+29305
   \   000000F6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    281                       return;
   \   000000FA   0xE09D             B.N      ??OSTimeDlyHMSM_1
    282                   }
    283                   if (hours   > (CPU_INT16U)99u) {
   \                     ??OSTimeDlyHMSM_14: (+1)
   \   000000FC   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000FE   0x2D64             CMP      R5,#+100
   \   00000100   0xDB17             BLT.N    ??OSTimeDlyHMSM_15
    284                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   00000102   0xF247 0x2078      MOVW     R0,#+29304
   \   00000106   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    285                       return;
   \   0000010A   0xE095             B.N      ??OSTimeDlyHMSM_1
    286                   }
    287              } else {
    288                   if (minutes > (CPU_INT16U)9999u) {
   \                     ??OSTimeDlyHMSM_11: (+1)
   \   0000010C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000010E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000112   0x4286             CMP      R6,R0
   \   00000114   0xDB04             BLT.N    ??OSTimeDlyHMSM_16
    289                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   00000116   0xF247 0x2079      MOVW     R0,#+29305
   \   0000011A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    290                       return;
   \   0000011E   0xE08B             B.N      ??OSTimeDlyHMSM_1
    291                   }
    292                   if (hours   > (CPU_INT16U)999u) {
   \                     ??OSTimeDlyHMSM_16: (+1)
   \   00000120   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000122   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   00000126   0xDB04             BLT.N    ??OSTimeDlyHMSM_15
    293                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   00000128   0xF247 0x2078      MOVW     R0,#+29304
   \   0000012C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    294                       return;
   \   00000130   0xE082             B.N      ??OSTimeDlyHMSM_1
    295                   }
    296              }
    297          #endif
    298          
    299                                                                      /* Compute the total number of clock ticks required..     */
    300                                                                      /* .. (rounded to the nearest tick)                       */
    301              tick_rate = OSCfg_TickRate_Hz;
   \                     ??OSTimeDlyHMSM_15: (+1)
   \   00000132   0x....             LDR.N    R0,??DataTable5_3
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x9001             STR      R0,[SP, #+4]
    302              ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
    303                        + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;
   \   00000138   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000013A   0xF44F 0x6061      MOV      R0,#+3600
   \   0000013E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000140   0x213C             MOVS     R1,#+60
   \   00000142   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000146   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000014A   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000014E   0xEB1B 0x0000      ADDS     R0,R11,R0
   \   00000152   0x9901             LDR      R1,[SP, #+4]
   \   00000154   0x9A01             LDR      R2,[SP, #+4]
   \   00000156   0xF44F 0x73FA      MOV      R3,#+500
   \   0000015A   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \   0000015E   0xFBB3 0xF3FC      UDIV     R3,R3,R12
   \   00000162   0x19DB             ADDS     R3,R3,R7
   \   00000164   0x435A             MULS     R2,R3,R2
   \   00000166   0xF44F 0x737A      MOV      R3,#+1000
   \   0000016A   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000016E   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000172   0x9002             STR      R0,[SP, #+8]
    304          
    305              if (ticks > (OS_TICK)0u) {
   \   00000174   0x9802             LDR      R0,[SP, #+8]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD05A             BEQ.N    ??OSTimeDlyHMSM_17
    306                  OS_CRITICAL_ENTER();
   \   0000017A   0x.... 0x....      BL       CPU_SR_Save
   \   0000017E   0x4682             MOV      R10,R0
   \   00000180   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000184   0x....             LDR.N    R0,??DataTable5_1
   \   00000186   0x7800             LDRB     R0,[R0, #+0]
   \   00000188   0x1C40             ADDS     R0,R0,#+1
   \   0000018A   0x....             LDR.N    R1,??DataTable5_1
   \   0000018C   0x7008             STRB     R0,[R1, #+0]
   \   0000018E   0x....             LDR.N    R0,??DataTable5_1
   \   00000190   0x7800             LDRB     R0,[R0, #+0]
   \   00000192   0x2801             CMP      R0,#+1
   \   00000194   0xD101             BNE.N    ??OSTimeDlyHMSM_18
   \   00000196   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTimeDlyHMSM_18: (+1)
   \   0000019A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000019E   0x4650             MOV      R0,R10
   \   000001A0   0x.... 0x....      BL       CPU_SR_Restore
    307                  OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0x....             LDR.N    R1,??DataTable5_2
   \   000001A8   0x6809             LDR      R1,[R1, #+0]
   \   000001AA   0xF881 0x0036      STRB     R0,[R1, #+54]
    308                  OS_TickListInsert(OSTCBCurPtr,
    309                                    ticks,
    310                                    opt_time,
    311                                    p_err);
   \   000001AE   0x4643             MOV      R3,R8
   \   000001B0   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   000001B4   0x9902             LDR      R1,[SP, #+8]
   \   000001B6   0x....             LDR.N    R0,??DataTable5_2
   \   000001B8   0x6800             LDR      R0,[R0, #+0]
   \   000001BA   0x.... 0x....      BL       OS_TickListInsert
    312                  if (*p_err != OS_ERR_NONE) {
   \   000001BE   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD015             BEQ.N    ??OSTimeDlyHMSM_19
    313                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000001C6   0x.... 0x....      BL       CPU_SR_Save
   \   000001CA   0x4682             MOV      R10,R0
   \   000001CC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001D0   0x....             LDR.N    R0,??DataTable5_1
   \   000001D2   0x7800             LDRB     R0,[R0, #+0]
   \   000001D4   0x1E40             SUBS     R0,R0,#+1
   \   000001D6   0x....             LDR.N    R1,??DataTable5_1
   \   000001D8   0x7008             STRB     R0,[R1, #+0]
   \   000001DA   0x....             LDR.N    R0,??DataTable5_1
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x2800             CMP      R0,#+0
   \   000001E0   0xD101             BNE.N    ??OSTimeDlyHMSM_20
   \   000001E2   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTimeDlyHMSM_20: (+1)
   \   000001E6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001EA   0x4650             MOV      R0,R10
   \   000001EC   0x.... 0x....      BL       CPU_SR_Restore
    314                       return;
   \   000001F0   0xE022             B.N      ??OSTimeDlyHMSM_1
    315                  }
    316                  OS_RdyListRemove(OSTCBCurPtr);                      /* Remove current task from ready list                    */
   \                     ??OSTimeDlyHMSM_19: (+1)
   \   000001F2   0x....             LDR.N    R0,??DataTable5_2
   \   000001F4   0x6800             LDR      R0,[R0, #+0]
   \   000001F6   0x.... 0x....      BL       OS_RdyListRemove
    317                  OS_CRITICAL_EXIT_NO_SCHED();
   \   000001FA   0x.... 0x....      BL       CPU_SR_Save
   \   000001FE   0x4682             MOV      R10,R0
   \   00000200   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000204   0x....             LDR.N    R0,??DataTable5_1
   \   00000206   0x7800             LDRB     R0,[R0, #+0]
   \   00000208   0x1E40             SUBS     R0,R0,#+1
   \   0000020A   0x....             LDR.N    R1,??DataTable5_1
   \   0000020C   0x7008             STRB     R0,[R1, #+0]
   \   0000020E   0x....             LDR.N    R0,??DataTable5_1
   \   00000210   0x7800             LDRB     R0,[R0, #+0]
   \   00000212   0x2800             CMP      R0,#+0
   \   00000214   0xD101             BNE.N    ??OSTimeDlyHMSM_21
   \   00000216   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTimeDlyHMSM_21: (+1)
   \   0000021A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000021E   0x4650             MOV      R0,R10
   \   00000220   0x.... 0x....      BL       CPU_SR_Restore
    318                  OSSched();                                          /* Find next task to run!                                 */
   \   00000224   0x.... 0x....      BL       OSSched
    319                 *p_err = OS_ERR_NONE;
   \   00000228   0x2000             MOVS     R0,#+0
   \   0000022A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000022E   0xE003             B.N      ??OSTimeDlyHMSM_22
    320              } else {
    321                 *p_err = OS_ERR_TIME_ZERO_DLY;
   \                     ??OSTimeDlyHMSM_17: (+1)
   \   00000230   0xF247 0x207E      MOVW     R0,#+29310
   \   00000234   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    322              }
    323          }
   \                     ??OSTimeDlyHMSM_22: (+1)
   \                     ??OSTimeDlyHMSM_1: (+1)
   \   00000238   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    324          #endif
    325          /*$PAGE*/
    326          /*
    327          ************************************************************************************************************************
    328          *                                                RESUME A DELAYED TASK
    329          *
    330          * Description: This function is used resume a task that has been delayed through a call to either OSTimeDly() or
    331          *              OSTimeDlyHMSM().  Note that cannot call this function to resume a task that is waiting for an event
    332          *              with timeout.
    333          *
    334          * Arguments  : p_tcb    is a pointer to the TCB of the task to resume.
    335          *
    336          *              p_err    is a pointer to a variable that will receive an error code
    337          *
    338          *                           OS_ERR_NONE                  Task has been resumed
    339          *                           OS_ERR_STATE_INVALID         Task is in an invalid state
    340          *                           OS_ERR_TIME_DLY_RESUME_ISR   If called from an ISR
    341          *                           OS_ERR_TIME_NOT_DLY          Task is not waiting for time to expire
    342          *                           OS_ERR_TASK_SUSPENDED        Task cannot be resumed, it was suspended by OSTaskSuspend()
    343          *
    344          * Note(s)    : none
    345          ************************************************************************************************************************
    346          */
    347          
    348          #if OS_CFG_TIME_DLY_RESUME_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    349          void  OSTimeDlyResume (OS_TCB  *p_tcb,
    350                                 OS_ERR  *p_err)
    351          {
   \                     OSTimeDlyResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    352              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    353          
    354          
    355          
    356          #ifdef OS_SAFETY_CRITICAL
    357              if (p_err == (OS_ERR *)0) {
    358                  OS_SAFETY_CRITICAL_EXCEPTION();
    359                  return;
    360              }
    361          #endif
    362          
    363          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    364              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTimeDlyResume_0
    365                 *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
   \   00000010   0xF247 0x2076      MOVW     R0,#+29302
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    366                  return;
   \   00000016   0xE0C9             B.N      ??OSTimeDlyResume_1
    367              }
    368          #endif
    369          
    370          #if OS_CFG_ARG_CHK_EN > 0u
    371              if (p_tcb == (OS_TCB *)0) {                             /* Not possible for the running task to be delayed!       */
   \                     ??OSTimeDlyResume_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD103             BNE.N    ??OSTimeDlyResume_2
    372                 *p_err = OS_ERR_TASK_NOT_DLY;
   \   0000001C   0xF247 0x1051      MOVW     R0,#+29009
   \   00000020   0x8028             STRH     R0,[R5, #+0]
    373                  return;
   \   00000022   0xE0C3             B.N      ??OSTimeDlyResume_1
    374              }
    375          #endif
    376          
    377              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDlyResume_2: (+1)
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
    378              if (p_tcb == OSTCBCurPtr) {                             /* Not possible for the running task to be delayed!       */
   \   0000002E   0x....             LDR.N    R0,??DataTable5_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD108             BNE.N    ??OSTimeDlyResume_3
    379                 *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000036   0xF247 0x1051      MOVW     R0,#+29009
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    380                  CPU_CRITICAL_EXIT();
   \   0000003C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
    381                  return;
   \   00000046   0xE0B1             B.N      ??OSTimeDlyResume_1
    382              }
    383          
    384              switch (p_tcb->TaskState) {
   \                     ??OSTimeDlyResume_3: (+1)
   \   00000048   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD00D             BEQ.N    ??OSTimeDlyResume_4
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD045             BEQ.N    ??OSTimeDlyResume_5
   \   00000054   0xD313             BCC.N    ??OSTimeDlyResume_6
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD054             BEQ.N    ??OSTimeDlyResume_7
   \   0000005A   0xD34A             BCC.N    ??OSTimeDlyResume_8
   \   0000005C   0x2806             CMP      R0,#+6
   \   0000005E   0xF000 0x8089      BEQ.W    ??OSTimeDlyResume_9
   \   00000062   0xD358             BCC.N    ??OSTimeDlyResume_10
   \   00000064   0x2807             CMP      R0,#+7
   \   00000066   0xF000 0x808E      BEQ.W    ??OSTimeDlyResume_11
   \   0000006A   0xE095             B.N      ??OSTimeDlyResume_12
    385                  case OS_TASK_STATE_RDY:                             /* Cannot Abort delay if task is ready                    */
    386                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_4: (+1)
   \   0000006C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    387                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000076   0xF247 0x1051      MOVW     R0,#+29009
   \   0000007A   0x8028             STRH     R0,[R5, #+0]
    388                       break;
   \   0000007C   0xE094             B.N      ??OSTimeDlyResume_13
    389          
    390                  case OS_TASK_STATE_DLY:
    391                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTimeDlyResume_6: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable5_1
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x....             LDR.N    R1,??DataTable5_1
   \   00000086   0x7008             STRB     R0,[R1, #+0]
   \   00000088   0x....             LDR.N    R0,??DataTable5_1
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD101             BNE.N    ??OSTimeDlyResume_14
   \   00000090   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTimeDlyResume_14: (+1)
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
    392                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x0036      STRB     R0,[R4, #+54]
    393                       OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       OS_TickListRemove
    394                       OS_RdyListInsert(p_tcb);                       /* Add to ready list                                      */
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       OS_RdyListInsert
    395                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000000B0   0x.... 0x....      BL       CPU_SR_Save
   \   000000B4   0x0006             MOVS     R6,R0
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000BA   0x....             LDR.N    R0,??DataTable5_1
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x1E40             SUBS     R0,R0,#+1
   \   000000C0   0x....             LDR.N    R1,??DataTable5_1
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
   \   000000C4   0x....             LDR.N    R0,??DataTable5_1
   \   000000C6   0x7800             LDRB     R0,[R0, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD101             BNE.N    ??OSTimeDlyResume_15
   \   000000CC   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTimeDlyResume_15: (+1)
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x0030             MOVS     R0,R6
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
    396                      *p_err = OS_ERR_NONE;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x8028             STRH     R0,[R5, #+0]
    397                       break;
   \   000000DE   0xE063             B.N      ??OSTimeDlyResume_13
    398          
    399                  case OS_TASK_STATE_PEND:
    400                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_5: (+1)
   \   000000E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E4   0x0030             MOVS     R0,R6
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
    401                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   000000EA   0xF247 0x1051      MOVW     R0,#+29009
   \   000000EE   0x8028             STRH     R0,[R5, #+0]
    402                       break;
   \   000000F0   0xE05A             B.N      ??OSTimeDlyResume_13
    403          
    404                  case OS_TASK_STATE_PEND_TIMEOUT:
    405                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_8: (+1)
   \   000000F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F6   0x0030             MOVS     R0,R6
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
    406                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   000000FC   0xF247 0x1051      MOVW     R0,#+29009
   \   00000100   0x8028             STRH     R0,[R5, #+0]
    407                       break;
   \   00000102   0xE051             B.N      ??OSTimeDlyResume_13
    408          
    409                  case OS_TASK_STATE_SUSPENDED:
    410                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_7: (+1)
   \   00000104   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000108   0x0030             MOVS     R0,R6
   \   0000010A   0x.... 0x....      BL       CPU_SR_Restore
    411                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   0000010E   0xF247 0x1051      MOVW     R0,#+29009
   \   00000112   0x8028             STRH     R0,[R5, #+0]
    412                       break;
   \   00000114   0xE048             B.N      ??OSTimeDlyResume_13
    413          
    414                  case OS_TASK_STATE_DLY_SUSPENDED:
    415                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTimeDlyResume_10: (+1)
   \   00000116   0x....             LDR.N    R0,??DataTable5_1
   \   00000118   0x7800             LDRB     R0,[R0, #+0]
   \   0000011A   0x1C40             ADDS     R0,R0,#+1
   \   0000011C   0x....             LDR.N    R1,??DataTable5_1
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
   \   00000120   0x....             LDR.N    R0,??DataTable5_1
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x2801             CMP      R0,#+1
   \   00000126   0xD101             BNE.N    ??OSTimeDlyResume_16
   \   00000128   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSTimeDlyResume_16: (+1)
   \   0000012C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000130   0x0030             MOVS     R0,R6
   \   00000132   0x.... 0x....      BL       CPU_SR_Restore
    416                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \   00000136   0x2004             MOVS     R0,#+4
   \   00000138   0xF884 0x0036      STRB     R0,[R4, #+54]
    417                       OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0x.... 0x....      BL       OS_TickListRemove
    418                       OS_CRITICAL_EXIT_NO_SCHED();
   \   00000142   0x.... 0x....      BL       CPU_SR_Save
   \   00000146   0x0006             MOVS     R6,R0
   \   00000148   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000014C   0x....             LDR.N    R0,??DataTable5_1
   \   0000014E   0x7800             LDRB     R0,[R0, #+0]
   \   00000150   0x1E40             SUBS     R0,R0,#+1
   \   00000152   0x....             LDR.N    R1,??DataTable5_1
   \   00000154   0x7008             STRB     R0,[R1, #+0]
   \   00000156   0x....             LDR.N    R0,??DataTable5_1
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD101             BNE.N    ??OSTimeDlyResume_17
   \   0000015E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSTimeDlyResume_17: (+1)
   \   00000162   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000166   0x0030             MOVS     R0,R6
   \   00000168   0x.... 0x....      BL       CPU_SR_Restore
    419                      *p_err            = OS_ERR_TASK_SUSPENDED;
   \   0000016C   0xF247 0x105A      MOVW     R0,#+29018
   \   00000170   0x8028             STRH     R0,[R5, #+0]
    420                       break;
   \   00000172   0xE019             B.N      ??OSTimeDlyResume_13
    421          
    422                  case OS_TASK_STATE_PEND_SUSPENDED:
    423                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_9: (+1)
   \   00000174   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000178   0x0030             MOVS     R0,R6
   \   0000017A   0x.... 0x....      BL       CPU_SR_Restore
    424                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   0000017E   0xF247 0x1051      MOVW     R0,#+29009
   \   00000182   0x8028             STRH     R0,[R5, #+0]
    425                       break;
   \   00000184   0xE010             B.N      ??OSTimeDlyResume_13
    426          
    427                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    428                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_11: (+1)
   \   00000186   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000018A   0x0030             MOVS     R0,R6
   \   0000018C   0x.... 0x....      BL       CPU_SR_Restore
    429                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000190   0xF247 0x1051      MOVW     R0,#+29009
   \   00000194   0x8028             STRH     R0,[R5, #+0]
    430                       break;
   \   00000196   0xE007             B.N      ??OSTimeDlyResume_13
    431          
    432                  default:
    433                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_12: (+1)
   \   00000198   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000019C   0x0030             MOVS     R0,R6
   \   0000019E   0x.... 0x....      BL       CPU_SR_Restore
    434                      *p_err = OS_ERR_STATE_INVALID;
   \   000001A2   0xF646 0x602D      MOVW     R0,#+28205
   \   000001A6   0x8028             STRH     R0,[R5, #+0]
    435                       break;
    436              }
    437          
    438              OSSched();
   \                     ??OSTimeDlyResume_13: (+1)
   \   000001A8   0x.... 0x....      BL       OSSched
    439          }
   \                     ??OSTimeDlyResume_1: (+1)
   \   000001AC   0xBD70             POP      {R4-R6,PC}       ;; return
    440          #endif
    441          /*$PAGE*/
    442          /*
    443          ************************************************************************************************************************
    444          *                                               GET CURRENT SYSTEM TIME
    445          *
    446          * Description: This function is used by your application to obtain the current value of the counter which keeps track of
    447          *              the number of clock ticks.
    448          *
    449          * Arguments  : p_err    is a pointer to a variable that will receive an error code
    450          *
    451          *                           OS_ERR_NONE           If the call was successful
    452          *
    453          * Returns    : The current value of OSTickCtr
    454          ************************************************************************************************************************
    455          */
    456          

   \                                 In section .text, align 2, keep-with-next
    457          OS_TICK  OSTimeGet (OS_ERR  *p_err)
    458          {
   \                     OSTimeGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    459              OS_TICK  ticks;
    460              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    461          
    462          
    463          
    464          #ifdef OS_SAFETY_CRITICAL
    465              if (p_err == (OS_ERR *)0) {
    466                  OS_SAFETY_CRITICAL_EXCEPTION();
    467                  return ((OS_TICK)0);
    468              }
    469          #endif
    470          
    471              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    472              ticks = OSTickCtr;
   \   00000010   0x....             LDR.N    R0,??DataTable5_4
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x0005             MOVS     R5,R0
    473              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    474             *p_err = OS_ERR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8020             STRH     R0,[R4, #+0]
    475              return (ticks);
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    476          }
    477          
    478          /*
    479          ************************************************************************************************************************
    480          *                                                   SET SYSTEM CLOCK
    481          *
    482          * Description: This function sets the counter which keeps track of the number of clock ticks.
    483          *
    484          * Arguments  : ticks    is the desired tick value
    485          *
    486          *              p_err    is a pointer to a variable that will receive an error code
    487          *
    488          *                           OS_ERR_NONE           If the call was successful
    489          *
    490          * Returns    : none
    491          ************************************************************************************************************************
    492          */
    493          

   \                                 In section .text, align 2, keep-with-next
    494          void  OSTimeSet (OS_TICK   ticks,
    495                           OS_ERR   *p_err)
    496          {
   \                     OSTimeSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    497              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    498          
    499          
    500          
    501          #ifdef OS_SAFETY_CRITICAL
    502              if (p_err == (OS_ERR *)0) {
    503                  OS_SAFETY_CRITICAL_EXCEPTION();
    504                  return;
    505              }
    506          #endif
    507          
    508              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    509              OSTickCtr = ticks;
   \   00000012   0x....             LDR.N    R0,??DataTable5_4
   \   00000014   0x6004             STR      R4,[R0, #+0]
    510              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    511             *p_err     = OS_ERR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    512          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    513          
    514          /*$PAGE*/
    515          /*
    516          ************************************************************************************************************************
    517          *                                                 PROCESS SYSTEM TICK
    518          *
    519          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    520          *              'clock tick').  This function should be called by the tick ISR.
    521          *
    522          * Arguments  : none
    523          *
    524          * Returns    : none
    525          ************************************************************************************************************************
    526          */
    527          

   \                                 In section .text, align 2, keep-with-next
    528          void  OSTimeTick (void)
    529          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    530              OS_ERR  err;
    531          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    532              CPU_TS  ts;
    533          #endif
    534          
    535          
    536              OSTimeTickHook();                                       /* Call user definable hook                               */
   \   00000004   0x.... 0x....      BL       OSTimeTickHook
    537          
    538          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    539          
    540              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \   00000008   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000000C   0x0004             MOVS     R4,R0
    541              OS_IntQPost((OS_OBJ_TYPE) OS_OBJ_TYPE_TICK,             /* Post to ISR queue                                      */
    542                          (void      *)&OSRdyList[OSPrioCur],
    543                          (void      *) 0,
    544                          (OS_MSG_SIZE) 0u,
    545                          (OS_FLAGS   ) 0u,
    546                          (OS_OPT     ) 0u,
    547                          (CPU_TS     ) ts,
    548                          (OS_ERR    *)&err);
   \   0000000E   0xA804             ADD      R0,SP,#+16
   \   00000010   0x9003             STR      R0,[SP, #+12]
   \   00000012   0x9402             STR      R4,[SP, #+8]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x....             LDR.N    R0,??DataTable5_5
   \   00000022   0x....             LDR.N    R1,??DataTable5_6
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x250C             MOVS     R5,#+12
   \   00000028   0xFB05 0x0101      MLA      R1,R5,R1,R0
   \   0000002C   0x....             LDR.N    R0,??DataTable5_7  ;; 0x4b434954
   \   0000002E   0x.... 0x....      BL       OS_IntQPost
    549          
    550          #else
    551          
    552             (void)OSTaskSemPost((OS_TCB *)&OSTickTaskTCB,            /* Signal tick task                                       */
    553                                 (OS_OPT  ) OS_OPT_POST_NONE,
    554                                 (OS_ERR *)&err);
    555          
    556          
    557          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    558              OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
    559          #endif
    560          
    561          #if OS_CFG_TMR_EN > 0u
    562              OSTmrUpdateCtr--;
    563              if (OSTmrUpdateCtr == (OS_CTR)0u) {
    564                  OSTmrUpdateCtr = OSTmrUpdateCnt;
    565                  OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
    566                                (OS_OPT  ) OS_OPT_POST_NONE,
    567                                (OS_ERR *)&err);
    568              }
    569          #endif
    570          
    571          #endif
    572          }
   \   00000032   0xB005             ADD      SP,SP,#+20
   \   00000034   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4B434954         DC32     0x4b434954

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTimeDly
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
        24   -> OS_TickListInsert
      48   OSTimeDlyHMSM
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OS_RdyListRemove
        48   -> OS_SchedLockTimeMeasStart
        48   -> OS_SchedLockTimeMeasStop
        48   -> OS_TickListInsert
      16   OSTimeDlyResume
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListInsert
        16   -> OS_SchedLockTimeMeasStart
        16   -> OS_SchedLockTimeMeasStop
        16   -> OS_TickListRemove
      16   OSTimeGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTimeSet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      32   OSTimeTick
        32   -> CPU_TS_TmrRd
        32   -> OSTimeTickHook
        32   -> OS_IntQPost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
     292  OSTimeDly
     572  OSTimeDlyHMSM
     430  OSTimeDlyResume
      40  OSTimeGet
      38  OSTimeSet
      54  OSTimeTick

 
 1 458 bytes in section .text
 
 1 458 bytes of CODE memory

Errors: none
Warnings: none
