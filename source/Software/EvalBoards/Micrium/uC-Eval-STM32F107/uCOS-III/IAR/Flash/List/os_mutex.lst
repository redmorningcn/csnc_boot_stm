###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_mutex.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_mutex.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_mutex.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_mutex.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_mutex.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   MUTEX MANAGEMENT
     10          *
     11          * File    : OS_MUTEX.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_mutex__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_MUTEX_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                                   CREATE A MUTEX
     45          *
     46          * Description: This function creates a mutex.
     47          *
     48          * Arguments  : p_mutex       is a pointer to the mutex to initialize.  Your application is responsible for allocating
     49          *                            storage for the mutex.
     50          *
     51          *              p_name        is a pointer to the name you would like to give the mutex.
     52          *
     53          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     54          *
     55          *                                OS_ERR_NONE                    if the call was successful
     56          *                                OS_ERR_CREATE_ISR              if you called this function from an ISR
     57          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the Mutex after you called
     58          *                                                                 OSSafetyCriticalStart().
     59          *                                OS_ERR_NAME                    if 'p_name'  is a NULL pointer
     60          *                                OS_ERR_OBJ_CREATED             if the mutex has already been created
     61          *                                OS_ERR_OBJ_PTR_NULL            if 'p_mutex' is a NULL pointer
     62          *
     63          * Returns    : none
     64          ************************************************************************************************************************
     65          */
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void  OSMutexCreate (OS_MUTEX  *p_mutex,
     68                               CPU_CHAR  *p_name,
     69                               OS_ERR    *p_err)
     70          {
   \                     OSMutexCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     71              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
     72          
     73          
     74          
     75          #ifdef OS_SAFETY_CRITICAL
     76              if (p_err == (OS_ERR *)0) {
     77                  OS_SAFETY_CRITICAL_EXCEPTION();
     78                  return;
     79              }
     80          #endif
     81          
     82          #ifdef OS_SAFETY_CRITICAL_IEC61508
     83              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     84                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     85                  return;
     86              }
     87          #endif
     88          
     89          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     90              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSMutexCreate_0
     91                 *p_err = OS_ERR_CREATE_ISR;
   \   00000014   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000018   0x8030             STRH     R0,[R6, #+0]
     92                  return;
   \   0000001A   0xE053             B.N      ??OSMutexCreate_1
     93              }
     94          #endif
     95          
     96          #if OS_CFG_ARG_CHK_EN > 0u
     97              if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
   \                     ??OSMutexCreate_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD103             BNE.N    ??OSMutexCreate_2
     98                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8030             STRH     R0,[R6, #+0]
     99                  return;
   \   00000026   0xE04D             B.N      ??OSMutexCreate_1
    100              }
    101          #endif
    102          
    103              OS_CRITICAL_ENTER();
   \                     ??OSMutexCreate_2: (+1)
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE.N    ??OSMutexCreate_3
   \   0000004A   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSMutexCreate_3: (+1)
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
    104              p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x5854554d
   \   0000005C   0x6020             STR      R0,[R4, #+0]
    105              p_mutex->NamePtr           =  p_name;
   \   0000005E   0x6065             STR      R5,[R4, #+4]
    106              p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6220             STR      R0,[R4, #+32]
    107              p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x0025      STRB     R0,[R4, #+37]
    108              p_mutex->TS                = (CPU_TS        )0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x62A0             STR      R0,[R4, #+40]
    109              p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
   \   0000006E   0x2020             MOVS     R0,#+32
   \   00000070   0xF884 0x0024      STRB     R0,[R4, #+36]
    110              OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
   \   00000074   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000078   0x.... 0x....      BL       OS_PendListInit
    111          
    112          #if OS_CFG_DBG_EN > 0u
    113              OS_MutexDbgListAdd(p_mutex);
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       OS_MutexDbgListAdd
    114          #endif
    115              OSMutexQty++;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000086   0x8800             LDRH     R0,[R0, #+0]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   0000008E   0x8008             STRH     R0,[R1, #+0]
    116          
    117              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000090   0x.... 0x....      BL       CPU_SR_Save
   \   00000094   0x0007             MOVS     R7,R0
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x1E40             SUBS     R0,R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD101             BNE.N    ??OSMutexCreate_4
   \   000000B2   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSMutexCreate_4: (+1)
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    118             *p_err = OS_ERR_NONE;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x8030             STRH     R0,[R6, #+0]
    119          }
   \                     ??OSMutexCreate_1: (+1)
   \   000000C4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    120          
    121          /*$PAGE*/
    122          /*
    123          ************************************************************************************************************************
    124          *                                                   DELETE A MUTEX
    125          *
    126          * Description: This function deletes a mutex and readies all tasks pending on the mutex.
    127          *
    128          * Arguments  : p_mutex       is a pointer to the mutex to delete
    129          *
    130          *              opt           determines delete options as follows:
    131          *
    132          *                                OS_OPT_DEL_NO_PEND          Delete mutex ONLY if no task pending
    133          *                                OS_OPT_DEL_ALWAYS           Deletes the mutex even if tasks are waiting.
    134          *                                                            In this case, all the tasks pending will be readied.
    135          *
    136          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    137          *
    138          *                                OS_ERR_NONE                 The call was successful and the mutex was deleted
    139          *                                OS_ERR_DEL_ISR              If you attempted to delete the mutex from an ISR
    140          *                                OS_ERR_OBJ_PTR_NULL         If 'p_mutex' is a NULL pointer.
    141          *                                OS_ERR_OBJ_TYPE             If 'p_mutex' is not pointing to a mutex
    142          *                                OS_ERR_OPT_INVALID          An invalid option was specified
    143          *                                OS_ERR_STATE_INVALID        Task is in an invalid state
    144          *                                OS_ERR_TASK_WAITING         One or more tasks were waiting on the mutex
    145          *
    146          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    147          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    148          *
    149          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the mutex MUST
    150          *                 check the return code of OSMutexPend().
    151          *
    152          *              2) OSMutexAccept() callers will not know that the intended mutex has been deleted.
    153          *
    154          *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful in applications where the
    155          *                 mutex is used for mutual exclusion because the resource(s) will no longer be guarded by the mutex.
    156          ************************************************************************************************************************
    157          */
    158          
    159          #if OS_CFG_MUTEX_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    160          OS_OBJ_QTY  OSMutexDel (OS_MUTEX  *p_mutex,
    161                                  OS_OPT     opt,
    162                                  OS_ERR    *p_err)
    163          {
   \                     OSMutexDel: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    164              OS_OBJ_QTY     cnt;
    165              OS_OBJ_QTY     nbr_tasks;
    166              OS_PEND_DATA  *p_pend_data;
    167              OS_PEND_LIST  *p_pend_list;
    168              OS_TCB        *p_tcb;
    169              OS_TCB        *p_tcb_owner;
    170              CPU_TS         ts;
    171              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    172          
    173          
    174          
    175          #ifdef OS_SAFETY_CRITICAL
    176              if (p_err == (OS_ERR *)0) {
    177                  OS_SAFETY_CRITICAL_EXCEPTION();
    178                  return ((OS_OBJ_QTY)0);
    179              }
    180          #endif
    181          
    182          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    183              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                  /* Not allowed to delete a mutex from an ISR          */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSMutexDel_0
    184                 *p_err = OS_ERR_DEL_ISR;
   \   00000018   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    185                  return ((OS_OBJ_QTY)0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE181             B.N      ??OSMutexDel_1
    186              }
    187          #endif
    188          
    189          #if OS_CFG_ARG_CHK_EN > 0u
    190              if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                 */
   \                     ??OSMutexDel_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSMutexDel_2
    191                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    192                  return ((OS_OBJ_QTY)0);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE17A             B.N      ??OSMutexDel_1
    193              }
    194              switch (opt) {                                              /* Validate 'opt'                                     */
   \                     ??OSMutexDel_2: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD805             BHI.N    ??OSMutexDel_3
    195                  case OS_OPT_DEL_NO_PEND:
    196                  case OS_OPT_DEL_ALWAYS:
    197                       break;
    198          
    199                  default:
    200                      *p_err =  OS_ERR_OPT_INVALID;
    201                       return ((OS_OBJ_QTY)0);
    202              }
    203          #endif
    204          
    205          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    206              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                        */
   \                     ??OSMutexDel_4: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x5854554d
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD105             BNE.N    ??OSMutexDel_5
   \   00000044   0xE009             B.N      ??OSMutexDel_6
   \                     ??OSMutexDel_3: (+1)
   \   00000046   0xF645 0x6025      MOVW     R0,#+24101
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE16A             B.N      ??OSMutexDel_1
    207                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSMutexDel_5: (+1)
   \   00000050   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000054   0x8030             STRH     R0,[R6, #+0]
    208                  return ((OS_OBJ_QTY)0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE165             B.N      ??OSMutexDel_1
    209              }
    210          #endif
    211          
    212              OS_CRITICAL_ENTER();
   \                     ??OSMutexDel_6: (+1)
   \   0000005A   0x.... 0x....      BL       CPU_SR_Save
   \   0000005E   0x4683             MOV      R11,R0
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD101             BNE.N    ??OSMutexDel_7
   \   0000007C   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSMutexDel_7: (+1)
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    213              p_pend_list = &p_mutex->PendList;
   \   0000008A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000008E   0x9000             STR      R0,[SP, #+0]
    214              cnt         = p_pend_list->NbrEntries;
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x8900             LDRH     R0,[R0, #+8]
   \   00000094   0x0007             MOVS     R7,R0
    215              nbr_tasks   = cnt;
   \   00000096   0x46B8             MOV      R8,R7
    216              switch (opt) {
   \   00000098   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009A   0x2D00             CMP      R5,#+0
   \   0000009C   0xD002             BEQ.N    ??OSMutexDel_8
   \   0000009E   0x2D01             CMP      R5,#+1
   \   000000A0   0xD06F             BEQ.N    ??OSMutexDel_9
   \   000000A2   0xE110             B.N      ??OSMutexDel_10
    217                  case OS_OPT_DEL_NO_PEND:                                /* Delete mutex only if no task waiting               */
    218                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSMutexDel_8: (+1)
   \   000000A4   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000A8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AC   0xD13A             BNE.N    ??OSMutexDel_11
    219          #if OS_CFG_DBG_EN > 0u
    220                           OS_MutexDbgListRemove(p_mutex);
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       OS_MutexDbgListRemove
    221          #endif
    222                           OSMutexQty--;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000000B8   0x8800             LDRH     R0,[R0, #+0]
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   000000C0   0x8008             STRH     R0,[R1, #+0]
    223                           OS_MutexClr(p_mutex);
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       OS_MutexClr
    224                           OS_CRITICAL_EXIT();
   \   000000C8   0x.... 0x....      BL       CPU_SR_Save
   \   000000CC   0x4683             MOV      R11,R0
   \   000000CE   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0x1E40             SUBS     R0,R0,#+1
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000000DE   0x7008             STRB     R0,[R1, #+0]
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD114             BNE.N    ??OSMutexDel_12
   \   000000EA   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   000000F2   0x8800             LDRH     R0,[R0, #+0]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD007             BEQ.N    ??OSMutexDel_13
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x4658             MOV      R0,R11
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
   \   00000102   0x.... 0x....      BL       OS_Sched0
   \   00000106   0xE00A             B.N      ??OSMutexDel_14
   \                     ??OSMutexDel_13: (+1)
   \   00000108   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010C   0x4658             MOV      R0,R11
   \   0000010E   0x.... 0x....      BL       CPU_SR_Restore
   \   00000112   0xE004             B.N      ??OSMutexDel_14
   \                     ??OSMutexDel_12: (+1)
   \   00000114   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000118   0x4658             MOV      R0,R11
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
    225                          *p_err = OS_ERR_NONE;
   \                     ??OSMutexDel_14: (+1)
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x8030             STRH     R0,[R6, #+0]
   \   00000122   0xE02D             B.N      ??OSMutexDel_15
    226                       } else {
    227                           OS_CRITICAL_EXIT();
   \                     ??OSMutexDel_11: (+1)
   \   00000124   0x.... 0x....      BL       CPU_SR_Save
   \   00000128   0x4683             MOV      R11,R0
   \   0000012A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x1E40             SUBS     R0,R0,#+1
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000140   0x7800             LDRB     R0,[R0, #+0]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD114             BNE.N    ??OSMutexDel_16
   \   00000146   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   0000014E   0x8800             LDRH     R0,[R0, #+0]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD007             BEQ.N    ??OSMutexDel_17
   \   00000154   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000158   0x4658             MOV      R0,R11
   \   0000015A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000015E   0x.... 0x....      BL       OS_Sched0
   \   00000162   0xE00A             B.N      ??OSMutexDel_18
   \                     ??OSMutexDel_17: (+1)
   \   00000164   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000168   0x4658             MOV      R0,R11
   \   0000016A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000016E   0xE004             B.N      ??OSMutexDel_18
   \                     ??OSMutexDel_16: (+1)
   \   00000170   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000174   0x4658             MOV      R0,R11
   \   00000176   0x.... 0x....      BL       CPU_SR_Restore
    228                          *p_err = OS_ERR_TASK_WAITING;
   \                     ??OSMutexDel_18: (+1)
   \   0000017A   0xF247 0x105F      MOVW     R0,#+29023
   \   0000017E   0x8030             STRH     R0,[R6, #+0]
    229                       }
    230                       break;
   \                     ??OSMutexDel_15: (+1)
   \   00000180   0xE0CF             B.N      ??OSMutexDel_19
    231          
    232                  case OS_OPT_DEL_ALWAYS:                                            /* Always delete the mutex                 */
    233                       p_tcb_owner = p_mutex->OwnerTCBPtr;                           /* Did we had to change the prio of owner? */
   \                     ??OSMutexDel_9: (+1)
   \   00000182   0x6A20             LDR      R0,[R4, #+32]
   \   00000184   0x4682             MOV      R10,R0
    234                       if ((p_tcb_owner       != (OS_TCB *)0) &&
    235                           (p_tcb_owner->Prio !=  p_mutex->OwnerOriginalPrio)) {
   \   00000186   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000018A   0xD05F             BEQ.N    ??OSMutexDel_20
   \   0000018C   0xF89A 0x0037      LDRB     R0,[R10, #+55]
   \   00000190   0xF894 0x1024      LDRB     R1,[R4, #+36]
   \   00000194   0x4288             CMP      R0,R1
   \   00000196   0xD059             BEQ.N    ??OSMutexDel_20
    236                           switch (p_tcb_owner->TaskState) {                         /* yes                                     */
   \   00000198   0xF89A 0x0036      LDRB     R0,[R10, #+54]
   \   0000019C   0x2800             CMP      R0,#+0
   \   0000019E   0xD00B             BEQ.N    ??OSMutexDel_21
   \   000001A0   0x2802             CMP      R0,#+2
   \   000001A2   0xD01D             BEQ.N    ??OSMutexDel_22
   \   000001A4   0xD317             BCC.N    ??OSMutexDel_23
   \   000001A6   0x2804             CMP      R0,#+4
   \   000001A8   0xD015             BEQ.N    ??OSMutexDel_23
   \   000001AA   0xD319             BCC.N    ??OSMutexDel_22
   \   000001AC   0x2806             CMP      R0,#+6
   \   000001AE   0xD017             BEQ.N    ??OSMutexDel_22
   \   000001B0   0xD311             BCC.N    ??OSMutexDel_23
   \   000001B2   0x2807             CMP      R0,#+7
   \   000001B4   0xD014             BEQ.N    ??OSMutexDel_22
   \   000001B6   0xE019             B.N      ??OSMutexDel_24
    237                               case OS_TASK_STATE_RDY:
    238                                    OS_RdyListRemove(p_tcb_owner);
   \                     ??OSMutexDel_21: (+1)
   \   000001B8   0x4650             MOV      R0,R10
   \   000001BA   0x.... 0x....      BL       OS_RdyListRemove
    239                                    p_tcb_owner->Prio = p_mutex->OwnerOriginalPrio;  /* Lower owner's prio back                 */
   \   000001BE   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   000001C2   0xF88A 0x0037      STRB     R0,[R10, #+55]
    240                                    OS_PrioInsert(p_tcb_owner->Prio);
   \   000001C6   0xF89A 0x0037      LDRB     R0,[R10, #+55]
   \   000001CA   0x.... 0x....      BL       OS_PrioInsert
    241                                    OS_RdyListInsertTail(p_tcb_owner);               /* Insert owner in ready list at new prio  */
   \   000001CE   0x4650             MOV      R0,R10
   \   000001D0   0x.... 0x....      BL       OS_RdyListInsertTail
    242                                    break;
   \   000001D4   0xE03A             B.N      ??OSMutexDel_20
    243          
    244                               case OS_TASK_STATE_DLY:
    245                               case OS_TASK_STATE_SUSPENDED:
    246                               case OS_TASK_STATE_DLY_SUSPENDED:
    247                                    p_tcb_owner->Prio = p_mutex->OwnerOriginalPrio;  /* Not in any pend list, change the prio   */
   \                     ??OSMutexDel_23: (+1)
   \   000001D6   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   000001DA   0xF88A 0x0037      STRB     R0,[R10, #+55]
    248                                    break;
   \   000001DE   0xE035             B.N      ??OSMutexDel_20
    249          
    250                               case OS_TASK_STATE_PEND:
    251                               case OS_TASK_STATE_PEND_TIMEOUT:
    252                               case OS_TASK_STATE_PEND_SUSPENDED:
    253                               case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    254                                    OS_PendListChangePrio(p_tcb_owner,               /* Owner is pending on another object      */
    255                                                          p_mutex->OwnerOriginalPrio);
   \                     ??OSMutexDel_22: (+1)
   \   000001E0   0xF894 0x1024      LDRB     R1,[R4, #+36]
   \   000001E4   0x4650             MOV      R0,R10
   \   000001E6   0x.... 0x....      BL       OS_PendListChangePrio
    256                                    break;
   \   000001EA   0xE02F             B.N      ??OSMutexDel_20
    257          
    258                               default:
    259                                    OS_CRITICAL_EXIT();
   \                     ??OSMutexDel_24: (+1)
   \   000001EC   0x.... 0x....      BL       CPU_SR_Save
   \   000001F0   0x4683             MOV      R11,R0
   \   000001F2   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
   \   000001FC   0x1E40             SUBS     R0,R0,#+1
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   00000202   0x7008             STRB     R0,[R1, #+0]
   \   00000204   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000208   0x7800             LDRB     R0,[R0, #+0]
   \   0000020A   0x2800             CMP      R0,#+0
   \   0000020C   0xD114             BNE.N    ??OSMutexDel_25
   \   0000020E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   00000216   0x8800             LDRH     R0,[R0, #+0]
   \   00000218   0x2800             CMP      R0,#+0
   \   0000021A   0xD007             BEQ.N    ??OSMutexDel_26
   \   0000021C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000220   0x4658             MOV      R0,R11
   \   00000222   0x.... 0x....      BL       CPU_SR_Restore
   \   00000226   0x.... 0x....      BL       OS_Sched0
   \   0000022A   0xE00A             B.N      ??OSMutexDel_27
   \                     ??OSMutexDel_26: (+1)
   \   0000022C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000230   0x4658             MOV      R0,R11
   \   00000232   0x.... 0x....      BL       CPU_SR_Restore
   \   00000236   0xE004             B.N      ??OSMutexDel_27
   \                     ??OSMutexDel_25: (+1)
   \   00000238   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000023C   0x4658             MOV      R0,R11
   \   0000023E   0x.... 0x....      BL       CPU_SR_Restore
    260                                   *p_err = OS_ERR_STATE_INVALID;
   \                     ??OSMutexDel_27: (+1)
   \   00000242   0xF646 0x602D      MOVW     R0,#+28205
   \   00000246   0x8030             STRH     R0,[R6, #+0]
    261                                    return ((OS_OBJ_QTY)0);
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0xE06C             B.N      ??OSMutexDel_1
    262                           }
    263                       }
    264          
    265                       ts = OS_TS_GET();                                             /* Get timestamp                           */
   \                     ??OSMutexDel_20: (+1)
   \   0000024C   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000250   0x9001             STR      R0,[SP, #+4]
    266                       while (cnt > 0u) {                                            /* Remove all tasks from the pend list     */
   \                     ??OSMutexDel_28: (+1)
   \   00000252   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000254   0x2F00             CMP      R7,#+0
   \   00000256   0xD00C             BEQ.N    ??OSMutexDel_29
    267                           p_pend_data = p_pend_list->HeadPtr;
   \   00000258   0x9800             LDR      R0,[SP, #+0]
   \   0000025A   0x6800             LDR      R0,[R0, #+0]
   \   0000025C   0x9002             STR      R0,[SP, #+8]
    268                           p_tcb       = p_pend_data->TCBPtr;
   \   0000025E   0x9802             LDR      R0,[SP, #+8]
   \   00000260   0x6880             LDR      R0,[R0, #+8]
   \   00000262   0x4681             MOV      R9,R0
    269                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_mutex),
    270                                         p_tcb,
    271                                         ts);
   \   00000264   0x9A01             LDR      R2,[SP, #+4]
   \   00000266   0x4649             MOV      R1,R9
   \   00000268   0x0020             MOVS     R0,R4
   \   0000026A   0x.... 0x....      BL       OS_PendObjDel
    272                           cnt--;
   \   0000026E   0x1E7F             SUBS     R7,R7,#+1
   \   00000270   0xE7EF             B.N      ??OSMutexDel_28
    273                       }
    274          #if OS_CFG_DBG_EN > 0u
    275                       OS_MutexDbgListRemove(p_mutex);
   \                     ??OSMutexDel_29: (+1)
   \   00000272   0x0020             MOVS     R0,R4
   \   00000274   0x.... 0x....      BL       OS_MutexDbgListRemove
    276          #endif
    277                       OSMutexQty--;
   \   00000278   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   0000027C   0x8800             LDRH     R0,[R0, #+0]
   \   0000027E   0x1E40             SUBS     R0,R0,#+1
   \   00000280   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   00000284   0x8008             STRH     R0,[R1, #+0]
    278                       OS_MutexClr(p_mutex);
   \   00000286   0x0020             MOVS     R0,R4
   \   00000288   0x.... 0x....      BL       OS_MutexClr
    279                       OS_CRITICAL_EXIT_NO_SCHED();
   \   0000028C   0x.... 0x....      BL       CPU_SR_Save
   \   00000290   0x4683             MOV      R11,R0
   \   00000292   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000296   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000029A   0x7800             LDRB     R0,[R0, #+0]
   \   0000029C   0x1E40             SUBS     R0,R0,#+1
   \   0000029E   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000002A2   0x7008             STRB     R0,[R1, #+0]
   \   000002A4   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000002A8   0x7800             LDRB     R0,[R0, #+0]
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xD101             BNE.N    ??OSMutexDel_30
   \   000002AE   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSMutexDel_30: (+1)
   \   000002B2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002B6   0x4658             MOV      R0,R11
   \   000002B8   0x.... 0x....      BL       CPU_SR_Restore
    280                       OSSched();                                                    /* Find highest priority task ready to run */
   \   000002BC   0x.... 0x....      BL       OSSched
    281                      *p_err = OS_ERR_NONE;
   \   000002C0   0x2000             MOVS     R0,#+0
   \   000002C2   0x8030             STRH     R0,[R6, #+0]
    282                       break;
   \   000002C4   0xE02D             B.N      ??OSMutexDel_19
    283          
    284                  default:
    285                       OS_CRITICAL_EXIT();
   \                     ??OSMutexDel_10: (+1)
   \   000002C6   0x.... 0x....      BL       CPU_SR_Save
   \   000002CA   0x4683             MOV      R11,R0
   \   000002CC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000002D0   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000002D4   0x7800             LDRB     R0,[R0, #+0]
   \   000002D6   0x1E40             SUBS     R0,R0,#+1
   \   000002D8   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000002DC   0x7008             STRB     R0,[R1, #+0]
   \   000002DE   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000002E2   0x7800             LDRB     R0,[R0, #+0]
   \   000002E4   0x2800             CMP      R0,#+0
   \   000002E6   0xD114             BNE.N    ??OSMutexDel_31
   \   000002E8   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000002EC   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   000002F0   0x8800             LDRH     R0,[R0, #+0]
   \   000002F2   0x2800             CMP      R0,#+0
   \   000002F4   0xD007             BEQ.N    ??OSMutexDel_32
   \   000002F6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002FA   0x4658             MOV      R0,R11
   \   000002FC   0x.... 0x....      BL       CPU_SR_Restore
   \   00000300   0x.... 0x....      BL       OS_Sched0
   \   00000304   0xE00A             B.N      ??OSMutexDel_33
   \                     ??OSMutexDel_32: (+1)
   \   00000306   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000030A   0x4658             MOV      R0,R11
   \   0000030C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000310   0xE004             B.N      ??OSMutexDel_33
   \                     ??OSMutexDel_31: (+1)
   \   00000312   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000316   0x4658             MOV      R0,R11
   \   00000318   0x.... 0x....      BL       CPU_SR_Restore
    286                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSMutexDel_33: (+1)
   \   0000031C   0xF645 0x6025      MOVW     R0,#+24101
   \   00000320   0x8030             STRH     R0,[R6, #+0]
    287                       break;
    288              }
    289              return (nbr_tasks);
   \                     ??OSMutexDel_19: (+1)
   \   00000322   0x4640             MOV      R0,R8
   \   00000324   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexDel_1: (+1)
   \   00000326   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    290          }
    291          #endif
    292          
    293          /*$PAGE*/
    294          /*
    295          ************************************************************************************************************************
    296          *                                                    PEND ON MUTEX
    297          *
    298          * Description: This function waits for a mutex.
    299          *
    300          * Arguments  : p_mutex       is a pointer to the mutex
    301          *
    302          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    303          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    304          *                            0, however, your task will wait forever at the specified mutex or, until the resource
    305          *                            becomes available.
    306          *
    307          *              opt           determines whether the user wants to block if the mutex is not available or not:
    308          *
    309          *                                OS_OPT_PEND_BLOCKING
    310          *                                OS_OPT_PEND_NON_BLOCKING
    311          *
    312          *              p_ts          is a pointer to a variable that will receive the timestamp of when the mutex was posted or
    313          *                            pend aborted or the mutex deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you
    314          *                            will not get the timestamp.  In other words, passing a NULL pointer is valid and indicates
    315          *                            that you don't need the timestamp.
    316          *
    317          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    318          *
    319          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    320          *                                OS_ERR_MUTEX_OWNER        If calling task already owns the mutex
    321          *                                OS_ERR_OBJ_DEL            If 'p_mutex' was deleted
    322          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer.
    323          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    324          *                                OS_ERR_OPT_INVALID        If you didn't specify a valid option
    325          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    326          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    327          *                                                          would lead to a suspension.
    328          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the mutex was not
    329          *                                                          available.
    330          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    331          *                                OS_ERR_STATE_INVALID      If the task is in an invalid state
    332          *                                OS_ERR_STATUS_INVALID     If the pend status has an invalid value
    333          *                                OS_ERR_TIMEOUT            The mutex was not received within the specified timeout.
    334          *
    335          * Returns    : none
    336          ************************************************************************************************************************
    337          */
    338          

   \                                 In section .text, align 2, keep-with-next
    339          void  OSMutexPend (OS_MUTEX  *p_mutex,
    340                             OS_TICK    timeout,
    341                             OS_OPT     opt,
    342                             CPU_TS    *p_ts,
    343                             OS_ERR    *p_err)
    344          {
   \                     OSMutexPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8040      LDR      R8,[SP, #+64]
    345              OS_PEND_DATA  pend_data;
    346              OS_TCB       *p_tcb;
    347              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0A00      MOVS     R10,#+0
    348          
    349          
    350          
    351          #ifdef OS_SAFETY_CRITICAL
    352              if (p_err == (OS_ERR *)0) {
    353                  OS_SAFETY_CRITICAL_EXCEPTION();
    354                  return;
    355              }
    356          #endif
    357          
    358          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    359              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??OSMutexPend_0
    360                 *p_err = OS_ERR_PEND_ISR;
   \   00000020   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000024   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    361                  return;
   \   00000028   0xE161             B.N      ??OSMutexPend_1
    362              }
    363          #endif
    364          
    365          #if OS_CFG_ARG_CHK_EN > 0u
    366              if (p_mutex == (OS_MUTEX *)0) {                         /* Validate arguments                                     */
   \                     ??OSMutexPend_0: (+1)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD104             BNE.N    ??OSMutexPend_2
    367                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000002E   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000032   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    368                  return;
   \   00000036   0xE15A             B.N      ??OSMutexPend_1
    369              }
    370              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSMutexPend_2: (+1)
   \   00000038   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??OSMutexPend_3
   \   00000040   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000044   0xD105             BNE.N    ??OSMutexPend_4
    371                  case OS_OPT_PEND_BLOCKING:
    372                  case OS_OPT_PEND_NON_BLOCKING:
    373                       break;
    374          
    375                  default:
    376                      *p_err = OS_ERR_OPT_INVALID;
    377                       return;
    378              }
    379          #endif
    380          
    381          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    382              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
   \                     ??OSMutexPend_3: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x5854554d
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD105             BNE.N    ??OSMutexPend_5
   \   00000050   0xE009             B.N      ??OSMutexPend_6
   \                     ??OSMutexPend_4: (+1)
   \   00000052   0xF645 0x6025      MOVW     R0,#+24101
   \   00000056   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000005A   0xE148             B.N      ??OSMutexPend_1
    383                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSMutexPend_5: (+1)
   \   0000005C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000060   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    384                  return;
   \   00000064   0xE143             B.N      ??OSMutexPend_1
    385              }
    386          #endif
    387          
    388              if (p_ts != (CPU_TS *)0) {
   \                     ??OSMutexPend_6: (+1)
   \   00000066   0x2F00             CMP      R7,#+0
   \   00000068   0xD001             BEQ.N    ??OSMutexPend_7
    389                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x6038             STR      R0,[R7, #+0]
    390              }
    391          
    392              CPU_CRITICAL_ENTER();
   \                     ??OSMutexPend_7: (+1)
   \   0000006E   0x.... 0x....      BL       CPU_SR_Save
   \   00000072   0x4682             MOV      R10,R0
   \   00000074   0x.... 0x....      BL       CPU_IntDisMeasStart
    393              if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
   \   00000078   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD11A             BNE.N    ??OSMutexPend_8
    394                  p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x6220             STR      R0,[R4, #+32]
    395                  p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   00000092   0xF884 0x0024      STRB     R0,[R4, #+36]
    396                  p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF884 0x0025      STRB     R0,[R4, #+37]
    397                  if (p_ts != (CPU_TS *)0) {
   \   0000009C   0x2F00             CMP      R7,#+0
   \   0000009E   0xD001             BEQ.N    ??OSMutexPend_9
    398                     *p_ts  = p_mutex->TS;
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0x6038             STR      R0,[R7, #+0]
    399                  }
    400                  CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_9: (+1)
   \   000000A4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A8   0x4650             MOV      R0,R10
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    401                 *p_err = OS_ERR_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    402                  return;
   \   000000B4   0xE11B             B.N      ??OSMutexPend_1
    403              }
    404          
    405              if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
   \                     ??OSMutexPend_8: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x6A21             LDR      R1,[R4, #+32]
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xD112             BNE.N    ??OSMutexPend_10
    406                  p_mutex->OwnerNestingCtr++;
   \   000000C2   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0xF884 0x0025      STRB     R0,[R4, #+37]
    407                  if (p_ts != (CPU_TS *)0) {
   \   000000CC   0x2F00             CMP      R7,#+0
   \   000000CE   0xD001             BEQ.N    ??OSMutexPend_11
    408                     *p_ts  = p_mutex->TS;
   \   000000D0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D2   0x6038             STR      R0,[R7, #+0]
    409                  }
    410                  CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_11: (+1)
   \   000000D4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D8   0x4650             MOV      R0,R10
   \   000000DA   0x.... 0x....      BL       CPU_SR_Restore
    411                 *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
   \   000000DE   0xF245 0x7082      MOVW     R0,#+22402
   \   000000E2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    412                  return;
   \   000000E6   0xE102             B.N      ??OSMutexPend_1
    413              }
    414          
    415              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSMutexPend_10: (+1)
   \   000000E8   0x0430             LSLS     R0,R6,#+16
   \   000000EA   0xD509             BPL.N    ??OSMutexPend_12
    416                  CPU_CRITICAL_EXIT();
   \   000000EC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F0   0x4650             MOV      R0,R10
   \   000000F2   0x.... 0x....      BL       CPU_SR_Restore
    417                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \   000000F6   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000FA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    418                  return;
   \   000000FE   0xE0F6             B.N      ??OSMutexPend_1
    419              } else {
    420                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSMutexPend_12: (+1)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD009             BEQ.N    ??OSMutexPend_13
    421                      CPU_CRITICAL_EXIT();
   \   0000010A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010E   0x4650             MOV      R0,R10
   \   00000110   0x.... 0x....      BL       CPU_SR_Restore
    422                     *p_err = OS_ERR_SCHED_LOCKED;
   \   00000114   0xF646 0x5063      MOVW     R0,#+28003
   \   00000118   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    423                      return;
   \   0000011C   0xE0E7             B.N      ??OSMutexPend_1
    424                  }
    425              }
    426                                                                      /* Lock the scheduler/re-enable interrupts                */
    427              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSMutexPend_13: (+1)
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x1C40             ADDS     R0,R0,#+1
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   0000012A   0x7008             STRB     R0,[R1, #+0]
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x2801             CMP      R0,#+1
   \   00000134   0xD101             BNE.N    ??OSMutexPend_14
   \   00000136   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSMutexPend_14: (+1)
   \   0000013A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000013E   0x4650             MOV      R0,R10
   \   00000140   0x.... 0x....      BL       CPU_SR_Restore
    428              p_tcb = p_mutex->OwnerTCBPtr;                           /* Point to the TCB of the Mutex owner                    */
   \   00000144   0x6A20             LDR      R0,[R4, #+32]
   \   00000146   0x4681             MOV      R9,R0
    429              if (p_tcb->Prio > OSTCBCurPtr->Prio) {                  /* See if mutex owner has a lower priority than current   */
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   00000152   0xF899 0x1037      LDRB     R1,[R9, #+55]
   \   00000156   0x4288             CMP      R0,R1
   \   00000158   0xD262             BCS.N    ??OSMutexPend_15
    430                  switch (p_tcb->TaskState) {
   \   0000015A   0xF899 0x0036      LDRB     R0,[R9, #+54]
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD00B             BEQ.N    ??OSMutexPend_16
   \   00000162   0x2802             CMP      R0,#+2
   \   00000164   0xD023             BEQ.N    ??OSMutexPend_17
   \   00000166   0xD31A             BCC.N    ??OSMutexPend_18
   \   00000168   0x2804             CMP      R0,#+4
   \   0000016A   0xD018             BEQ.N    ??OSMutexPend_18
   \   0000016C   0xD31F             BCC.N    ??OSMutexPend_17
   \   0000016E   0x2806             CMP      R0,#+6
   \   00000170   0xD01D             BEQ.N    ??OSMutexPend_17
   \   00000172   0xD314             BCC.N    ??OSMutexPend_18
   \   00000174   0x2807             CMP      R0,#+7
   \   00000176   0xD01A             BEQ.N    ??OSMutexPend_17
   \   00000178   0xE022             B.N      ??OSMutexPend_19
    431                      case OS_TASK_STATE_RDY:
    432                           OS_RdyListRemove(p_tcb);                   /* Remove from ready list at current priority             */
   \                     ??OSMutexPend_16: (+1)
   \   0000017A   0x4648             MOV      R0,R9
   \   0000017C   0x.... 0x....      BL       OS_RdyListRemove
    433                           p_tcb->Prio = OSTCBCurPtr->Prio;           /* Raise owner's priority                                 */
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   0000018A   0xF889 0x0037      STRB     R0,[R9, #+55]
    434                           OS_PrioInsert(p_tcb->Prio);
   \   0000018E   0xF899 0x0037      LDRB     R0,[R9, #+55]
   \   00000192   0x.... 0x....      BL       OS_PrioInsert
    435                           OS_RdyListInsertHead(p_tcb);               /* Insert in ready list at new priority                   */
   \   00000196   0x4648             MOV      R0,R9
   \   00000198   0x.... 0x....      BL       OS_RdyListInsertHead
    436                           break;
   \   0000019C   0xE040             B.N      ??OSMutexPend_15
    437          
    438                      case OS_TASK_STATE_DLY:
    439                      case OS_TASK_STATE_DLY_SUSPENDED:
    440                      case OS_TASK_STATE_SUSPENDED:
    441                           p_tcb->Prio = OSTCBCurPtr->Prio;           /* Only need to raise the owner's priority                */
   \                     ??OSMutexPend_18: (+1)
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   000001A2   0x6800             LDR      R0,[R0, #+0]
   \   000001A4   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   000001A8   0xF889 0x0037      STRB     R0,[R9, #+55]
    442                           break;
   \   000001AC   0xE038             B.N      ??OSMutexPend_15
    443          
    444                      case OS_TASK_STATE_PEND:                        /* Change the position of the task in the wait list       */
    445                      case OS_TASK_STATE_PEND_TIMEOUT:
    446                      case OS_TASK_STATE_PEND_SUSPENDED:
    447                      case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    448                           OS_PendListChangePrio(p_tcb,
    449                                                 OSTCBCurPtr->Prio);
   \                     ??OSMutexPend_17: (+1)
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   000001B2   0x6800             LDR      R0,[R0, #+0]
   \   000001B4   0xF890 0x1037      LDRB     R1,[R0, #+55]
   \   000001B8   0x4648             MOV      R0,R9
   \   000001BA   0x.... 0x....      BL       OS_PendListChangePrio
    450                           break;
   \   000001BE   0xE02F             B.N      ??OSMutexPend_15
    451          
    452                      default:
    453                           OS_CRITICAL_EXIT();
   \                     ??OSMutexPend_19: (+1)
   \   000001C0   0x.... 0x....      BL       CPU_SR_Save
   \   000001C4   0x4682             MOV      R10,R0
   \   000001C6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000001CE   0x7800             LDRB     R0,[R0, #+0]
   \   000001D0   0x1E40             SUBS     R0,R0,#+1
   \   000001D2   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   000001D6   0x7008             STRB     R0,[R1, #+0]
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x2800             CMP      R0,#+0
   \   000001E0   0xD114             BNE.N    ??OSMutexPend_20
   \   000001E2   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   000001EA   0x8800             LDRH     R0,[R0, #+0]
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD007             BEQ.N    ??OSMutexPend_21
   \   000001F0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001F4   0x4650             MOV      R0,R10
   \   000001F6   0x.... 0x....      BL       CPU_SR_Restore
   \   000001FA   0x.... 0x....      BL       OS_Sched0
   \   000001FE   0xE00A             B.N      ??OSMutexPend_22
   \                     ??OSMutexPend_21: (+1)
   \   00000200   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000204   0x4650             MOV      R0,R10
   \   00000206   0x.... 0x....      BL       CPU_SR_Restore
   \   0000020A   0xE004             B.N      ??OSMutexPend_22
   \                     ??OSMutexPend_20: (+1)
   \   0000020C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000210   0x4650             MOV      R0,R10
   \   00000212   0x.... 0x....      BL       CPU_SR_Restore
    454                          *p_err = OS_ERR_STATE_INVALID;
   \                     ??OSMutexPend_22: (+1)
   \   00000216   0xF646 0x602D      MOVW     R0,#+28205
   \   0000021A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    455                           return;
   \   0000021E   0xE066             B.N      ??OSMutexPend_1
    456                  }
    457              }
    458          
    459              OS_Pend(&pend_data,                                     /* Block task pending on Mutex                            */
    460                      (OS_PEND_OBJ *)((void *)p_mutex),
    461                       OS_TASK_PEND_ON_MUTEX,
    462                       timeout);
   \                     ??OSMutexPend_15: (+1)
   \   00000220   0x002B             MOVS     R3,R5
   \   00000222   0x2204             MOVS     R2,#+4
   \   00000224   0x0021             MOVS     R1,R4
   \   00000226   0x4668             MOV      R0,SP
   \   00000228   0x.... 0x....      BL       OS_Pend
    463          
    464              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000022C   0x.... 0x....      BL       CPU_SR_Save
   \   00000230   0x4682             MOV      R10,R0
   \   00000232   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000236   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000023A   0x7800             LDRB     R0,[R0, #+0]
   \   0000023C   0x1E40             SUBS     R0,R0,#+1
   \   0000023E   0x.... 0x....      LDR.W    R1,??DataTable8_2
   \   00000242   0x7008             STRB     R0,[R1, #+0]
   \   00000244   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000248   0x7800             LDRB     R0,[R0, #+0]
   \   0000024A   0x2800             CMP      R0,#+0
   \   0000024C   0xD101             BNE.N    ??OSMutexPend_23
   \   0000024E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSMutexPend_23: (+1)
   \   00000252   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000256   0x4650             MOV      R0,R10
   \   00000258   0x.... 0x....      BL       CPU_SR_Restore
    465          
    466              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   0000025C   0x.... 0x....      BL       OSSched
    467          
    468              CPU_CRITICAL_ENTER();
   \   00000260   0x.... 0x....      BL       CPU_SR_Save
   \   00000264   0x4682             MOV      R10,R0
   \   00000266   0x.... 0x....      BL       CPU_IntDisMeasStart
    469              switch (OSTCBCurPtr->PendStatus) {
   \   0000026A   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   0000026E   0x6800             LDR      R0,[R0, #+0]
   \   00000270   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000274   0x2800             CMP      R0,#+0
   \   00000276   0xD005             BEQ.N    ??OSMutexPend_24
   \   00000278   0x2802             CMP      R0,#+2
   \   0000027A   0xD023             BEQ.N    ??OSMutexPend_25
   \   0000027C   0xD30D             BCC.N    ??OSMutexPend_26
   \   0000027E   0x2803             CMP      R0,#+3
   \   00000280   0xD017             BEQ.N    ??OSMutexPend_27
   \   00000282   0xE02B             B.N      ??OSMutexPend_28
    470                  case OS_STATUS_PEND_OK:                             /* We got the mutex                                       */
    471                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSMutexPend_24: (+1)
   \   00000284   0x2F00             CMP      R7,#+0
   \   00000286   0xD004             BEQ.N    ??OSMutexPend_29
    472                          *p_ts  = OSTCBCurPtr->TS;
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   0000028C   0x6800             LDR      R0,[R0, #+0]
   \   0000028E   0x6C00             LDR      R0,[R0, #+64]
   \   00000290   0x6038             STR      R0,[R7, #+0]
    473                       }
    474                      *p_err = OS_ERR_NONE;
   \                     ??OSMutexPend_29: (+1)
   \   00000292   0x2000             MOVS     R0,#+0
   \   00000294   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    475                       break;
   \   00000298   0xE024             B.N      ??OSMutexPend_30
    476          
    477                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    478                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSMutexPend_26: (+1)
   \   0000029A   0x2F00             CMP      R7,#+0
   \   0000029C   0xD004             BEQ.N    ??OSMutexPend_31
    479                          *p_ts  = OSTCBCurPtr->TS;
   \   0000029E   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   000002A2   0x6800             LDR      R0,[R0, #+0]
   \   000002A4   0x6C00             LDR      R0,[R0, #+64]
   \   000002A6   0x6038             STR      R0,[R7, #+0]
    480                       }
    481                      *p_err = OS_ERR_PEND_ABORT;
   \                     ??OSMutexPend_31: (+1)
   \   000002A8   0xF246 0x10A9      MOVW     R0,#+25001
   \   000002AC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    482                       break;
   \   000002B0   0xE018             B.N      ??OSMutexPend_30
    483          
    484                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get mutex within timeout       */
    485                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSMutexPend_27: (+1)
   \   000002B2   0x2F00             CMP      R7,#+0
   \   000002B4   0xD001             BEQ.N    ??OSMutexPend_32
    486                          *p_ts  = (CPU_TS  )0;
   \   000002B6   0x2000             MOVS     R0,#+0
   \   000002B8   0x6038             STR      R0,[R7, #+0]
    487                       }
    488                      *p_err = OS_ERR_TIMEOUT;
   \                     ??OSMutexPend_32: (+1)
   \   000002BA   0xF247 0x20D9      MOVW     R0,#+29401
   \   000002BE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    489                       break;
   \   000002C2   0xE00F             B.N      ??OSMutexPend_30
    490          
    491                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    492                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSMutexPend_25: (+1)
   \   000002C4   0x2F00             CMP      R7,#+0
   \   000002C6   0xD004             BEQ.N    ??OSMutexPend_33
    493                          *p_ts  = OSTCBCurPtr->TS;
   \   000002C8   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   000002CC   0x6800             LDR      R0,[R0, #+0]
   \   000002CE   0x6C00             LDR      R0,[R0, #+64]
   \   000002D0   0x6038             STR      R0,[R7, #+0]
    494                       }
    495                      *p_err = OS_ERR_OBJ_DEL;
   \                     ??OSMutexPend_33: (+1)
   \   000002D2   0xF645 0x50C2      MOVW     R0,#+24002
   \   000002D6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    496                       break;
   \   000002DA   0xE003             B.N      ??OSMutexPend_30
    497          
    498                  default:
    499                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSMutexPend_28: (+1)
   \   000002DC   0xF646 0x602E      MOVW     R0,#+28206
   \   000002E0   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    500                       break;
    501              }
    502              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_30: (+1)
   \   000002E4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002E8   0x4650             MOV      R0,R10
   \   000002EA   0x.... 0x....      BL       CPU_SR_Restore
    503          }
   \                     ??OSMutexPend_1: (+1)
   \   000002EE   0xB008             ADD      SP,SP,#+32
   \   000002F0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    504          
    505          /*$PAGE*/
    506          /*
    507          ************************************************************************************************************************
    508          *                                               ABORT WAITING ON A MUTEX
    509          *
    510          * Description: This function aborts & readies any tasks currently waiting on a mutex.  This function should be used
    511          *              to fault-abort the wait on the mutex, rather than to normally signal the mutex via OSMutexPost().
    512          *
    513          * Arguments  : p_mutex   is a pointer to the mutex
    514          *
    515          *              opt       determines the type of ABORT performed:
    516          *
    517          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the mutex
    518          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the mutex
    519          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    520          *
    521          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    522          *
    523          *                            OS_ERR_NONE                  At least one task waiting on the mutex was readied and
    524          *                                                         informed of the aborted wait; check return value for the
    525          *                                                         number of tasks whose wait on the mutex was aborted.
    526          *                            OS_ERR_OBJ_PTR_NULL          If 'p_mutex' is a NULL pointer.
    527          *                            OS_ERR_OBJ_TYPE              If 'p_mutex' is not pointing at a mutex
    528          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    529          *                            OS_ERR_PEND_ABORT_ISR        If you attempted to call this function from an ISR
    530          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    531          *
    532          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    533          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    534          ************************************************************************************************************************
    535          */
    536          
    537          #if OS_CFG_MUTEX_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    538          OS_OBJ_QTY  OSMutexPendAbort (OS_MUTEX  *p_mutex,
    539                                        OS_OPT     opt,
    540                                        OS_ERR    *p_err)
    541          {
   \                     OSMutexPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    542              OS_PEND_LIST  *p_pend_list;
    543              OS_TCB        *p_tcb;
    544              CPU_TS         ts;
    545              OS_OBJ_QTY     nbr_tasks;
    546              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    547          
    548          
    549          
    550          #ifdef OS_SAFETY_CRITICAL
    551              if (p_err == (OS_ERR *)0) {
    552                  OS_SAFETY_CRITICAL_EXCEPTION();
    553                  return ((OS_OBJ_QTY)0u);
    554              }
    555          #endif
    556          
    557          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    558              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSMutexPendAbort_0
    559                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000018   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    560                  return ((OS_OBJ_QTY)0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE07C             B.N      ??OSMutexPendAbort_1
    561              }
    562          #endif
    563          
    564          #if OS_CFG_ARG_CHK_EN > 0u
    565              if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
   \                     ??OSMutexPendAbort_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSMutexPendAbort_2
    566                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    567                  return ((OS_OBJ_QTY)0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE075             B.N      ??OSMutexPendAbort_1
    568              }
    569              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSMutexPendAbort_2: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??OSMutexPendAbort_3
   \   00000038   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003C   0xD005             BEQ.N    ??OSMutexPendAbort_3
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD002             BEQ.N    ??OSMutexPendAbort_3
   \   00000044   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000048   0xD105             BNE.N    ??OSMutexPendAbort_4
    570                  case OS_OPT_PEND_ABORT_1:
    571                  case OS_OPT_PEND_ABORT_ALL:
    572                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    573                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    574                       break;
    575          
    576                  default:
    577                      *p_err =  OS_ERR_OPT_INVALID;
    578                       return ((OS_OBJ_QTY)0u);
    579              }
    580          #endif
    581          
    582          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    583              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
   \                     ??OSMutexPendAbort_3: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x5854554d
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD105             BNE.N    ??OSMutexPendAbort_5
   \   00000054   0xE009             B.N      ??OSMutexPendAbort_6
   \                     ??OSMutexPendAbort_4: (+1)
   \   00000056   0xF645 0x6025      MOVW     R0,#+24101
   \   0000005A   0x8030             STRH     R0,[R6, #+0]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE05D             B.N      ??OSMutexPendAbort_1
    584                 *p_err =  OS_ERR_OBJ_TYPE;
   \                     ??OSMutexPendAbort_5: (+1)
   \   00000060   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000064   0x8030             STRH     R0,[R6, #+0]
    585                  return ((OS_OBJ_QTY)0u);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE058             B.N      ??OSMutexPendAbort_1
    586              }
    587          #endif
    588          
    589              CPU_CRITICAL_ENTER();
   \                     ??OSMutexPendAbort_6: (+1)
   \   0000006A   0x.... 0x....      BL       CPU_SR_Save
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStart
    590              p_pend_list = &p_mutex->PendList;
   \   00000074   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000078   0x0007             MOVS     R7,R0
    591              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on mutex?                             */
   \   0000007A   0x8938             LDRH     R0,[R7, #+8]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD109             BNE.N    ??OSMutexPendAbort_7
    592                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    593                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   0000008A   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000008E   0x8030             STRH     R0,[R6, #+0]
    594                  return ((OS_OBJ_QTY)0u);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE043             B.N      ??OSMutexPendAbort_1
    595              }
    596          
    597              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSMutexPendAbort_7: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x....             LDR.N    R1,??DataTable8_2
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \   000000A0   0x....             LDR.N    R0,??DataTable8_2
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD101             BNE.N    ??OSMutexPendAbort_8
   \   000000A8   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSMutexPendAbort_8: (+1)
   \   000000AC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B0   0x4658             MOV      R0,R11
   \   000000B2   0x.... 0x....      BL       CPU_SR_Restore
    598              nbr_tasks = 0u;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x4682             MOV      R10,R0
    599              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
   \   000000BA   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000BE   0x4681             MOV      R9,R0
    600              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSMutexPendAbort_9: (+1)
   \   000000C0   0x8938             LDRH     R0,[R7, #+8]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00D             BEQ.N    ??OSMutexPendAbort_10
    601                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
   \   000000C6   0x6838             LDR      R0,[R7, #+0]
   \   000000C8   0x6880             LDR      R0,[R0, #+8]
   \   000000CA   0x4680             MOV      R8,R0
    602                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_mutex),
    603                               p_tcb,
    604                               ts);
   \   000000CC   0x464A             MOV      R2,R9
   \   000000CE   0x4641             MOV      R1,R8
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       OS_PendAbort
    605                  nbr_tasks++;
   \   000000D6   0xF11A 0x0A01      ADDS     R10,R10,#+1
    606                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000DA   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000DC   0xF5B5 0x7F80      CMP      R5,#+256
   \   000000E0   0xD0EE             BEQ.N    ??OSMutexPendAbort_9
    607                      break;                                          /* No                                                     */
    608                  }
    609              }
    610              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSMutexPendAbort_10: (+1)
   \   000000E2   0x.... 0x....      BL       CPU_SR_Save
   \   000000E6   0x4683             MOV      R11,R0
   \   000000E8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000EC   0x....             LDR.N    R0,??DataTable8_2
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x1E40             SUBS     R0,R0,#+1
   \   000000F2   0x....             LDR.N    R1,??DataTable8_2
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   \   000000F6   0x....             LDR.N    R0,??DataTable8_2
   \   000000F8   0x7800             LDRB     R0,[R0, #+0]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD101             BNE.N    ??OSMutexPendAbort_11
   \   000000FE   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSMutexPendAbort_11: (+1)
   \   00000102   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000106   0x4658             MOV      R0,R11
   \   00000108   0x.... 0x....      BL       CPU_SR_Restore
    611          
    612              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   0000010C   0x0428             LSLS     R0,R5,#+16
   \   0000010E   0xD401             BMI.N    ??OSMutexPendAbort_12
    613                  OSSched();                                          /* Run the scheduler                                      */
   \   00000110   0x.... 0x....      BL       OSSched
    614              }
    615          
    616             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPendAbort_12: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x8030             STRH     R0,[R6, #+0]
    617              return (nbr_tasks);
   \   00000118   0x4650             MOV      R0,R10
   \   0000011A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexPendAbort_1: (+1)
   \   0000011C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    618          }
    619          #endif
    620          
    621          /*$PAGE*/
    622          /*
    623          ************************************************************************************************************************
    624          *                                                   POST TO A MUTEX
    625          *
    626          * Description: This function signals a mutex
    627          *
    628          * Arguments  : p_mutex  is a pointer to the mutex
    629          *
    630          *              opt      is an option you can specify to alter the behavior of the post.  The choices are:
    631          *
    632          *                           OS_OPT_POST_NONE        No special option selected
    633          *                           OS_OPT_POST_NO_SCHED    If you don't want the scheduler to be called after the post.
    634          *
    635          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    636          *
    637          *                           OS_ERR_NONE             The call was successful and the mutex was signaled.
    638          *                           OS_ERR_MUTEX_NESTING    Mutex owner nested its use of the mutex
    639          *                           OS_ERR_MUTEX_NOT_OWNER  If the task posting is not the Mutex owner
    640          *                           OS_ERR_OBJ_PTR_NULL     If 'p_mutex' is a NULL pointer.
    641          *                           OS_ERR_OBJ_TYPE         If 'p_mutex' is not pointing at a mutex
    642          *                           OS_ERR_POST_ISR         If you attempted to post from an ISR
    643          *
    644          * Returns    : none
    645          ************************************************************************************************************************
    646          */
    647          

   \                                 In section .text, align 2, keep-with-next
    648          void  OSMutexPost (OS_MUTEX  *p_mutex,
    649                             OS_OPT     opt,
    650                             OS_ERR    *p_err)
    651          {
   \                     OSMutexPost: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    652              OS_PEND_LIST  *p_pend_list;
    653              OS_TCB        *p_tcb;
    654              CPU_TS         ts;
    655              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
    656          
    657          
    658          
    659          #ifdef OS_SAFETY_CRITICAL
    660              if (p_err == (OS_ERR *)0) {
    661                  OS_SAFETY_CRITICAL_EXCEPTION();
    662                  return;
    663              }
    664          #endif
    665          
    666          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    667              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000010   0x....             LDR.N    R0,??DataTable8
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSMutexPost_0
    668                 *p_err = OS_ERR_POST_ISR;
   \   00000018   0xF246 0x200E      MOVW     R0,#+25102
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    669                  return;
   \   0000001E   0xE0FB             B.N      ??OSMutexPost_1
    670              }
    671          #endif
    672          
    673          #if OS_CFG_ARG_CHK_EN > 0u
    674              if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
   \                     ??OSMutexPost_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD103             BNE.N    ??OSMutexPost_2
    675                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8030             STRH     R0,[R6, #+0]
    676                  return;
   \   0000002A   0xE0F5             B.N      ??OSMutexPost_1
    677              }
    678              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSMutexPost_2: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??OSMutexPost_3
   \   00000034   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000038   0xD104             BNE.N    ??OSMutexPost_4
    679                  case OS_OPT_POST_NONE:
    680                  case OS_OPT_POST_NO_SCHED:
    681                       break;
    682          
    683                  default:
    684                      *p_err =  OS_ERR_OPT_INVALID;
    685                       return;
    686              }
    687          #endif
    688          
    689          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    690              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
   \                     ??OSMutexPost_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x....             LDR.N    R1,??DataTable8_3  ;; 0x5854554d
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD104             BNE.N    ??OSMutexPost_5
   \   00000042   0xE007             B.N      ??OSMutexPost_6
   \                     ??OSMutexPost_4: (+1)
   \   00000044   0xF645 0x6025      MOVW     R0,#+24101
   \   00000048   0x8030             STRH     R0,[R6, #+0]
   \   0000004A   0xE0E5             B.N      ??OSMutexPost_1
    691                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSMutexPost_5: (+1)
   \   0000004C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000050   0x8030             STRH     R0,[R6, #+0]
    692                  return;
   \   00000052   0xE0E1             B.N      ??OSMutexPost_1
    693              }
    694          #endif
    695          
    696              CPU_CRITICAL_ENTER();
   \                     ??OSMutexPost_6: (+1)
   \   00000054   0x.... 0x....      BL       CPU_SR_Save
   \   00000058   0x4682             MOV      R10,R0
   \   0000005A   0x.... 0x....      BL       CPU_IntDisMeasStart
    697              if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {              /* Make sure the mutex owner is releasing the mutex       */
   \   0000005E   0x....             LDR.N    R0,??DataTable8_6
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x6A21             LDR      R1,[R4, #+32]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD008             BEQ.N    ??OSMutexPost_7
    698                  CPU_CRITICAL_EXIT();
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x4650             MOV      R0,R10
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
    699                 *p_err = OS_ERR_MUTEX_NOT_OWNER;
   \   00000072   0xF245 0x7081      MOVW     R0,#+22401
   \   00000076   0x8030             STRH     R0,[R6, #+0]
    700                  return;
   \   00000078   0xE0CE             B.N      ??OSMutexPost_1
    701              }
    702          
    703              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSMutexPost_7: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable8_2
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable8_2
   \   00000082   0x7008             STRB     R0,[R1, #+0]
   \   00000084   0x....             LDR.N    R0,??DataTable8_2
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD101             BNE.N    ??OSMutexPost_8
   \   0000008C   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSMutexPost_8: (+1)
   \   00000090   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000094   0x4650             MOV      R0,R10
   \   00000096   0x.... 0x....      BL       CPU_SR_Restore
    704              ts          = OS_TS_GET();                              /* Get timestamp                                          */
   \   0000009A   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000009E   0x4681             MOV      R9,R0
    705              p_mutex->TS = ts;
   \   000000A0   0xF8C4 0x9028      STR      R9,[R4, #+40]
    706              p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
   \   000000A4   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   000000A8   0x1E40             SUBS     R0,R0,#+1
   \   000000AA   0xF884 0x0025      STRB     R0,[R4, #+37]
    707              if (p_mutex->OwnerNestingCtr > (OS_NESTING_CTR)0) {     /* Are we done with all nestings?                         */
   \   000000AE   0xF894 0x0025      LDRB     R0,[R4, #+37]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD02A             BEQ.N    ??OSMutexPost_9
    708                  OS_CRITICAL_EXIT();                                 /* No                                                     */
   \   000000B6   0x.... 0x....      BL       CPU_SR_Save
   \   000000BA   0x4682             MOV      R10,R0
   \   000000BC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000C0   0x....             LDR.N    R0,??DataTable8_2
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0x....             LDR.N    R1,??DataTable8_2
   \   000000C8   0x7008             STRB     R0,[R1, #+0]
   \   000000CA   0x....             LDR.N    R0,??DataTable8_2
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD113             BNE.N    ??OSMutexPost_10
   \   000000D2   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000000D6   0x....             LDR.N    R0,??DataTable8_5
   \   000000D8   0x8800             LDRH     R0,[R0, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD007             BEQ.N    ??OSMutexPost_11
   \   000000DE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E2   0x4650             MOV      R0,R10
   \   000000E4   0x.... 0x....      BL       CPU_SR_Restore
   \   000000E8   0x.... 0x....      BL       OS_Sched0
   \   000000EC   0xE00A             B.N      ??OSMutexPost_12
   \                     ??OSMutexPost_11: (+1)
   \   000000EE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000F2   0x4650             MOV      R0,R10
   \   000000F4   0x.... 0x....      BL       CPU_SR_Restore
   \   000000F8   0xE004             B.N      ??OSMutexPost_12
   \                     ??OSMutexPost_10: (+1)
   \   000000FA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FE   0x4650             MOV      R0,R10
   \   00000100   0x.... 0x....      BL       CPU_SR_Restore
    709                 *p_err = OS_ERR_MUTEX_NESTING;
   \                     ??OSMutexPost_12: (+1)
   \   00000104   0xF245 0x7083      MOVW     R0,#+22403
   \   00000108   0x8030             STRH     R0,[R6, #+0]
    710                  return;
   \   0000010A   0xE085             B.N      ??OSMutexPost_1
    711              }
    712          
    713              p_pend_list = &p_mutex->PendList;
   \                     ??OSMutexPost_9: (+1)
   \   0000010C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000110   0x0007             MOVS     R7,R0
    714              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                             */
   \   00000112   0x8938             LDRH     R0,[R7, #+8]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD12E             BNE.N    ??OSMutexPost_13
    715                  p_mutex->OwnerTCBPtr     = (OS_TCB       *)0;       /* No                                                     */
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x6220             STR      R0,[R4, #+32]
    716                  p_mutex->OwnerNestingCtr = (OS_NESTING_CTR)0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0xF884 0x0025      STRB     R0,[R4, #+37]
    717                  OS_CRITICAL_EXIT();
   \   00000122   0x.... 0x....      BL       CPU_SR_Save
   \   00000126   0x4682             MOV      R10,R0
   \   00000128   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000012C   0x....             LDR.N    R0,??DataTable8_2
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0x....             LDR.N    R1,??DataTable8_2
   \   00000134   0x7008             STRB     R0,[R1, #+0]
   \   00000136   0x....             LDR.N    R0,??DataTable8_2
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD113             BNE.N    ??OSMutexPost_14
   \   0000013E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000142   0x....             LDR.N    R0,??DataTable8_5
   \   00000144   0x8800             LDRH     R0,[R0, #+0]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD007             BEQ.N    ??OSMutexPost_15
   \   0000014A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000014E   0x4650             MOV      R0,R10
   \   00000150   0x.... 0x....      BL       CPU_SR_Restore
   \   00000154   0x.... 0x....      BL       OS_Sched0
   \   00000158   0xE00A             B.N      ??OSMutexPost_16
   \                     ??OSMutexPost_15: (+1)
   \   0000015A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000015E   0x4650             MOV      R0,R10
   \   00000160   0x.... 0x....      BL       CPU_SR_Restore
   \   00000164   0xE004             B.N      ??OSMutexPost_16
   \                     ??OSMutexPost_14: (+1)
   \   00000166   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016A   0x4650             MOV      R0,R10
   \   0000016C   0x.... 0x....      BL       CPU_SR_Restore
    718                 *p_err = OS_ERR_NONE;
   \                     ??OSMutexPost_16: (+1)
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x8030             STRH     R0,[R6, #+0]
    719                  return;
   \   00000174   0xE050             B.N      ??OSMutexPost_1
    720              }
    721                                                                      /* Yes                                                    */
    722              if (OSTCBCurPtr->Prio != p_mutex->OwnerOriginalPrio) {
   \                     ??OSMutexPost_13: (+1)
   \   00000176   0x....             LDR.N    R0,??DataTable8_6
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   0000017E   0xF894 0x1024      LDRB     R1,[R4, #+36]
   \   00000182   0x4288             CMP      R0,R1
   \   00000184   0xD019             BEQ.N    ??OSMutexPost_17
    723                  OS_RdyListRemove(OSTCBCurPtr);
   \   00000186   0x....             LDR.N    R0,??DataTable8_6
   \   00000188   0x6800             LDR      R0,[R0, #+0]
   \   0000018A   0x.... 0x....      BL       OS_RdyListRemove
    724                  OSTCBCurPtr->Prio = p_mutex->OwnerOriginalPrio;     /* Lower owner's priority back to its original one        */
   \   0000018E   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000192   0x....             LDR.N    R1,??DataTable8_6
   \   00000194   0x6809             LDR      R1,[R1, #+0]
   \   00000196   0xF881 0x0037      STRB     R0,[R1, #+55]
    725                  OS_PrioInsert(OSTCBCurPtr->Prio);
   \   0000019A   0x....             LDR.N    R0,??DataTable8_6
   \   0000019C   0x6800             LDR      R0,[R0, #+0]
   \   0000019E   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   000001A2   0x.... 0x....      BL       OS_PrioInsert
    726                  OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority             */
   \   000001A6   0x....             LDR.N    R0,??DataTable8_6
   \   000001A8   0x6800             LDR      R0,[R0, #+0]
   \   000001AA   0x.... 0x....      BL       OS_RdyListInsertTail
    727                  OSPrioCur         = OSTCBCurPtr->Prio;
   \   000001AE   0x....             LDR.N    R0,??DataTable8_6
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   000001B6   0x....             LDR.N    R1,??DataTable8_7
   \   000001B8   0x7008             STRB     R0,[R1, #+0]
    728              }
    729                                                                      /* Get TCB from head of pend list                         */
    730              p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
   \                     ??OSMutexPost_17: (+1)
   \   000001BA   0x6838             LDR      R0,[R7, #+0]
   \   000001BC   0x6880             LDR      R0,[R0, #+8]
   \   000001BE   0x4680             MOV      R8,R0
    731              p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
   \   000001C0   0xF8C4 0x8020      STR      R8,[R4, #+32]
    732              p_mutex->OwnerOriginalPrio = p_tcb->Prio;
   \   000001C4   0xF898 0x0037      LDRB     R0,[R8, #+55]
   \   000001C8   0xF884 0x0024      STRB     R0,[R4, #+36]
    733              p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
   \   000001CC   0x2001             MOVS     R0,#+1
   \   000001CE   0xF884 0x0025      STRB     R0,[R4, #+37]
    734                                                                      /* Post to mutex                                          */
    735              OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
    736                      (OS_TCB      *)p_tcb,
    737                      (void        *)0,
    738                      (OS_MSG_SIZE  )0,
    739                      (CPU_TS       )ts);
   \   000001D2   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000001D6   0x2300             MOVS     R3,#+0
   \   000001D8   0x2200             MOVS     R2,#+0
   \   000001DA   0x4641             MOV      R1,R8
   \   000001DC   0x0020             MOVS     R0,R4
   \   000001DE   0x.... 0x....      BL       OS_Post
    740          
    741              OS_CRITICAL_EXIT_NO_SCHED();
   \   000001E2   0x.... 0x....      BL       CPU_SR_Save
   \   000001E6   0x4682             MOV      R10,R0
   \   000001E8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001EC   0x....             LDR.N    R0,??DataTable8_2
   \   000001EE   0x7800             LDRB     R0,[R0, #+0]
   \   000001F0   0x1E40             SUBS     R0,R0,#+1
   \   000001F2   0x....             LDR.N    R1,??DataTable8_2
   \   000001F4   0x7008             STRB     R0,[R1, #+0]
   \   000001F6   0x....             LDR.N    R0,??DataTable8_2
   \   000001F8   0x7800             LDRB     R0,[R0, #+0]
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD101             BNE.N    ??OSMutexPost_18
   \   000001FE   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSMutexPost_18: (+1)
   \   00000202   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000206   0x4650             MOV      R0,R10
   \   00000208   0x.... 0x....      BL       CPU_SR_Restore
    742          
    743              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   0000020C   0x0428             LSLS     R0,R5,#+16
   \   0000020E   0xD401             BMI.N    ??OSMutexPost_19
    744                  OSSched();                                          /* Run the scheduler                                      */
   \   00000210   0x.... 0x....      BL       OSSched
    745              }
    746          
    747             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPost_19: (+1)
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0x8030             STRH     R0,[R6, #+0]
    748          }
   \                     ??OSMutexPost_1: (+1)
   \   00000218   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    749          
    750          /*$PAGE*/
    751          /*
    752          ************************************************************************************************************************
    753          *                                            CLEAR THE CONTENTS OF A MUTEX
    754          *
    755          * Description: This function is called by OSMutexDel() to clear the contents of a mutex
    756          *
    757          
    758          * Argument(s): p_mutex      is a pointer to the mutex to clear
    759          *              -------
    760          *
    761          * Returns    : none
    762          *
    763          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    764          ************************************************************************************************************************
    765          */
    766          

   \                                 In section .text, align 2, keep-with-next
    767          void  OS_MutexClr (OS_MUTEX  *p_mutex)
    768          {
   \                     OS_MutexClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    769              p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
   \   00000004   0x....             LDR.N    R0,??DataTable8_8  ;; 0x454e4f4e
   \   00000006   0x6020             STR      R0,[R4, #+0]
    770              p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
   \   00000008   0x....             LDR.N    R0,??DataTable8_9
   \   0000000A   0x6060             STR      R0,[R4, #+4]
    771              p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6220             STR      R0,[R4, #+32]
    772              p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF884 0x0025      STRB     R0,[R4, #+37]
    773              p_mutex->TS                = (CPU_TS        )0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x62A0             STR      R0,[R4, #+40]
    774              p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
   \   0000001A   0x2020             MOVS     R0,#+32
   \   0000001C   0xF884 0x0024      STRB     R0,[R4, #+36]
    775              OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
   \   00000020   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000024   0x.... 0x....      BL       OS_PendListInit
    776          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    777          
    778          /*$PAGE*/
    779          /*
    780          ************************************************************************************************************************
    781          *                                          ADD/REMOVE MUTEX TO/FROM DEBUG LIST
    782          *
    783          * Description: These functions are called by uC/OS-III to add or remove a mutex to/from the debug list.
    784          *
    785          * Arguments  : p_mutex     is a pointer to the mutex to add/remove
    786          *
    787          * Returns    : none
    788          *
    789          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    790          ************************************************************************************************************************
    791          */
    792          
    793          
    794          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    795          void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
    796          {
    797              p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_MutexDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable8_1  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    798              p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    799              if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
   \   00000008   0x....             LDR.N    R1,??DataTable8_10
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_MutexDbgListAdd_0
    800                  p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_MutexDbgListAdd_1
    801              } else {
    802                  p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
   \                     ??OS_MutexDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable8_10
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    803                  OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
   \   0000001C   0x....             LDR.N    R1,??DataTable8_10
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    804              }
    805              OSMutexDbgListPtr                 =  p_mutex;
   \                     ??OS_MutexDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable8_10
   \   00000024   0x6008             STR      R0,[R1, #+0]
    806          }
   \   00000026   0x4770             BX       LR               ;; return
    807          
    808          
    809          

   \                                 In section .text, align 2, keep-with-next
    810          void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
    811          {
    812              OS_MUTEX  *p_mutex_next;
    813              OS_MUTEX  *p_mutex_prev;
    814          
    815          
    816              p_mutex_prev = p_mutex->DbgPrevPtr;
   \                     OS_MutexDbgListRemove: (+1)
   \   00000000   0x6943             LDR      R3,[R0, #+20]
   \   00000002   0x001A             MOVS     R2,R3
    817              p_mutex_next = p_mutex->DbgNextPtr;
   \   00000004   0x6983             LDR      R3,[R0, #+24]
   \   00000006   0x0019             MOVS     R1,R3
    818          
    819              if (p_mutex_prev == (OS_MUTEX *)0) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??OS_MutexDbgListRemove_0
    820                  OSMutexDbgListPtr = p_mutex_next;
   \   0000000C   0x....             LDR.N    R3,??DataTable8_10
   \   0000000E   0x6019             STR      R1,[R3, #+0]
    821                  if (p_mutex_next != (OS_MUTEX *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??OS_MutexDbgListRemove_1
    822                      p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x614B             STR      R3,[R1, #+20]
    823                  }
    824                  p_mutex->DbgNextPtr = (OS_MUTEX *)0;
   \                     ??OS_MutexDbgListRemove_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6183             STR      R3,[R0, #+24]
   \   0000001C   0xE00C             B.N      ??OS_MutexDbgListRemove_2
    825          
    826              } else if (p_mutex_next == (OS_MUTEX *)0) {
   \                     ??OS_MutexDbgListRemove_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_MutexDbgListRemove_3
    827                  p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x6193             STR      R3,[R2, #+24]
    828                  p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x6143             STR      R3,[R0, #+20]
   \   0000002A   0xE005             B.N      ??OS_MutexDbgListRemove_2
    829          
    830              } else {
    831                  p_mutex_prev->DbgNextPtr =  p_mutex_next;
   \                     ??OS_MutexDbgListRemove_3: (+1)
   \   0000002C   0x6191             STR      R1,[R2, #+24]
    832                  p_mutex_next->DbgPrevPtr =  p_mutex_prev;
   \   0000002E   0x614A             STR      R2,[R1, #+20]
    833                  p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x6183             STR      R3,[R0, #+24]
    834                  p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x6143             STR      R3,[R0, #+20]
    835              }
    836          }
   \                     ??OS_MutexDbgListRemove_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    837          #endif
    838          
    839          /*$PAGE*/
    840          /*
    841          ************************************************************************************************************************
    842          *                                                MUTEX INITIALIZATION
    843          *
    844          * Description: This function is called by OSInit() to initialize the mutex management.
    845          *
    846          
    847          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
    848          *
    849          *                                OS_ERR_NONE     the call was successful
    850          *
    851          * Returns    : none
    852          *
    853          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    854          ************************************************************************************************************************
    855          */
    856          

   \                                 In section .text, align 2, keep-with-next
    857          void  OS_MutexInit (OS_ERR  *p_err)
    858          {
    859          #ifdef OS_SAFETY_CRITICAL
    860              if (p_err == (OS_ERR *)0) {
    861                  OS_SAFETY_CRITICAL_EXCEPTION();
    862                  return;
    863              }
    864          #endif
    865          
    866          #if OS_CFG_DBG_EN > 0u
    867              OSMutexDbgListPtr = (OS_MUTEX *)0;
   \                     OS_MutexInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable8_10
   \   00000004   0x6011             STR      R1,[R2, #+0]
    868          #endif
    869          
    870              OSMutexQty        = (OS_OBJ_QTY)0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable8_4
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    871             *p_err             =  OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    872          }
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x5854554D         DC32     0x5854554d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSMutexQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     OSMutexDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x4D          DC8 "?MUTEX"
   \              0x55 0x54    
   \              0x45 0x58    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
    873          
    874          #endif                                                      /* OS_CFG_MUTEX_EN                                        */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSMutexCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MutexDbgListAdd
        24   -> OS_PendListInit
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      48   OSMutexDel
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_TS_TmrRd
        48   -> OSSched
        48   -> OS_MutexClr
        48   -> OS_MutexDbgListRemove
        48   -> OS_PendListChangePrio
        48   -> OS_PendObjDel
        48   -> OS_PrioInsert
        48   -> OS_RdyListInsertTail
        48   -> OS_RdyListRemove
        48   -> OS_Sched0
        48   -> OS_SchedLockTimeMeasStart
        48   -> OS_SchedLockTimeMeasStop
      64   OSMutexPend
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OS_Pend
        64   -> OS_PendListChangePrio
        64   -> OS_PrioInsert
        64   -> OS_RdyListInsertHead
        64   -> OS_RdyListRemove
        64   -> OS_Sched0
        64   -> OS_SchedLockTimeMeasStart
        64   -> OS_SchedLockTimeMeasStop
      40   OSMutexPendAbort
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_PendAbort
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
      40   OSMutexPost
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_Post
        40   -> OS_PrioInsert
        40   -> OS_RdyListInsertTail
        40   -> OS_RdyListRemove
        40   -> OS_Sched0
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
       8   OS_MutexClr
         8   -> OS_PendListInit
       0   OS_MutexDbgListAdd
       0   OS_MutexDbgListRemove
       0   OS_MutexInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       8  ?_0
       2  ?_1
     198  OSMutexCreate
     810  OSMutexDel
     756  OSMutexPend
     288  OSMutexPendAbort
     540  OSMutexPost
      42  OS_MutexClr
      40  OS_MutexDbgListAdd
      58  OS_MutexDbgListRemove
      18  OS_MutexInit

 
    10 bytes in section .rodata
 2 794 bytes in section .text
 
 2 794 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
