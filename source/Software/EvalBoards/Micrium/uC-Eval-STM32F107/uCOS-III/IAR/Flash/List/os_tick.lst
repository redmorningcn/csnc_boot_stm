###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_tick.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_tick.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_tick.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_tick.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_tick.c
      1          /*
      2          ***********************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TICK MANAGEMENT
     10          *
     11          * File    : OS_TICK.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_tick__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                  LOCAL PROTOTYPES
     43          ************************************************************************************************************************
     44          */
     45          
     46          
     47          /*
     48          ************************************************************************************************************************
     49          *                                                      TICK TASK
     50          *
     51          * Description: This task is internal to uC/OS-III and is triggered by the tick interrupt.
     52          *
     53          * Arguments  : p_arg     is an argument passed to the task when the task is created (unused).
     54          *
     55          * Returns    : none
     56          *
     57          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
     58          ************************************************************************************************************************
     59          */
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void  OS_TickTask (void  *p_arg)
     62          {
   \                     OS_TickTask: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     63              OS_ERR  err;
     64              CPU_TS  ts;
     65          
     66          
     67              p_arg = p_arg;                                          /* Prevent compiler warning                               */
     68          
     69              while (DEF_ON) {
     70                  (void)OSTaskSemPend((OS_TICK  )0,
     71                                      (OS_OPT   )OS_OPT_PEND_BLOCKING,
     72                                      (CPU_TS  *)&ts,
     73                                      (OS_ERR  *)&err);               /* Wait for signal from tick interrupt                    */
   \                     ??OS_TickTask_0: (+1)
   \   00000004   0x466B             MOV      R3,SP
   \   00000006   0xAA01             ADD      R2,SP,#+4
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       OSTaskSemPend
     74                  if (err == OS_ERR_NONE) {
   \   00000010   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1F5             BNE.N    ??OS_TickTask_0
     75                      if (OSRunning == OS_STATE_OS_RUNNING) {
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD1F0             BNE.N    ??OS_TickTask_0
     76                          OS_TickListUpdate();                        /* Update all tasks waiting for time                      */
   \   00000022   0x.... 0x....      BL       OS_TickListUpdate
   \   00000026   0xE7ED             B.N      ??OS_TickTask_0
     77                      }
     78                  }
     79              }
     80          }
     81          
     82          /*$PAGE*/
     83          /*
     84          ************************************************************************************************************************
     85          *                                                 INITIALIZE TICK TASK
     86          *
     87          * Description: This function is called by OSInit() to create the tick task.
     88          *
     89          * Arguments  : p_err   is a pointer to a variable that will hold the value of an error code:
     90          *
     91          *                          OS_ERR_TICK_STK_INVALID   if the pointer to the tick task stack is a NULL pointer
     92          *                          OS_ERR_TICK_STK_SIZE      indicates that the specified stack size
     93          *                          OS_ERR_PRIO_INVALID       if the priority you specified in the configuration is invalid
     94          *                                                      (There could be only one task at the Idle Task priority)
     95          *                                                      (Maybe the priority you specified is higher than OS_CFG_PRIO_MAX-1
     96          *                          OS_ERR_??                 other error code returned by OSTaskCreate()
     97          *
     98          * Returns    : none
     99          *
    100          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    101          ************************************************************************************************************************
    102          */
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void  OS_TickTaskInit (OS_ERR  *p_err)
    105          {
   \                     OS_TickTaskInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    106          #ifdef OS_SAFETY_CRITICAL
    107              if (p_err == (OS_ERR *)0) {
    108                  OS_SAFETY_CRITICAL_EXCEPTION();
    109                  return;
    110              }
    111          #endif
    112          
    113              OSTickCtr         = (OS_TICK)0u;                        /* Clear the tick counter                                 */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    114          
    115              OSTickTaskTimeMax = (CPU_TS)0u;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    116          
    117          
    118              OS_TickListInit();                                      /* Initialize the tick list data structures               */
   \   00000016   0x.... 0x....      BL       OS_TickListInit
    119          
    120                                                                      /* ---------------- CREATE THE TICK TASK ---------------- */
    121              if (OSCfg_TickTaskStkBasePtr == (CPU_STK *)0) {
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD103             BNE.N    ??OS_TickTaskInit_0
    122                 *p_err = OS_ERR_TICK_STK_INVALID;
   \   00000024   0xF247 0x2012      MOVW     R0,#+29202
   \   00000028   0x8020             STRH     R0,[R4, #+0]
    123                  return;
   \   0000002A   0xE036             B.N      ??OS_TickTaskInit_1
    124              }
    125          
    126              if (OSCfg_TickTaskStkSize < OSCfg_StkSizeMin) {
   \                     ??OS_TickTaskInit_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable5_4
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable5_5
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD203             BCS.N    ??OS_TickTaskInit_2
    127                 *p_err = OS_ERR_TICK_STK_SIZE_INVALID;
   \   0000003C   0xF247 0x2013      MOVW     R0,#+29203
   \   00000040   0x8020             STRH     R0,[R4, #+0]
    128                  return;
   \   00000042   0xE02A             B.N      ??OS_TickTaskInit_1
    129              }
    130          
    131              if (OSCfg_TickTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {     /* Only one task at the 'Idle Task' priority              */
   \                     ??OS_TickTaskInit_2: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable5_6
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x281F             CMP      R0,#+31
   \   0000004C   0xD303             BCC.N    ??OS_TickTaskInit_3
    132                 *p_err = OS_ERR_TICK_PRIO_INVALID;
   \   0000004E   0xF247 0x2011      MOVW     R0,#+29201
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    133                  return;
   \   00000054   0xE021             B.N      ??OS_TickTaskInit_1
    134              }
    135          
    136              OSTaskCreate((OS_TCB     *)&OSTickTaskTCB,
    137                           (CPU_CHAR   *)((void *)"uC/OS-III Tick Task"),
    138                           (OS_TASK_PTR )OS_TickTask,
    139                           (void       *)0,
    140                           (OS_PRIO     )OSCfg_TickTaskPrio,
    141                           (CPU_STK    *)OSCfg_TickTaskStkBasePtr,
    142                           (CPU_STK_SIZE)OSCfg_TickTaskStkLimit,
    143                           (CPU_STK_SIZE)OSCfg_TickTaskStkSize,
    144                           (OS_MSG_QTY  )0u,
    145                           (OS_TICK     )0u,
    146                           (void       *)0,
    147                           (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
    148                           (OS_ERR     *)p_err);
   \                     ??OS_TickTaskInit_3: (+1)
   \   00000056   0x9408             STR      R4,[SP, #+32]
   \   00000058   0x200B             MOVS     R0,#+11
   \   0000005A   0x9007             STR      R0,[SP, #+28]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9006             STR      R0,[SP, #+24]
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x9005             STR      R0,[SP, #+20]
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x9004             STR      R0,[SP, #+16]
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable5_4
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x9003             STR      R0,[SP, #+12]
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable5_7
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x9002             STR      R0,[SP, #+8]
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x9001             STR      R0,[SP, #+4]
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable5_6
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0x2300             MOVS     R3,#+0
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable5_8
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable5_9
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable5_10
   \   00000096   0x.... 0x....      BL       OSTaskCreate
    149          }
   \                     ??OS_TickTaskInit_1: (+1)
   \   0000009A   0xB00A             ADD      SP,SP,#+40
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
    150          
    151          /*$PAGE*/
    152          /*
    153          ************************************************************************************************************************
    154          *                                               INITIALIZE THE TICK LIST
    155          *
    156          * Description: This function initializes the tick handling data structures of uC/OS-III.
    157          *
    158          * Arguments  : none
    159          *
    160          * Returns    : None
    161          *
    162          * Note(s)    : This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    163          ************************************************************************************************************************
    164          */
    165          

   \                                 In section .text, align 2, keep-with-next
    166          void  OS_TickListInit (void)
    167          {
    168              OS_TICK_SPOKE_IX   i;
    169              OS_TICK_SPOKE     *p_spoke;
    170          
    171          
    172          
    173              for (i = 0u; i < OSCfg_TickWheelSize; i++) {
   \                     OS_TickListInit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x0010             MOVS     R0,R2
   \                     ??OS_TickListInit_0: (+1)
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable5_11
   \   00000008   0x8812             LDRH     R2,[R2, #+0]
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4290             CMP      R0,R2
   \   0000000E   0xD20D             BCS.N    ??OS_TickListInit_1
    174                  p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable5_12
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   0000001A   0x0011             MOVS     R1,R2
    175                  p_spoke->FirstPtr      = (OS_TCB        *)0;
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x600A             STR      R2,[R1, #+0]
    176                  p_spoke->NbrEntries    = (OS_OBJ_QTY     )0u;
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x808A             STRH     R2,[R1, #+4]
    177                  p_spoke->NbrEntriesMax = (OS_OBJ_QTY     )0u;
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x80CA             STRH     R2,[R1, #+6]
    178              }
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0xE7EB             B.N      ??OS_TickListInit_0
    179          }
   \                     ??OS_TickListInit_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
    180          
    181          /*$PAGE*/
    182          /*
    183          ************************************************************************************************************************
    184          *                                                ADD TASK TO TICK LIST
    185          *
    186          * Description: This function is called to place a task in a list of task waiting for either time to expire or waiting to
    187          *              timeout on a pend call.
    188          *
    189          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to add to the tick list
    190          *              -----
    191          *
    192          *              time           represents either the 'match' value of OSTickCtr or a relative time from the current
    193          *                             value of OSTickCtr as specified by the 'opt' argument..
    194          *
    195          *                             relative when 'opt' is set to OS_OPT_TIME_DLY
    196          *                             relative when 'opt' is set to OS_OPT_TIME_TIMEOUT
    197          *                             match    when 'opt' is set to OS_OPT_TIME_MATCH
    198          *                             periodic when 'opt' is set to OS_OPT_TIME_PERIODIC
    199          *
    200          *              opt            is an option specifying how to calculate time.  The valid values are:
    201          *              ---
    202          *                                 OS_OPT_TIME_DLY
    203          *                                 OS_OPT_TIME_TIMEOUT
    204          *                                 OS_OPT_TIME_PERIODIC
    205          *                                 OS_OPT_TIME_MATCH
    206          *
    207          *              p_err          is a pointer to a variable that will contain an error code returned by this function.
    208          *              -----
    209          *                                 OS_ERR_NONE           the call was successful and the time delay was scheduled.
    210          *                                 OS_ERR_TIME_ZERO_DLY  if delay is zero or already occurred.
    211          *
    212          * Returns    : None
    213          *
    214          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    215          *
    216          *              2) This function is assumed to be called with interrupts disabled.
    217          ************************************************************************************************************************
    218          */
    219          

   \                                 In section .text, align 2, keep-with-next
    220          void  OS_TickListInsert (OS_TCB   *p_tcb,
    221                                   OS_TICK   time,
    222                                   OS_OPT    opt,
    223                                   OS_ERR   *p_err)
    224          {
   \                     OS_TickListInsert: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    225              OS_TICK            tick_delta;
    226              OS_TICK            tick_next;
    227              OS_TICK_SPOKE     *p_spoke;
    228              OS_TCB            *p_tcb0;
    229              OS_TCB            *p_tcb1;
    230              OS_TICK_SPOKE_IX   spoke;
    231          
    232          
    233          
    234              if (opt == OS_OPT_TIME_MATCH) {                              /* Task time is absolute.                            */
   \   00000004   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000006   0x2A04             CMP      R2,#+4
   \   00000008   0xD123             BNE.N    ??OS_TickListInsert_0
    235                  tick_delta = time - OSTickCtr - 1u;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable5_1
   \   0000000E   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   00000012   0xEBB1 0x0808      SUBS     R8,R1,R8
   \   00000016   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000001A   0x4644             MOV      R4,R8
    236                  if (tick_delta > OS_TICK_TH_RDY) {                       /* If delay already occurred, ...                    */
   \   0000001C   0x.... 0x....      LDR.W    R8,??DataTable5_13  ;; 0xffff0001
   \   00000020   0x4544             CMP      R4,R8
   \   00000022   0xD310             BCC.N    ??OS_TickListInsert_1
    237                      p_tcb->TickCtrMatch = (OS_TICK        )0u;
   \   00000024   0xF05F 0x0800      MOVS     R8,#+0
   \   00000028   0xF8C0 0x804C      STR      R8,[R0, #+76]
    238                      p_tcb->TickRemain   = (OS_TICK        )0u;
   \   0000002C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000030   0xF8C0 0x8050      STR      R8,[R0, #+80]
    239                      p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
   \   00000034   0xF05F 0x0800      MOVS     R8,#+0
   \   00000038   0xF8C0 0x801C      STR      R8,[R0, #+28]
    240                     *p_err               =  OS_ERR_TIME_ZERO_DLY;         /* ... do NOT delay.                                 */
   \   0000003C   0xF247 0x287E      MOVW     R8,#+29310
   \   00000040   0xF8A3 0x8000      STRH     R8,[R3, #+0]
    241                      return;
   \   00000044   0xE0CE             B.N      ??OS_TickListInsert_2
    242                  }
    243                  p_tcb->TickCtrMatch = time;
   \                     ??OS_TickListInsert_1: (+1)
   \   00000046   0x64C1             STR      R1,[R0, #+76]
    244                  p_tcb->TickRemain   = tick_delta + 1u;
   \   00000048   0xF114 0x0801      ADDS     R8,R4,#+1
   \   0000004C   0xF8C0 0x8050      STR      R8,[R0, #+80]
   \   00000050   0xE048             B.N      ??OS_TickListInsert_3
    245          
    246              } else if (time > (OS_TICK)0u) {
   \                     ??OS_TickListInsert_0: (+1)
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD035             BEQ.N    ??OS_TickListInsert_4
    247                  if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
   \   00000056   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000058   0x2A08             CMP      R2,#+8
   \   0000005A   0xD128             BNE.N    ??OS_TickListInsert_5
    248                      tick_next  = p_tcb->TickCtrPrev + time;
   \   0000005C   0xF8D0 0x8048      LDR      R8,[R0, #+72]
   \   00000060   0xEB11 0x0808      ADDS     R8,R1,R8
   \   00000064   0x4645             MOV      R5,R8
    249                      tick_delta = tick_next - OSTickCtr - 1u;
   \   00000066   0x.... 0x....      LDR.W    R8,??DataTable5_1
   \   0000006A   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   0000006E   0xEBB5 0x0808      SUBS     R8,R5,R8
   \   00000072   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000076   0x4644             MOV      R4,R8
    250                      if (tick_delta < time) {                             /* If next periodic delay did NOT already occur, ... */
   \   00000078   0x428C             CMP      R4,R1
   \   0000007A   0xD201             BCS.N    ??OS_TickListInsert_6
    251                          p_tcb->TickCtrMatch = tick_next;                 /* ... set  next  periodic delay;                ... */
   \   0000007C   0x64C5             STR      R5,[R0, #+76]
   \   0000007E   0xE007             B.N      ??OS_TickListInsert_7
    252                      } else {
    253                          p_tcb->TickCtrMatch = OSTickCtr + time;          /* ... else reset periodic delay.                    */
   \                     ??OS_TickListInsert_6: (+1)
   \   00000080   0x.... 0x....      LDR.W    R8,??DataTable5_1
   \   00000084   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   00000088   0xEB11 0x0808      ADDS     R8,R1,R8
   \   0000008C   0xF8C0 0x804C      STR      R8,[R0, #+76]
    254                      }
    255                      p_tcb->TickRemain   = p_tcb->TickCtrMatch - OSTickCtr;
   \                     ??OS_TickListInsert_7: (+1)
   \   00000090   0xF8D0 0x804C      LDR      R8,[R0, #+76]
   \   00000094   0x.... 0x....      LDR.W    R9,??DataTable5_1
   \   00000098   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   0000009C   0xEBB8 0x0809      SUBS     R8,R8,R9
   \   000000A0   0xF8C0 0x8050      STR      R8,[R0, #+80]
    256                      p_tcb->TickCtrPrev  = p_tcb->TickCtrMatch;
   \   000000A4   0xF8D0 0x804C      LDR      R8,[R0, #+76]
   \   000000A8   0xF8C0 0x8048      STR      R8,[R0, #+72]
   \   000000AC   0xE01A             B.N      ??OS_TickListInsert_3
    257          
    258                  } else {                                                 /* Task time is relative to current.                 */
    259                      p_tcb->TickCtrMatch = OSTickCtr + time;
   \                     ??OS_TickListInsert_5: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R8,??DataTable5_1
   \   000000B2   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \   000000B6   0xEB11 0x0808      ADDS     R8,R1,R8
   \   000000BA   0xF8C0 0x804C      STR      R8,[R0, #+76]
    260                      p_tcb->TickRemain   = time;
   \   000000BE   0x6501             STR      R1,[R0, #+80]
   \   000000C0   0xE010             B.N      ??OS_TickListInsert_3
    261                  }
    262          
    263              } else {                                                     /* Zero time delay; ...                              */
    264                  p_tcb->TickCtrMatch = (OS_TICK        )0u;
   \                     ??OS_TickListInsert_4: (+1)
   \   000000C2   0xF05F 0x0800      MOVS     R8,#+0
   \   000000C6   0xF8C0 0x804C      STR      R8,[R0, #+76]
    265                  p_tcb->TickRemain   = (OS_TICK        )0u;
   \   000000CA   0xF05F 0x0800      MOVS     R8,#+0
   \   000000CE   0xF8C0 0x8050      STR      R8,[R0, #+80]
    266                  p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
   \   000000D2   0xF05F 0x0800      MOVS     R8,#+0
   \   000000D6   0xF8C0 0x801C      STR      R8,[R0, #+28]
    267                 *p_err               =  OS_ERR_TIME_ZERO_DLY;             /* ... do NOT delay.                                 */
   \   000000DA   0xF247 0x287E      MOVW     R8,#+29310
   \   000000DE   0xF8A3 0x8000      STRH     R8,[R3, #+0]
    268                  return;
   \   000000E2   0xE07F             B.N      ??OS_TickListInsert_2
    269              }
    270          
    271          
    272              spoke   = (OS_TICK_SPOKE_IX)(p_tcb->TickCtrMatch % OSCfg_TickWheelSize);
   \                     ??OS_TickListInsert_3: (+1)
   \   000000E4   0xF8D0 0x804C      LDR      R8,[R0, #+76]
   \   000000E8   0x.... 0x....      LDR.W    R9,??DataTable5_11
   \   000000EC   0xF8B9 0x9000      LDRH     R9,[R9, #+0]
   \   000000F0   0xFBB8 0xFAF9      UDIV     R10,R8,R9
   \   000000F4   0xFB09 0x881A      MLS      R8,R9,R10,R8
   \   000000F8   0x46C6             MOV      LR,R8
    273              p_spoke = &OSCfg_TickWheel[spoke];
   \   000000FA   0x.... 0x....      LDR.W    R8,??DataTable5_12
   \   000000FE   0xFA1F 0xFE8E      UXTH     LR,LR            ;; ZeroExt  LR,LR,#+16,#+16
   \   00000102   0xEB18 0x08CE      ADDS     R8,R8,LR, LSL #+3
   \   00000106   0x4646             MOV      R6,R8
    274          
    275              if (p_spoke->NbrEntries == (OS_OBJ_QTY)0u) {                 /* First entry in the spoke                          */
   \   00000108   0xF8B6 0x8004      LDRH     R8,[R6, #+4]
   \   0000010C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000110   0xD10D             BNE.N    ??OS_TickListInsert_8
    276                  p_tcb->TickNextPtr   = (OS_TCB   *)0;
   \   00000112   0xF05F 0x0800      MOVS     R8,#+0
   \   00000116   0xF8C0 0x8014      STR      R8,[R0, #+20]
    277                  p_tcb->TickPrevPtr   = (OS_TCB   *)0;
   \   0000011A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000011E   0xF8C0 0x8018      STR      R8,[R0, #+24]
    278                  p_spoke->FirstPtr    =  p_tcb;
   \   00000122   0x6030             STR      R0,[R6, #+0]
    279                  p_spoke->NbrEntries  = (OS_OBJ_QTY)1u;
   \   00000124   0xF05F 0x0801      MOVS     R8,#+1
   \   00000128   0xF8A6 0x8004      STRH     R8,[R6, #+4]
   \   0000012C   0xE04B             B.N      ??OS_TickListInsert_9
    280              } else {
    281                  p_tcb1     = p_spoke->FirstPtr;                          /* Point to current first TCB in the list            */
   \                     ??OS_TickListInsert_8: (+1)
   \   0000012E   0xF8D6 0x8000      LDR      R8,[R6, #+0]
   \   00000132   0x46C4             MOV      R12,R8
    282                  while (p_tcb1 != (OS_TCB *)0) {
   \                     ??OS_TickListInsert_10: (+1)
   \   00000134   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000138   0xD03F             BEQ.N    ??OS_TickListInsert_11
    283                      p_tcb1->TickRemain = p_tcb1->TickCtrMatch            /* Compute time remaining of current TCB in list     */
    284                                         - OSTickCtr;
   \   0000013A   0xF8DC 0x804C      LDR      R8,[R12, #+76]
   \   0000013E   0x.... 0x....      LDR.W    R9,??DataTable5_1
   \   00000142   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \   00000146   0xEBB8 0x0809      SUBS     R8,R8,R9
   \   0000014A   0xF8CC 0x8050      STR      R8,[R12, #+80]
    285                      if (p_tcb->TickRemain > p_tcb1->TickRemain) {        /* Do we need to insert AFTER current TCB in list?   */
   \   0000014E   0xF8DC 0x8050      LDR      R8,[R12, #+80]
   \   00000152   0xF8D0 0x9050      LDR      R9,[R0, #+80]
   \   00000156   0x45C8             CMP      R8,R9
   \   00000158   0xD213             BCS.N    ??OS_TickListInsert_12
    286                          if (p_tcb1->TickNextPtr != (OS_TCB *)0) {        /* Yes, are we pointing at the last TCB in the list? */
   \   0000015A   0xF8DC 0x8014      LDR      R8,[R12, #+20]
   \   0000015E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000162   0xD002             BEQ.N    ??OS_TickListInsert_13
    287                              p_tcb1               =  p_tcb1->TickNextPtr; /* No,  Point to next TCB in the list                */
   \   00000164   0xF8DC 0xC014      LDR      R12,[R12, #+20]
   \   00000168   0xE7E4             B.N      ??OS_TickListInsert_10
    288                          } else {
    289                              p_tcb->TickNextPtr   = (OS_TCB *)0;
   \                     ??OS_TickListInsert_13: (+1)
   \   0000016A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000016E   0xF8C0 0x8014      STR      R8,[R0, #+20]
    290                              p_tcb->TickPrevPtr   =  p_tcb1;
   \   00000172   0xF8C0 0xC018      STR      R12,[R0, #+24]
    291                              p_tcb1->TickNextPtr  =  p_tcb;               /* Yes, TCB to add is now new last entry in the list */
   \   00000176   0xF8CC 0x0014      STR      R0,[R12, #+20]
    292                              p_tcb1               = (OS_TCB *)0;          /* Break loop                                        */
   \   0000017A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000017E   0x46C4             MOV      R12,R8
   \   00000180   0xE7D8             B.N      ??OS_TickListInsert_10
    293                          }
    294                      } else {                                             /* Insert before the current TCB                     */
    295                          if (p_tcb1->TickPrevPtr == (OS_TCB *)0) {        /* Are we inserting before the first TCB?            */
   \                     ??OS_TickListInsert_12: (+1)
   \   00000182   0xF8DC 0x8018      LDR      R8,[R12, #+24]
   \   00000186   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000018A   0xD109             BNE.N    ??OS_TickListInsert_14
    296                              p_tcb->TickPrevPtr   = (OS_TCB *)0;
   \   0000018C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000190   0xF8C0 0x8018      STR      R8,[R0, #+24]
    297                              p_tcb->TickNextPtr   =  p_tcb1;
   \   00000194   0xF8C0 0xC014      STR      R12,[R0, #+20]
    298                              p_tcb1->TickPrevPtr  =  p_tcb;
   \   00000198   0xF8CC 0x0018      STR      R0,[R12, #+24]
    299                              p_spoke->FirstPtr    =  p_tcb;
   \   0000019C   0x6030             STR      R0,[R6, #+0]
   \   0000019E   0xE008             B.N      ??OS_TickListInsert_15
    300                          } else {                                         /* Insert in between 2 TCBs already in the list      */
    301                              p_tcb0               =  p_tcb1->TickPrevPtr;
   \                     ??OS_TickListInsert_14: (+1)
   \   000001A0   0xF8DC 0x8018      LDR      R8,[R12, #+24]
   \   000001A4   0x4647             MOV      R7,R8
    302                              p_tcb->TickPrevPtr   =  p_tcb0;
   \   000001A6   0x6187             STR      R7,[R0, #+24]
    303                              p_tcb->TickNextPtr   =  p_tcb1;
   \   000001A8   0xF8C0 0xC014      STR      R12,[R0, #+20]
    304                              p_tcb0->TickNextPtr  =  p_tcb;
   \   000001AC   0x6178             STR      R0,[R7, #+20]
    305                              p_tcb1->TickPrevPtr  =  p_tcb;
   \   000001AE   0xF8CC 0x0018      STR      R0,[R12, #+24]
    306                          }
    307                          p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
   \                     ??OS_TickListInsert_15: (+1)
   \   000001B2   0xF05F 0x0800      MOVS     R8,#+0
   \   000001B6   0x46C4             MOV      R12,R8
   \   000001B8   0xE7BC             B.N      ??OS_TickListInsert_10
    308                      }
    309                  }
    310                  p_spoke->NbrEntries++;
   \                     ??OS_TickListInsert_11: (+1)
   \   000001BA   0xF8B6 0x8004      LDRH     R8,[R6, #+4]
   \   000001BE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000001C2   0xF8A6 0x8004      STRH     R8,[R6, #+4]
    311              }
    312              if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {          /* Keep track of maximum # of entries in each spoke  */
   \                     ??OS_TickListInsert_9: (+1)
   \   000001C6   0xF8B6 0x8006      LDRH     R8,[R6, #+6]
   \   000001CA   0xF8B6 0x9004      LDRH     R9,[R6, #+4]
   \   000001CE   0x45C8             CMP      R8,R9
   \   000001D0   0xD203             BCS.N    ??OS_TickListInsert_16
    313                  p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
   \   000001D2   0xF8B6 0x8004      LDRH     R8,[R6, #+4]
   \   000001D6   0xF8A6 0x8006      STRH     R8,[R6, #+6]
    314              }
    315              p_tcb->TickSpokePtr = p_spoke;                               /* Link back to tick spoke                           */
   \                     ??OS_TickListInsert_16: (+1)
   \   000001DA   0x61C6             STR      R6,[R0, #+28]
    316             *p_err               = OS_ERR_NONE;
   \   000001DC   0xF05F 0x0800      MOVS     R8,#+0
   \   000001E0   0xF8A3 0x8000      STRH     R8,[R3, #+0]
    317          }
   \                     ??OS_TickListInsert_2: (+1)
   \   000001E4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    318          
    319          /*$PAGE*/
    320          /*
    321          ************************************************************************************************************************
    322          *                                         REMOVE A TASK FROM THE TICK LIST
    323          *
    324          * Description: This function is called to remove a task from the tick list
    325          *
    326          * Arguments  : p_tcb          Is a pointer to the OS_TCB to remove.
    327          *              -----
    328          *
    329          * Returns    : none
    330          *
    331          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    332          *
    333          *              2) This function is assumed to be called with interrupts disabled.
    334          ************************************************************************************************************************
    335          */
    336          

   \                                 In section .text, align 2, keep-with-next
    337          void  OS_TickListRemove (OS_TCB  *p_tcb)
    338          {
   \                     OS_TickListRemove: (+1)
   \   00000000   0xB410             PUSH     {R4}
    339              OS_TICK_SPOKE  *p_spoke;
    340              OS_TCB         *p_tcb1;
    341              OS_TCB         *p_tcb2;
    342          
    343          
    344          
    345              p_spoke = p_tcb->TickSpokePtr;
   \   00000002   0x69C4             LDR      R4,[R0, #+28]
   \   00000004   0x0021             MOVS     R1,R4
    346              if (p_spoke != (OS_TICK_SPOKE *)0) {                              /* Confirm that task is in tick list            */
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD01F             BEQ.N    ??OS_TickListRemove_0
    347                  p_tcb->TickRemain = (OS_TICK)0u;
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x6504             STR      R4,[R0, #+80]
    348                  if (p_spoke->FirstPtr == p_tcb) {                             /* Is timer to remove at the beginning of list? */
   \   0000000E   0x680C             LDR      R4,[R1, #+0]
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD107             BNE.N    ??OS_TickListRemove_1
    349                      p_tcb1            = (OS_TCB *)p_tcb->TickNextPtr;         /* Yes                                          */
   \   00000014   0x6944             LDR      R4,[R0, #+20]
   \   00000016   0x0022             MOVS     R2,R4
    350                      p_spoke->FirstPtr = p_tcb1;
   \   00000018   0x600A             STR      R2,[R1, #+0]
    351                      if (p_tcb1 != (OS_TCB *)0) {
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD00A             BEQ.N    ??OS_TickListRemove_2
    352                          p_tcb1->TickPrevPtr = (OS_TCB *)0;
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x6194             STR      R4,[R2, #+24]
   \   00000022   0xE007             B.N      ??OS_TickListRemove_2
    353                      }
    354                  } else {
    355                      p_tcb1              = p_tcb->TickPrevPtr;                 /* No, remove timer from somewhere in the list  */
   \                     ??OS_TickListRemove_1: (+1)
   \   00000024   0x6984             LDR      R4,[R0, #+24]
   \   00000026   0x0022             MOVS     R2,R4
    356                      p_tcb2              = p_tcb->TickNextPtr;
   \   00000028   0x6944             LDR      R4,[R0, #+20]
   \   0000002A   0x0023             MOVS     R3,R4
    357                      p_tcb1->TickNextPtr = p_tcb2;
   \   0000002C   0x6153             STR      R3,[R2, #+20]
    358                      if (p_tcb2 != (OS_TCB *)0) {
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD000             BEQ.N    ??OS_TickListRemove_2
    359                          p_tcb2->TickPrevPtr = p_tcb1;
   \   00000032   0x619A             STR      R2,[R3, #+24]
    360                      }
    361                  }
    362                  p_tcb->TickNextPtr  = (OS_TCB        *)0;
   \                     ??OS_TickListRemove_2: (+1)
   \   00000034   0x2400             MOVS     R4,#+0
   \   00000036   0x6144             STR      R4,[R0, #+20]
    363                  p_tcb->TickPrevPtr  = (OS_TCB        *)0;
   \   00000038   0x2400             MOVS     R4,#+0
   \   0000003A   0x6184             STR      R4,[R0, #+24]
    364                  p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0x61C4             STR      R4,[R0, #+28]
    365                  p_tcb->TickCtrMatch = (OS_TICK        )0u;
   \   00000040   0x2400             MOVS     R4,#+0
   \   00000042   0x64C4             STR      R4,[R0, #+76]
    366                  p_spoke->NbrEntries--;
   \   00000044   0x888C             LDRH     R4,[R1, #+4]
   \   00000046   0x1E64             SUBS     R4,R4,#+1
   \   00000048   0x808C             STRH     R4,[R1, #+4]
    367              }
    368          }
   \                     ??OS_TickListRemove_0: (+1)
   \   0000004A   0xBC10             POP      {R4}
   \   0000004C   0x4770             BX       LR               ;; return
    369          
    370          /*$PAGE*/
    371          /*
    372          ************************************************************************************************************************
    373          *                                              RESET TICK LIST PEAK DETECTOR
    374          *
    375          * Description: This function is used to reset the peak detector for the number of entries in each spoke.
    376          *
    377          * Arguments  : void
    378          *
    379          * Returns    : none
    380          *
    381          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    382          ************************************************************************************************************************
    383          */
    384          
    385          

   \                                 In section .text, align 2, keep-with-next
    386          void  OS_TickListResetPeak (void)
    387          {
    388              OS_TICK_SPOKE_IX   i;
    389              OS_TICK_SPOKE     *p_spoke;
    390          
    391          
    392          
    393              for (i = 0u; i < OSCfg_TickWheelSize; i++) {
   \                     OS_TickListResetPeak: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x0010             MOVS     R0,R2
   \                     ??OS_TickListResetPeak_0: (+1)
   \   00000004   0x....             LDR.N    R2,??DataTable5_11
   \   00000006   0x8812             LDRH     R2,[R2, #+0]
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0x4290             CMP      R0,R2
   \   0000000C   0xD208             BCS.N    ??OS_TickListResetPeak_1
    394                  p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
   \   0000000E   0x....             LDR.N    R2,??DataTable5_12
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000016   0x0011             MOVS     R1,R2
    395                  p_spoke->NbrEntriesMax = (OS_OBJ_QTY     )0u;
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x80CA             STRH     R2,[R1, #+6]
    396              }
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xE7F1             B.N      ??OS_TickListResetPeak_0
    397          }
   \                     ??OS_TickListResetPeak_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    398          
    399          /*$PAGE*/
    400          /*
    401          ************************************************************************************************************************
    402          *                                                UPDATE THE TICK LIST
    403          *
    404          * Description: This function is called when a tick occurs and determines if the timeout waiting for a kernel object has
    405          *              expired or a delay has expired.
    406          *
    407          * Arguments  : non
    408          *
    409          * Returns    : none
    410          *
    411          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    412          ************************************************************************************************************************
    413          */
    414          

   \                                 In section .text, align 2, keep-with-next
    415          void  OS_TickListUpdate (void)
    416          {
   \                     OS_TickListUpdate: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    417              CPU_BOOLEAN        done;
    418              OS_TICK_SPOKE     *p_spoke;
    419              OS_TCB            *p_tcb;
    420              OS_TCB            *p_tcb_next;
    421              OS_TICK_SPOKE_IX   spoke;
    422              CPU_TS             ts_start;
    423              CPU_TS             ts_end;
    424              CPU_SR_ALLOC();
   \   00000004   0xF05F 0x0B00      MOVS     R11,#+0
    425          
    426          
    427              OS_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x4683             MOV      R11,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000012   0x....             LDR.N    R0,??DataTable5_14
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable5_14
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   \   0000001C   0x....             LDR.N    R0,??DataTable5_14
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD101             BNE.N    ??OS_TickListUpdate_0
   \   00000024   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_TickListUpdate_0: (+1)
   \   00000028   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002C   0x4658             MOV      R0,R11
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
    428              ts_start = OS_TS_GET();
   \   00000032   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000036   0x4681             MOV      R9,R0
    429              OSTickCtr++;                                                       /* Keep track of the number of ticks           */
   \   00000038   0x....             LDR.N    R0,??DataTable5_1
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable5_1
   \   00000040   0x6008             STR      R0,[R1, #+0]
    430              spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);
   \   00000042   0x....             LDR.N    R0,??DataTable5_11
   \   00000044   0x8800             LDRH     R0,[R0, #+0]
   \   00000046   0x....             LDR.N    R1,??DataTable5_1
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x....             LDR.N    R2,??DataTable5_1
   \   0000004C   0x6812             LDR      R2,[R2, #+0]
   \   0000004E   0xFBB2 0xF2F0      UDIV     R2,R2,R0
   \   00000052   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   00000056   0x4680             MOV      R8,R0
    431              p_spoke  = &OSCfg_TickWheel[spoke];
   \   00000058   0x....             LDR.N    R0,??DataTable5_12
   \   0000005A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000005E   0xEB10 0x00C8      ADDS     R0,R0,R8, LSL #+3
   \   00000062   0x0005             MOVS     R5,R0
    432              p_tcb    = p_spoke->FirstPtr;
   \   00000064   0x6828             LDR      R0,[R5, #+0]
   \   00000066   0x0006             MOVS     R6,R0
    433              done     = DEF_FALSE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0004             MOVS     R4,R0
    434              while (done == DEF_FALSE) {
   \                     ??OS_TickListUpdate_1: (+1)
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xF040 0x808D      BNE.W    ??OS_TickListUpdate_2
    435                  if (p_tcb != (OS_TCB *)0) {
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xF000 0x8087      BEQ.W    ??OS_TickListUpdate_3
    436                      p_tcb_next = p_tcb->TickNextPtr;                           /* Point to next TCB to update                 */
   \   0000007A   0x6970             LDR      R0,[R6, #+20]
   \   0000007C   0x0007             MOVS     R7,R0
    437                      switch (p_tcb->TaskState) {
   \   0000007E   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD00B             BEQ.N    ??OS_TickListUpdate_4
   \   00000086   0x2802             CMP      R0,#+2
   \   00000088   0xD009             BEQ.N    ??OS_TickListUpdate_4
   \   0000008A   0xD309             BCC.N    ??OS_TickListUpdate_5
   \   0000008C   0x2804             CMP      R0,#+4
   \   0000008E   0xD006             BEQ.N    ??OS_TickListUpdate_4
   \   00000090   0xD31A             BCC.N    ??OS_TickListUpdate_6
   \   00000092   0x2806             CMP      R0,#+6
   \   00000094   0xD003             BEQ.N    ??OS_TickListUpdate_4
   \   00000096   0xD33C             BCC.N    ??OS_TickListUpdate_7
   \   00000098   0x2807             CMP      R0,#+7
   \   0000009A   0xD04E             BEQ.N    ??OS_TickListUpdate_8
   \   0000009C   0xE072             B.N      ??OS_TickListUpdate_9
    438                          case OS_TASK_STATE_RDY:
    439                          case OS_TASK_STATE_PEND:
    440                          case OS_TASK_STATE_SUSPENDED:
    441                          case OS_TASK_STATE_PEND_SUSPENDED:
    442                               break;
   \                     ??OS_TickListUpdate_4: (+1)
   \   0000009E   0xE071             B.N      ??OS_TickListUpdate_10
    443          
    444                          case OS_TASK_STATE_DLY:
    445                               p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
    446                                                 - OSTickCtr;
   \                     ??OS_TickListUpdate_5: (+1)
   \   000000A0   0x6CF0             LDR      R0,[R6, #+76]
   \   000000A2   0x....             LDR.N    R1,??DataTable5_1
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x1A40             SUBS     R0,R0,R1
   \   000000A8   0x6530             STR      R0,[R6, #+80]
    447                               if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
   \   000000AA   0x....             LDR.N    R0,??DataTable5_1
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x6CF1             LDR      R1,[R6, #+76]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD106             BNE.N    ??OS_TickListUpdate_11
    448                                   p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF886 0x0036      STRB     R0,[R6, #+54]
    449                                   OS_TaskRdy(p_tcb);                            /* Make task ready to run                      */
   \   000000BA   0x0030             MOVS     R0,R6
   \   000000BC   0x.... 0x....      BL       OS_TaskRdy
   \   000000C0   0xE001             B.N      ??OS_TickListUpdate_12
    450                               } else {
    451                                   done             = DEF_TRUE;                  /* Don't find a match, we're done!             */
   \                     ??OS_TickListUpdate_11: (+1)
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x0004             MOVS     R4,R0
    452                               }
    453                               break;
   \                     ??OS_TickListUpdate_12: (+1)
   \   000000C6   0xE05D             B.N      ??OS_TickListUpdate_10
    454          
    455                          case OS_TASK_STATE_PEND_TIMEOUT:
    456                               p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
    457                                                 - OSTickCtr;
   \                     ??OS_TickListUpdate_6: (+1)
   \   000000C8   0x6CF0             LDR      R0,[R6, #+76]
   \   000000CA   0x....             LDR.N    R1,??DataTable5_1
   \   000000CC   0x6809             LDR      R1,[R1, #+0]
   \   000000CE   0x1A40             SUBS     R0,R0,R1
   \   000000D0   0x6530             STR      R0,[R6, #+80]
    458                               if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
   \   000000D2   0x....             LDR.N    R0,??DataTable5_1
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x6CF1             LDR      R1,[R6, #+76]
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xD117             BNE.N    ??OS_TickListUpdate_13
    459          #if (OS_MSG_EN > 0u)
    460                                   p_tcb->MsgPtr     = (void      *)0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x65F0             STR      R0,[R6, #+92]
    461                                   p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xF8A6 0x0060      STRH     R0,[R6, #+96]
    462          #endif
    463                                   p_tcb->TS         = OS_TS_GET();
   \   000000E6   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000EA   0x6430             STR      R0,[R6, #+64]
    464                                   OS_PendListRemove(p_tcb);                     /* Remove from wait list                       */
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0x.... 0x....      BL       OS_PendListRemove
    465                                   OS_TaskRdy(p_tcb);
   \   000000F2   0x0030             MOVS     R0,R6
   \   000000F4   0x.... 0x....      BL       OS_TaskRdy
    466                                   p_tcb->TaskState  = OS_TASK_STATE_RDY;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF886 0x0036      STRB     R0,[R6, #+54]
    467                                   p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;   /* Indicate pend timed out                     */
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0xF886 0x0035      STRB     R0,[R6, #+53]
    468                                   p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;  /* Indicate no longer pending                  */
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF886 0x0034      STRB     R0,[R6, #+52]
   \   0000010A   0xE001             B.N      ??OS_TickListUpdate_14
    469                               } else {
    470                                   done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
   \                     ??OS_TickListUpdate_13: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x0004             MOVS     R4,R0
    471                               }
    472                               break;
   \                     ??OS_TickListUpdate_14: (+1)
   \   00000110   0xE038             B.N      ??OS_TickListUpdate_10
    473          
    474                          case OS_TASK_STATE_DLY_SUSPENDED:
    475                               p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
    476                                                 - OSTickCtr;
   \                     ??OS_TickListUpdate_7: (+1)
   \   00000112   0x6CF0             LDR      R0,[R6, #+76]
   \   00000114   0x....             LDR.N    R1,??DataTable5_1
   \   00000116   0x6809             LDR      R1,[R1, #+0]
   \   00000118   0x1A40             SUBS     R0,R0,R1
   \   0000011A   0x6530             STR      R0,[R6, #+80]
    477                               if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
   \   0000011C   0x....             LDR.N    R0,??DataTable5_1
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0x6CF1             LDR      R1,[R6, #+76]
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD106             BNE.N    ??OS_TickListUpdate_15
    478                                   p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \   00000126   0x2004             MOVS     R0,#+4
   \   00000128   0xF886 0x0036      STRB     R0,[R6, #+54]
    479                                   OS_TickListRemove(p_tcb);                     /* Remove from current wheel spoke             */
   \   0000012C   0x0030             MOVS     R0,R6
   \   0000012E   0x.... 0x....      BL       OS_TickListRemove
   \   00000132   0xE001             B.N      ??OS_TickListUpdate_16
    480                               } else {
    481                                   done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
   \                     ??OS_TickListUpdate_15: (+1)
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0x0004             MOVS     R4,R0
    482                               }
    483                               break;
   \                     ??OS_TickListUpdate_16: (+1)
   \   00000138   0xE024             B.N      ??OS_TickListUpdate_10
    484          
    485                          case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    486                               p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
    487                                                 - OSTickCtr;
   \                     ??OS_TickListUpdate_8: (+1)
   \   0000013A   0x6CF0             LDR      R0,[R6, #+76]
   \   0000013C   0x....             LDR.N    R1,??DataTable5_1
   \   0000013E   0x6809             LDR      R1,[R1, #+0]
   \   00000140   0x1A40             SUBS     R0,R0,R1
   \   00000142   0x6530             STR      R0,[R6, #+80]
    488                               if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
   \   00000144   0x....             LDR.N    R0,??DataTable5_1
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \   00000148   0x6CF1             LDR      R1,[R6, #+76]
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD117             BNE.N    ??OS_TickListUpdate_17
    489          #if (OS_MSG_EN > 0u)
    490                                   p_tcb->MsgPtr     = (void      *)0;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x65F0             STR      R0,[R6, #+92]
    491                                   p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF8A6 0x0060      STRH     R0,[R6, #+96]
    492          #endif
    493                                   p_tcb->TS         = OS_TS_GET();
   \   00000158   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000015C   0x6430             STR      R0,[R6, #+64]
    494                                   OS_PendListRemove(p_tcb);                     /* Remove from wait list                       */
   \   0000015E   0x0030             MOVS     R0,R6
   \   00000160   0x.... 0x....      BL       OS_PendListRemove
    495                                   OS_TickListRemove(p_tcb);                     /* Remove from current wheel spoke             */
   \   00000164   0x0030             MOVS     R0,R6
   \   00000166   0x.... 0x....      BL       OS_TickListRemove
    496                                   p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \   0000016A   0x2004             MOVS     R0,#+4
   \   0000016C   0xF886 0x0036      STRB     R0,[R6, #+54]
    497                                   p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;   /* Indicate pend timed out                     */
   \   00000170   0x2003             MOVS     R0,#+3
   \   00000172   0xF886 0x0035      STRB     R0,[R6, #+53]
    498                                   p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;  /* Indicate no longer pending                  */
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0xF886 0x0034      STRB     R0,[R6, #+52]
   \   0000017C   0xE001             B.N      ??OS_TickListUpdate_18
    499                               } else {
    500                                   done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
   \                     ??OS_TickListUpdate_17: (+1)
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0x0004             MOVS     R4,R0
    501                               }
    502                               break;
   \                     ??OS_TickListUpdate_18: (+1)
   \   00000182   0xE7FF             B.N      ??OS_TickListUpdate_10
    503          
    504                          default:
    505                               break;
    506                      }
    507                      p_tcb = p_tcb_next;
   \                     ??OS_TickListUpdate_9: (+1)
   \                     ??OS_TickListUpdate_10: (+1)
   \   00000184   0x003E             MOVS     R6,R7
   \   00000186   0xE771             B.N      ??OS_TickListUpdate_1
    508                  } else {
    509                      done  = DEF_TRUE;
   \                     ??OS_TickListUpdate_3: (+1)
   \   00000188   0x2001             MOVS     R0,#+1
   \   0000018A   0x0004             MOVS     R4,R0
   \   0000018C   0xE76E             B.N      ??OS_TickListUpdate_1
    510                  }
    511              }
    512              ts_end = OS_TS_GET() - ts_start;                                   /* Measure execution time of tick task         */
   \                     ??OS_TickListUpdate_2: (+1)
   \   0000018E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000192   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000196   0x4682             MOV      R10,R0
    513              if (OSTickTaskTimeMax < ts_end) {
   \   00000198   0x....             LDR.N    R0,??DataTable5_2
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0x4550             CMP      R0,R10
   \   0000019E   0xD202             BCS.N    ??OS_TickListUpdate_19
    514                  OSTickTaskTimeMax = ts_end;
   \   000001A0   0x....             LDR.N    R0,??DataTable5_2
   \   000001A2   0xF8C0 0xA000      STR      R10,[R0, #+0]
    515              }
    516              OS_CRITICAL_EXIT();
   \                     ??OS_TickListUpdate_19: (+1)
   \   000001A6   0x.... 0x....      BL       CPU_SR_Save
   \   000001AA   0x4683             MOV      R11,R0
   \   000001AC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001B0   0x....             LDR.N    R0,??DataTable5_14
   \   000001B2   0x7800             LDRB     R0,[R0, #+0]
   \   000001B4   0x1E40             SUBS     R0,R0,#+1
   \   000001B6   0x....             LDR.N    R1,??DataTable5_14
   \   000001B8   0x7008             STRB     R0,[R1, #+0]
   \   000001BA   0x....             LDR.N    R0,??DataTable5_14
   \   000001BC   0x7800             LDRB     R0,[R0, #+0]
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD113             BNE.N    ??OS_TickListUpdate_20
   \   000001C2   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000001C6   0x....             LDR.N    R0,??DataTable5_15
   \   000001C8   0x8800             LDRH     R0,[R0, #+0]
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD007             BEQ.N    ??OS_TickListUpdate_21
   \   000001CE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001D2   0x4658             MOV      R0,R11
   \   000001D4   0x.... 0x....      BL       CPU_SR_Restore
   \   000001D8   0x.... 0x....      BL       OS_Sched0
   \   000001DC   0xE00A             B.N      ??OS_TickListUpdate_22
   \                     ??OS_TickListUpdate_21: (+1)
   \   000001DE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001E2   0x4658             MOV      R0,R11
   \   000001E4   0x.... 0x....      BL       CPU_SR_Restore
   \   000001E8   0xE004             B.N      ??OS_TickListUpdate_22
   \                     ??OS_TickListUpdate_20: (+1)
   \   000001EA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001EE   0x4658             MOV      R0,R11
   \   000001F0   0x.... 0x....      BL       CPU_SR_Restore
    517          }
   \                     ??OS_TickListUpdate_22: (+1)
   \   000001F4   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSTickTaskTimeMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSCfg_TickTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSCfg_TickTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSCfg_TickTaskPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     OSCfg_TickTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     OS_TickTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     OSTickTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     OSCfg_TickWheelSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     OSCfg_TickWheel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0xFFFF0001         DC32     0xffff0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x75 0x43          DC8 "uC/OS-III Tick Task"
   \              0x2F 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \              0x49 0x20    
   \              0x54 0x69    
   \              0x63 0x6B    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   OS_TickListInit
      32   OS_TickListInsert
       4   OS_TickListRemove
       0   OS_TickListResetPeak
      40   OS_TickListUpdate
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OS_PendListRemove
        40   -> OS_Sched0
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
        40   -> OS_TaskRdy
        40   -> OS_TickListRemove
      16   OS_TickTask
        16   -> OSTaskSemPend
        16   -> OS_TickListUpdate
      48   OS_TickTaskInit
        48   -> OSTaskCreate
        48   -> OS_TickListInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      20  ?_0
      46  OS_TickListInit
     488  OS_TickListInsert
      78  OS_TickListRemove
      34  OS_TickListResetPeak
     504  OS_TickListUpdate
      40  OS_TickTask
     158  OS_TickTaskInit

 
    20 bytes in section .rodata
 1 412 bytes in section .text
 
 1 412 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none
