###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_q.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_q.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_q.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_q.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_q.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                               MESSAGE QUEUE MANAGEMENT
     10          *
     11          * File    : OS_Q.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_q__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_Q_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                               CREATE A MESSAGE QUEUE
     45          *
     46          * Description: This function is called by your application to create a message queue.  Message queues MUST be created
     47          *              before they can be used.
     48          *
     49          * Arguments  : p_q         is a pointer to the message queue
     50          *
     51          *              p_name      is a pointer to an ASCII string that will be used to name the message queue
     52          *
     53          *              max_qty     indicates the maximum size of the message queue (must be non-zero).  Note that it's also not
     54          *                          possible to have a size higher than the maximum number of OS_MSGs available.
     55          *
     56          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
     57          *
     58          *                              OS_ERR_NONE                    the call was successful
     59          *                              OS_ERR_CREATE_ISR              can't create from an ISR
     60          *                              OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the Queue after you called
     61          *                                                               OSSafetyCriticalStart().
     62          *                              OS_ERR_NAME                    if 'p_name' is a NULL pointer
     63          *                              OS_ERR_OBJ_CREATED             if the message queue has already been created
     64          *                              OS_ERR_OBJ_PTR_NULL            if you passed a NULL pointer for 'p_q'
     65          *                              OS_ERR_Q_SIZE                  if the size you specified is 0
     66          *
     67          * Returns    : none
     68          ************************************************************************************************************************
     69          */
     70          

   \                                 In section .text, align 2, keep-with-next
     71          void  OSQCreate (OS_Q        *p_q,
     72                           CPU_CHAR    *p_name,
     73                           OS_MSG_QTY   max_qty,
     74                           OS_ERR      *p_err)
     75          
     76          {
   \                     OSQCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     77              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
     78          
     79          
     80          
     81          #ifdef OS_SAFETY_CRITICAL
     82              if (p_err == (OS_ERR *)0) {
     83                  OS_SAFETY_CRITICAL_EXCEPTION();
     84                  return;
     85              }
     86          #endif
     87          
     88          #ifdef OS_SAFETY_CRITICAL_IEC61508
     89              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     90                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     91                  return;
     92              }
     93          #endif
     94          
     95          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     96              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??OSQCreate_0
     97                 *p_err = OS_ERR_CREATE_ISR;
   \   0000001A   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
     98                  return;
   \   00000020   0xE056             B.N      ??OSQCreate_1
     99              }
    100          #endif
    101          
    102          #if OS_CFG_ARG_CHK_EN > 0u
    103              if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
   \                     ??OSQCreate_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??OSQCreate_2
    104                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8038             STRH     R0,[R7, #+0]
    105                  return;
   \   0000002C   0xE050             B.N      ??OSQCreate_1
    106              }
    107              if (max_qty == (OS_MSG_QTY)0) {                         /* Cannot specify a zero size queue                       */
   \                     ??OSQCreate_2: (+1)
   \   0000002E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD103             BNE.N    ??OSQCreate_3
    108                 *p_err = OS_ERR_Q_SIZE;
   \   00000034   0xF246 0x5094      MOVW     R0,#+26004
   \   00000038   0x8038             STRH     R0,[R7, #+0]
    109                  return;
   \   0000003A   0xE049             B.N      ??OSQCreate_1
    110              }
    111          #endif
    112          
    113              OS_CRITICAL_ENTER();
   \                     ??OSQCreate_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x4680             MOV      R8,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000052   0x7008             STRB     R0,[R1, #+0]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD101             BNE.N    ??OSQCreate_4
   \   0000005E   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSQCreate_4: (+1)
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    114              p_q->Type    = OS_OBJ_TYPE_Q;                           /* Mark the data structure as a message queue             */
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable10_4  ;; 0x55455551
   \   00000070   0x6020             STR      R0,[R4, #+0]
    115              p_q->NamePtr = p_name;
   \   00000072   0x6065             STR      R5,[R4, #+4]
    116              OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the queue                                   */
    117                          max_qty);
   \   00000074   0x0031             MOVS     R1,R6
   \   00000076   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000078   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000007C   0x.... 0x....      BL       OS_MsgQInit
    118              OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
   \   00000080   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000084   0x.... 0x....      BL       OS_PendListInit
    119          
    120          #if OS_CFG_DBG_EN > 0u
    121              OS_QDbgListAdd(p_q);
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       OS_QDbgListAdd
    122          #endif
    123              OSQQty++;                                               /* One more queue created                                 */
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000092   0x8800             LDRH     R0,[R0, #+0]
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   0000009A   0x8008             STRH     R0,[R1, #+0]
    124          
    125              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000009C   0x.... 0x....      BL       CPU_SR_Save
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x1E40             SUBS     R0,R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD101             BNE.N    ??OSQCreate_5
   \   000000BE   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSQCreate_5: (+1)
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    126             *p_err = OS_ERR_NONE;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x8038             STRH     R0,[R7, #+0]
    127          }
   \                     ??OSQCreate_1: (+1)
   \   000000D0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    128          
    129          /*$PAGE*/
    130          /*
    131          ************************************************************************************************************************
    132          *                                               DELETE A MESSAGE QUEUE
    133          *
    134          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    135          *
    136          * Arguments  : p_q       is a pointer to the message queue you want to delete
    137          *
    138          *              opt       determines delete options as follows:
    139          *
    140          *                            OS_OPT_DEL_NO_PEND          Delete the queue ONLY if no task pending
    141          *                            OS_OPT_DEL_ALWAYS           Deletes the queue even if tasks are waiting.
    142          *                                                        In this case, all the tasks pending will be readied.
    143          *
    144          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    145          *
    146          *                            OS_ERR_NONE                 The call was successful and the queue was deleted
    147          *                            OS_ERR_DEL_ISR              If you tried to delete the queue from an ISR
    148          *                            OS_ERR_OBJ_PTR_NULL         if you pass a NULL pointer for 'p_q'
    149          *                            OS_ERR_OBJ_TYPE             if the message queue was not created
    150          *                            OS_ERR_OPT_INVALID          An invalid option was specified
    151          *                            OS_ERR_TASK_WAITING         One or more tasks were waiting on the queue
    152          *
    153          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    154          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    155          *
    156          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the queue MUST
    157          *                 check the return code of OSQPend().
    158          *
    159          *              2) OSQAccept() callers will not know that the intended queue has been deleted.
    160          *
    161          *              3) Because ALL tasks pending on the queue will be readied, you MUST be careful in applications where the
    162          *                 queue is used for mutual exclusion because the resource(s) will no longer be guarded by the queue.
    163          ************************************************************************************************************************
    164          */
    165          
    166          #if OS_CFG_Q_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    167          OS_OBJ_QTY  OSQDel (OS_Q    *p_q,
    168                              OS_OPT   opt,
    169                              OS_ERR  *p_err)
    170          {
   \                     OSQDel: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    171              OS_OBJ_QTY     cnt;
    172              OS_OBJ_QTY     nbr_tasks;
    173              OS_PEND_DATA  *p_pend_data;
    174              OS_PEND_LIST  *p_pend_list;
    175              OS_TCB        *p_tcb;
    176              CPU_TS         ts;
    177              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    178          
    179          
    180          
    181          #ifdef OS_SAFETY_CRITICAL
    182              if (p_err == (OS_ERR *)0) {
    183                  OS_SAFETY_CRITICAL_EXCEPTION();
    184                  return ((OS_OBJ_QTY)0);
    185              }
    186          #endif
    187          
    188          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    189              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't delete a message queue from an ISR               */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSQDel_0
    190                 *p_err = OS_ERR_DEL_ISR;
   \   0000001A   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    191                  return ((OS_OBJ_QTY)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE0AA             B.N      ??OSQDel_1
    192              }
    193          #endif
    194          
    195          #if OS_CFG_ARG_CHK_EN > 0u
    196              if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
   \                     ??OSQDel_0: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD104             BNE.N    ??OSQDel_2
    197                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
    198                  return ((OS_OBJ_QTY)0u);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE0A3             B.N      ??OSQDel_1
    199              }
    200              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSQDel_2: (+1)
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD805             BHI.N    ??OSQDel_3
    201                  case OS_OPT_DEL_NO_PEND:
    202                  case OS_OPT_DEL_ALWAYS:
    203                       break;
    204          
    205                  default:
    206                      *p_err =  OS_ERR_OPT_INVALID;
    207                       return ((OS_OBJ_QTY)0u);
    208              }
    209          #endif
    210          
    211          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    212              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQDel_4: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x55455551
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD105             BNE.N    ??OSQDel_5
   \   00000046   0xE009             B.N      ??OSQDel_6
   \                     ??OSQDel_3: (+1)
   \   00000048   0xF645 0x6025      MOVW     R0,#+24101
   \   0000004C   0x8030             STRH     R0,[R6, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE093             B.N      ??OSQDel_1
    213                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSQDel_5: (+1)
   \   00000052   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    214                  return ((OS_OBJ_QTY)0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE08E             B.N      ??OSQDel_1
    215              }
    216          #endif
    217          
    218              CPU_CRITICAL_ENTER();
   \                     ??OSQDel_6: (+1)
   \   0000005C   0x.... 0x....      BL       CPU_SR_Save
   \   00000060   0x4683             MOV      R11,R0
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStart
    219              p_pend_list = &p_q->PendList;
   \   00000066   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000006A   0x4681             MOV      R9,R0
    220              cnt         = p_pend_list->NbrEntries;
   \   0000006C   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   00000070   0x0007             MOVS     R7,R0
    221              nbr_tasks   = cnt;
   \   00000072   0x46B8             MOV      R8,R7
    222              switch (opt) {
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD002             BEQ.N    ??OSQDel_7
   \   0000007A   0x2D01             CMP      R5,#+1
   \   0000007C   0xD023             BEQ.N    ??OSQDel_8
   \   0000007E   0xE072             B.N      ??OSQDel_9
    223                  case OS_OPT_DEL_NO_PEND:                            /* Delete message queue only if no task waiting           */
    224                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSQDel_7: (+1)
   \   00000080   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000084   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000088   0xD114             BNE.N    ??OSQDel_10
    225          #if OS_CFG_DBG_EN > 0u
    226                           OS_QDbgListRemove(p_q);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       OS_QDbgListRemove
    227          #endif
    228                           OSQQty--;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   00000094   0x8800             LDRH     R0,[R0, #+0]
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   0000009C   0x8008             STRH     R0,[R1, #+0]
    229                           OS_QClr(p_q);
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       OS_QClr
    230                           CPU_CRITICAL_EXIT();
   \   000000A4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A8   0x4658             MOV      R0,R11
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    231                          *p_err = OS_ERR_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x8030             STRH     R0,[R6, #+0]
   \   000000B2   0xE007             B.N      ??OSQDel_11
    232                       } else {
    233                           CPU_CRITICAL_EXIT();
   \                     ??OSQDel_10: (+1)
   \   000000B4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B8   0x4658             MOV      R0,R11
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    234                          *p_err = OS_ERR_TASK_WAITING;
   \   000000BE   0xF247 0x105F      MOVW     R0,#+29023
   \   000000C2   0x8030             STRH     R0,[R6, #+0]
    235                       }
    236                       break;
   \                     ??OSQDel_11: (+1)
   \   000000C4   0xE057             B.N      ??OSQDel_12
    237          
    238                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the message queue                        */
    239                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSQDel_8: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD101             BNE.N    ??OSQDel_13
   \   000000DE   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSQDel_13: (+1)
   \   000000E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E6   0x4658             MOV      R0,R11
   \   000000E8   0x.... 0x....      BL       CPU_SR_Restore
    240                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
   \   000000EC   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000F0   0x9000             STR      R0,[SP, #+0]
    241                       while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
   \                     ??OSQDel_14: (+1)
   \   000000F2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000F4   0x2F00             CMP      R7,#+0
   \   000000F6   0xD00C             BEQ.N    ??OSQDel_15
    242                           p_pend_data = p_pend_list->HeadPtr;
   \   000000F8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000FC   0x9001             STR      R0,[SP, #+4]
    243                           p_tcb       = p_pend_data->TCBPtr;
   \   000000FE   0x9801             LDR      R0,[SP, #+4]
   \   00000100   0x6880             LDR      R0,[R0, #+8]
   \   00000102   0x4682             MOV      R10,R0
    244                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_q),
    245                                         p_tcb,
    246                                         ts);
   \   00000104   0x9A00             LDR      R2,[SP, #+0]
   \   00000106   0x4651             MOV      R1,R10
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       OS_PendObjDel
    247                           cnt--;
   \   0000010E   0x1E7F             SUBS     R7,R7,#+1
   \   00000110   0xE7EF             B.N      ??OSQDel_14
    248                       }
    249          #if OS_CFG_DBG_EN > 0u
    250                       OS_QDbgListRemove(p_q);
   \                     ??OSQDel_15: (+1)
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       OS_QDbgListRemove
    251          #endif
    252                       OSQQty--;
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000011C   0x8800             LDRH     R0,[R0, #+0]
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000124   0x8008             STRH     R0,[R1, #+0]
    253                       OS_QClr(p_q);
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       OS_QClr
    254                       OS_CRITICAL_EXIT_NO_SCHED();
   \   0000012C   0x.... 0x....      BL       CPU_SR_Save
   \   00000130   0x4683             MOV      R11,R0
   \   00000132   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0x1E40             SUBS     R0,R0,#+1
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000142   0x7008             STRB     R0,[R1, #+0]
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD101             BNE.N    ??OSQDel_16
   \   0000014E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSQDel_16: (+1)
   \   00000152   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000156   0x4658             MOV      R0,R11
   \   00000158   0x.... 0x....      BL       CPU_SR_Restore
    255                       OSSched();                                     /* Find highest priority task ready to run                */
   \   0000015C   0x.... 0x....      BL       OSSched
    256                      *p_err = OS_ERR_NONE;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x8030             STRH     R0,[R6, #+0]
    257                       break;
   \   00000164   0xE007             B.N      ??OSQDel_12
    258          
    259                  default:
    260                       CPU_CRITICAL_EXIT();
   \                     ??OSQDel_9: (+1)
   \   00000166   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016A   0x4658             MOV      R0,R11
   \   0000016C   0x.... 0x....      BL       CPU_SR_Restore
    261                      *p_err = OS_ERR_OPT_INVALID;
   \   00000170   0xF645 0x6025      MOVW     R0,#+24101
   \   00000174   0x8030             STRH     R0,[R6, #+0]
    262                       break;
    263              }
    264              return (nbr_tasks);
   \                     ??OSQDel_12: (+1)
   \   00000176   0x4640             MOV      R0,R8
   \   00000178   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQDel_1: (+1)
   \   0000017A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    265          }
    266          #endif
    267          
    268          /*$PAGE*/
    269          /*
    270          ************************************************************************************************************************
    271          *                                                     FLUSH QUEUE
    272          *
    273          * Description : This function is used to flush the contents of the message queue.
    274          *
    275          * Arguments   : p_q        is a pointer to the message queue to flush
    276          *
    277          *               p_err      is a pointer to a variable that will contain an error code returned by this function.
    278          *
    279          *                              OS_ERR_NONE           upon success
    280          *                              OS_ERR_FLUSH_ISR      if you called this function from an ISR
    281          *                              OS_ERR_OBJ_PTR_NULL   If you passed a NULL pointer for 'p_q'
    282          *                              OS_ERR_OBJ_TYPE       If you didn't create the message queue
    283          *
    284          * Returns     : The number of entries freed from the queue
    285          *
    286          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    287          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    288          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    289          *                  likely, need to be de-allocated (i.e. freed).
    290          ************************************************************************************************************************
    291          */
    292          
    293          #if OS_CFG_Q_FLUSH_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    294          OS_MSG_QTY  OSQFlush (OS_Q    *p_q,
    295                                OS_ERR  *p_err)
    296          {
   \                     OSQFlush: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    297              OS_MSG_QTY  entries;
    298              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    299          
    300          
    301          
    302          #ifdef OS_SAFETY_CRITICAL
    303              if (p_err == (OS_ERR *)0) {
    304                  OS_SAFETY_CRITICAL_EXCEPTION();
    305                  return ((OS_MSG_QTY)0);
    306              }
    307          #endif
    308          
    309          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    310              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSQFlush_0
    311                 *p_err = OS_ERR_FLUSH_ISR;
   \   00000012   0xF44F 0x506C      MOV      R0,#+15104
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    312                  return ((OS_MSG_QTY)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE05C             B.N      ??OSQFlush_1
    313              }
    314          #endif
    315          
    316          #if OS_CFG_ARG_CHK_EN > 0u
    317              if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
   \                     ??OSQFlush_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSQFlush_2
    318                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    319                  return ((OS_MSG_QTY)0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE055             B.N      ??OSQFlush_1
    320              }
    321          #endif
    322          
    323          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    324              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQFlush_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x55455551
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??OSQFlush_3
    325                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000034   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    326                  return ((OS_MSG_QTY)0);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE04B             B.N      ??OSQFlush_1
    327              }
    328          #endif
    329          
    330              OS_CRITICAL_ENTER();
   \                     ??OSQFlush_3: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0007             MOVS     R7,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000054   0x7008             STRB     R0,[R1, #+0]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD101             BNE.N    ??OSQFlush_4
   \   00000060   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSQFlush_4: (+1)
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    331              entries = OS_MsgQFreeAll(&p_q->MsgQ);                   /* Return all OS_MSGs to the OS_MSG pool                  */
   \   0000006E   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000072   0x.... 0x....      BL       OS_MsgQFreeAll
   \   00000076   0x0006             MOVS     R6,R0
    332              OS_CRITICAL_EXIT();
   \   00000078   0x.... 0x....      BL       CPU_SR_Save
   \   0000007C   0x0007             MOVS     R7,R0
   \   0000007E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD114             BNE.N    ??OSQFlush_5
   \   0000009A   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000A2   0x8800             LDRH     R0,[R0, #+0]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD007             BEQ.N    ??OSQFlush_6
   \   000000A8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AC   0x0038             MOVS     R0,R7
   \   000000AE   0x.... 0x....      BL       CPU_SR_Restore
   \   000000B2   0x.... 0x....      BL       OS_Sched0
   \   000000B6   0xE00A             B.N      ??OSQFlush_7
   \                     ??OSQFlush_6: (+1)
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BC   0x0038             MOVS     R0,R7
   \   000000BE   0x.... 0x....      BL       CPU_SR_Restore
   \   000000C2   0xE004             B.N      ??OSQFlush_7
   \                     ??OSQFlush_5: (+1)
   \   000000C4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C8   0x0038             MOVS     R0,R7
   \   000000CA   0x.... 0x....      BL       CPU_SR_Restore
    333             *p_err   = OS_ERR_NONE;
   \                     ??OSQFlush_7: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x8028             STRH     R0,[R5, #+0]
    334              return ((OS_MSG_QTY)entries);
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQFlush_1: (+1)
   \   000000D6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    335          }
    336          #endif
    337          
    338          /*$PAGE*/
    339          /*
    340          ************************************************************************************************************************
    341          *                                            PEND ON A QUEUE FOR A MESSAGE
    342          *
    343          * Description: This function waits for a message to be sent to a queue
    344          *
    345          * Arguments  : p_q           is a pointer to the message queue
    346          *
    347          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    348          *                            message to arrive at the queue up to the amount of time specified by this argument.  If you
    349          *                            specify 0, however, your task will wait forever at the specified queue or, until a message
    350          *                            arrives.
    351          *
    352          *              opt           determines whether the user wants to block if the queue is empty or not:
    353          *
    354          *                                OS_OPT_PEND_BLOCKING
    355          *                                OS_OPT_PEND_NON_BLOCKING
    356          *
    357          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    358          *
    359          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    360          *                            received, pend aborted or the message queue deleted,  If you pass a NULL pointer (i.e.
    361          *                            (CPU_TS *)0) then you will not get the timestamp.  In other words, passing a NULL pointer
    362          *                            is valid and indicates that you don't need the timestamp.
    363          *
    364          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    365          *
    366          *                                OS_ERR_NONE               The call was successful and your task received a message.
    367          *                                OS_ERR_OBJ_PTR_NULL       if you pass a NULL pointer for 'p_q'
    368          *                                OS_ERR_OBJ_TYPE           if the message queue was not created
    369          *                                OS_ERR_PEND_ABORT         the pend was aborted
    370          *                                OS_ERR_PEND_ISR           if you called this function from an ISR
    371          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    372          *                                OS_ERR_SCHED_LOCKED       the scheduler is locked
    373          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    374          *                                                          would lead to a suspension.
    375          *
    376          * Returns    : != (void *)0  is a pointer to the message received
    377          *              == (void *)0  if you received a NULL pointer message or,
    378          *                            if no message was received or,
    379          *                            if 'p_q' is a NULL pointer or,
    380          *                            if you didn't pass a pointer to a queue.
    381          ************************************************************************************************************************
    382          */
    383          

   \                                 In section .text, align 2, keep-with-next
    384          void  *OSQPend (OS_Q         *p_q,
    385                          OS_TICK       timeout,
    386                          OS_OPT        opt,
    387                          OS_MSG_SIZE  *p_msg_size,
    388                          CPU_TS       *p_ts,
    389                          OS_ERR       *p_err)
    390          {
   \                     OSQPend: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \   00000012   0xF8DD 0x904C      LDR      R9,[SP, #+76]
    391              OS_PEND_DATA  pend_data;
    392              void         *p_void;
    393              CPU_SR_ALLOC();
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
    394          
    395          
    396          
    397          #ifdef OS_SAFETY_CRITICAL
    398              if (p_err == (OS_ERR *)0) {
    399                  OS_SAFETY_CRITICAL_EXCEPTION();
    400                  return ((void *)0);
    401              }
    402          #endif
    403          
    404          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    405              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD005             BEQ.N    ??OSQPend_0
    406                 *p_err = OS_ERR_PEND_ISR;
   \   00000024   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000028   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    407                  return ((void *)0);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE101             B.N      ??OSQPend_1
    408              }
    409          #endif
    410          
    411          #if OS_CFG_ARG_CHK_EN > 0u
    412              if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
   \                     ??OSQPend_0: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD105             BNE.N    ??OSQPend_2
    413                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    414                  return ((void *)0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE0F9             B.N      ??OSQPend_1
    415              }
    416              if (p_msg_size == (OS_MSG_SIZE *)0) {
   \                     ??OSQPend_2: (+1)
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD105             BNE.N    ??OSQPend_3
    417                 *p_err = OS_ERR_PTR_INVALID;
   \   00000044   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000048   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    418                  return ((void *)0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE0F1             B.N      ??OSQPend_1
    419              }
    420              switch (opt) {
   \                     ??OSQPend_3: (+1)
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??OSQPend_4
   \   00000058   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005C   0xD105             BNE.N    ??OSQPend_5
    421                  case OS_OPT_PEND_BLOCKING:
    422                  case OS_OPT_PEND_NON_BLOCKING:
    423                       break;
    424          
    425                  default:
    426                      *p_err = OS_ERR_OPT_INVALID;
    427                       return ((void *)0);
    428              }
    429          #endif
    430          
    431          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    432              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQPend_4: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x55455551
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD106             BNE.N    ??OSQPend_6
   \   00000068   0xE00B             B.N      ??OSQPend_7
   \                     ??OSQPend_5: (+1)
   \   0000006A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE0DE             B.N      ??OSQPend_1
    433                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSQPend_6: (+1)
   \   00000076   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000007A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    434                  return ((void *)0);
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE0D8             B.N      ??OSQPend_1
    435              }
    436          #endif
    437          
    438              if (p_ts != (CPU_TS *)0) {
   \                     ??OSQPend_7: (+1)
   \   00000082   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000086   0xD002             BEQ.N    ??OSQPend_8
    439                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    440              }
    441          
    442              CPU_CRITICAL_ENTER();
   \                     ??OSQPend_8: (+1)
   \   0000008E   0x.... 0x....      BL       CPU_SR_Save
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStart
    443              p_void = OS_MsgQGet(&p_q->MsgQ,                         /* Any message waiting in the message queue?              */
    444                                  p_msg_size,
    445                                  p_ts,
    446                                  p_err);
   \   00000098   0x464B             MOV      R3,R9
   \   0000009A   0x4642             MOV      R2,R8
   \   0000009C   0x0039             MOVS     R1,R7
   \   0000009E   0xF114 0x0020      ADDS     R0,R4,#+32
   \   000000A2   0x.... 0x....      BL       OS_MsgQGet
   \   000000A6   0x4682             MOV      R10,R0
    447              if (*p_err == OS_ERR_NONE) {
   \   000000A8   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD106             BNE.N    ??OSQPend_9
    448                  CPU_CRITICAL_EXIT();
   \   000000B0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B4   0x4658             MOV      R0,R11
   \   000000B6   0x.... 0x....      BL       CPU_SR_Restore
    449                  return (p_void);                                    /* Yes, Return message received                           */
   \   000000BA   0x4650             MOV      R0,R10
   \   000000BC   0xE0BA             B.N      ??OSQPend_1
    450              }
    451          
    452              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSQPend_9: (+1)
   \   000000BE   0x0430             LSLS     R0,R6,#+16
   \   000000C0   0xD50A             BPL.N    ??OSQPend_10
    453                  CPU_CRITICAL_EXIT();
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x4658             MOV      R0,R11
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    454                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \   000000CC   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000D0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    455                  return ((void *)0);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xE0AD             B.N      ??OSQPend_1
    456              } else {
    457                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSQPend_10: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD00A             BEQ.N    ??OSQPend_11
    458                      CPU_CRITICAL_EXIT();
   \   000000E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E6   0x4658             MOV      R0,R11
   \   000000E8   0x.... 0x....      BL       CPU_SR_Restore
    459                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000EC   0xF646 0x5063      MOVW     R0,#+28003
   \   000000F0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    460                      return ((void *)0);
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xE09D             B.N      ??OSQPend_1
    461                  }
    462              }
    463                                                                      /* Lock the scheduler/re-enable interrupts                */
    464              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSQPend_11: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000104   0x7008             STRB     R0,[R1, #+0]
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x2801             CMP      R0,#+1
   \   0000010E   0xD101             BNE.N    ??OSQPend_12
   \   00000110   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSQPend_12: (+1)
   \   00000114   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000118   0x4658             MOV      R0,R11
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
    465              OS_Pend(&pend_data,                                     /* Block task pending on Message Queue                    */
    466                      (OS_PEND_OBJ *)((void *)p_q),
    467                      OS_TASK_PEND_ON_Q,
    468                      timeout);
   \   0000011E   0x002B             MOVS     R3,R5
   \   00000120   0x2205             MOVS     R2,#+5
   \   00000122   0x0021             MOVS     R1,R4
   \   00000124   0x4668             MOV      R0,SP
   \   00000126   0x.... 0x....      BL       OS_Pend
    469              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000012A   0x.... 0x....      BL       CPU_SR_Save
   \   0000012E   0x4683             MOV      R11,R0
   \   00000130   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x1E40             SUBS     R0,R0,#+1
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000140   0x7008             STRB     R0,[R1, #+0]
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD101             BNE.N    ??OSQPend_13
   \   0000014C   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSQPend_13: (+1)
   \   00000150   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000154   0x4658             MOV      R0,R11
   \   00000156   0x.... 0x....      BL       CPU_SR_Restore
    470          
    471              OSSched();                                              /* Find the next highest priority task ready to run       */
   \   0000015A   0x.... 0x....      BL       OSSched
    472          
    473              CPU_CRITICAL_ENTER();
   \   0000015E   0x.... 0x....      BL       CPU_SR_Save
   \   00000162   0x4683             MOV      R11,R0
   \   00000164   0x.... 0x....      BL       CPU_IntDisMeasStart
    474              switch (OSTCBCurPtr->PendStatus) {
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD005             BEQ.N    ??OSQPend_14
   \   00000176   0x2802             CMP      R0,#+2
   \   00000178   0xD03C             BEQ.N    ??OSQPend_15
   \   0000017A   0xD31A             BCC.N    ??OSQPend_16
   \   0000017C   0x2803             CMP      R0,#+3
   \   0000017E   0xD02A             BEQ.N    ??OSQPend_17
   \   00000180   0xE04A             B.N      ??OSQPend_18
    475                  case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
    476                       p_void     = OSTCBCurPtr->MsgPtr;
   \                     ??OSQPend_14: (+1)
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x6DC0             LDR      R0,[R0, #+92]
   \   0000018A   0x4682             MOV      R10,R0
    477                      *p_msg_size = OSTCBCurPtr->MsgSize;
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   00000190   0x6800             LDR      R0,[R0, #+0]
   \   00000192   0xF8B0 0x0060      LDRH     R0,[R0, #+96]
   \   00000196   0x8038             STRH     R0,[R7, #+0]
    478                       if (p_ts  != (CPU_TS *)0) {
   \   00000198   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000019C   0xD005             BEQ.N    ??OSQPend_19
    479                          *p_ts   =  OSTCBCurPtr->TS;
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   000001A2   0x6800             LDR      R0,[R0, #+0]
   \   000001A4   0x6C00             LDR      R0,[R0, #+64]
   \   000001A6   0xF8C8 0x0000      STR      R0,[R8, #+0]
    480                       }
    481                      *p_err      = OS_ERR_NONE;
   \                     ??OSQPend_19: (+1)
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    482                       break;
   \   000001B0   0xE03A             B.N      ??OSQPend_20
    483          
    484                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    485                       p_void     = (void      *)0;
   \                     ??OSQPend_16: (+1)
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x4682             MOV      R10,R0
    486                      *p_msg_size = (OS_MSG_SIZE)0;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x8038             STRH     R0,[R7, #+0]
    487                       if (p_ts  != (CPU_TS *)0) {
   \   000001BA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001BE   0xD005             BEQ.N    ??OSQPend_21
    488                          *p_ts   =  OSTCBCurPtr->TS;
   \   000001C0   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   000001C4   0x6800             LDR      R0,[R0, #+0]
   \   000001C6   0x6C00             LDR      R0,[R0, #+64]
   \   000001C8   0xF8C8 0x0000      STR      R0,[R8, #+0]
    489                       }
    490                      *p_err      = OS_ERR_PEND_ABORT;
   \                     ??OSQPend_21: (+1)
   \   000001CC   0xF246 0x10A9      MOVW     R0,#+25001
   \   000001D0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    491                       break;
   \   000001D4   0xE028             B.N      ??OSQPend_20
    492          
    493                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
    494                       p_void     = (void      *)0;
   \                     ??OSQPend_17: (+1)
   \   000001D6   0x2000             MOVS     R0,#+0
   \   000001D8   0x4682             MOV      R10,R0
    495                      *p_msg_size = (OS_MSG_SIZE)0;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x8038             STRH     R0,[R7, #+0]
    496                       if (p_ts  != (CPU_TS *)0) {
   \   000001DE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001E2   0xD002             BEQ.N    ??OSQPend_22
    497                          *p_ts   = (CPU_TS  )0;
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xF8C8 0x0000      STR      R0,[R8, #+0]
    498                       }
    499                      *p_err      = OS_ERR_TIMEOUT;
   \                     ??OSQPend_22: (+1)
   \   000001EA   0xF247 0x20D9      MOVW     R0,#+29401
   \   000001EE   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    500                       break;
   \   000001F2   0xE019             B.N      ??OSQPend_20
    501          
    502                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    503                       p_void     = (void      *)0;
   \                     ??OSQPend_15: (+1)
   \   000001F4   0x2000             MOVS     R0,#+0
   \   000001F6   0x4682             MOV      R10,R0
    504                      *p_msg_size = (OS_MSG_SIZE)0;
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x8038             STRH     R0,[R7, #+0]
    505                       if (p_ts  != (CPU_TS *)0) {
   \   000001FC   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000200   0xD005             BEQ.N    ??OSQPend_23
    506                          *p_ts   =  OSTCBCurPtr->TS;
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable10_7
   \   00000206   0x6800             LDR      R0,[R0, #+0]
   \   00000208   0x6C00             LDR      R0,[R0, #+64]
   \   0000020A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    507                       }
    508                      *p_err      = OS_ERR_OBJ_DEL;
   \                     ??OSQPend_23: (+1)
   \   0000020E   0xF645 0x50C2      MOVW     R0,#+24002
   \   00000212   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    509                       break;
   \   00000216   0xE007             B.N      ??OSQPend_20
    510          
    511                  default:
    512                       p_void     = (void      *)0;
   \                     ??OSQPend_18: (+1)
   \   00000218   0x2000             MOVS     R0,#+0
   \   0000021A   0x4682             MOV      R10,R0
    513                      *p_msg_size = (OS_MSG_SIZE)0;
   \   0000021C   0x2000             MOVS     R0,#+0
   \   0000021E   0x8038             STRH     R0,[R7, #+0]
    514                      *p_err      = OS_ERR_STATUS_INVALID;
   \   00000220   0xF646 0x602E      MOVW     R0,#+28206
   \   00000224   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    515                       break;
    516              }
    517              CPU_CRITICAL_EXIT();
   \                     ??OSQPend_20: (+1)
   \   00000228   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000022C   0x4658             MOV      R0,R11
   \   0000022E   0x.... 0x....      BL       CPU_SR_Restore
    518              return (p_void);
   \   00000232   0x4650             MOV      R0,R10
   \                     ??OSQPend_1: (+1)
   \   00000234   0xB009             ADD      SP,SP,#+36
   \   00000236   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    519          }
    520          
    521          
    522          /*$PAGE*/
    523          /*
    524          ************************************************************************************************************************
    525          *                                             ABORT WAITING ON A MESSAGE QUEUE
    526          *
    527          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function should be used to
    528          *              fault-abort the wait on the queue, rather than to normally signal the queue via OSQPost().
    529          *
    530          * Arguments  : p_q       is a pointer to the message queue
    531          *
    532          *              opt       determines the type of ABORT performed:
    533          *
    534          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the queue
    535          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the queue
    536          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    537          *
    538          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    539          *
    540          *                            OS_ERR_NONE                  At least one task waiting on the queue was readied and
    541          *                                                         informed of the aborted wait; check return value for the
    542          *                                                         number of tasks whose wait on the queue was aborted.
    543          *                            OS_ERR_OPT_INVALID           if you specified an invalid option
    544          *                            OS_ERR_OBJ_PTR_NULL          if you pass a NULL pointer for 'p_q'
    545          *                            OS_ERR_OBJ_TYPE              if the message queue was not created
    546          *                            OS_ERR_PEND_ABORT_ISR        If this function was called from an ISR
    547          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    548          *
    549          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    550          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    551          ************************************************************************************************************************
    552          */
    553          
    554          #if OS_CFG_Q_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    555          OS_OBJ_QTY  OSQPendAbort (OS_Q    *p_q,
    556                                    OS_OPT   opt,
    557                                    OS_ERR  *p_err)
    558          {
   \                     OSQPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    559              OS_PEND_LIST  *p_pend_list;
    560              OS_TCB        *p_tcb;
    561              CPU_TS         ts;
    562              OS_OBJ_QTY     nbr_tasks;
    563              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    564          
    565          
    566          
    567          #ifdef OS_SAFETY_CRITICAL
    568              if (p_err == (OS_ERR *)0) {
    569                  OS_SAFETY_CRITICAL_EXCEPTION();
    570                  return ((OS_OBJ_QTY)0u);
    571              }
    572          #endif
    573          
    574          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    575              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSQPendAbort_0
    576                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000018   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    577                  return ((OS_OBJ_QTY)0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE07B             B.N      ??OSQPendAbort_1
    578              }
    579          #endif
    580          
    581          #if OS_CFG_ARG_CHK_EN > 0u
    582              if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
   \                     ??OSQPendAbort_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSQPendAbort_2
    583                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    584                  return ((OS_OBJ_QTY)0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE074             B.N      ??OSQPendAbort_1
    585              }
    586              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSQPendAbort_2: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??OSQPendAbort_3
   \   00000038   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003C   0xD005             BEQ.N    ??OSQPendAbort_3
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD002             BEQ.N    ??OSQPendAbort_3
   \   00000044   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000048   0xD105             BNE.N    ??OSQPendAbort_4
    587                  case OS_OPT_PEND_ABORT_1:
    588                  case OS_OPT_PEND_ABORT_ALL:
    589                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    590                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    591                       break;
    592          
    593                  default:
    594                      *p_err =  OS_ERR_OPT_INVALID;
    595                       return ((OS_OBJ_QTY)0u);
    596              }
    597          #endif
    598          
    599          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    600              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure queue was created                            */
   \                     ??OSQPendAbort_3: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x55455551
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD105             BNE.N    ??OSQPendAbort_5
   \   00000054   0xE009             B.N      ??OSQPendAbort_6
   \                     ??OSQPendAbort_4: (+1)
   \   00000056   0xF645 0x6025      MOVW     R0,#+24101
   \   0000005A   0x8030             STRH     R0,[R6, #+0]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE05C             B.N      ??OSQPendAbort_1
    601                 *p_err =  OS_ERR_OBJ_TYPE;
   \                     ??OSQPendAbort_5: (+1)
   \   00000060   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000064   0x8030             STRH     R0,[R6, #+0]
    602                  return ((OS_OBJ_QTY)0u);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE057             B.N      ??OSQPendAbort_1
    603              }
    604          #endif
    605          
    606              CPU_CRITICAL_ENTER();
   \                     ??OSQPendAbort_6: (+1)
   \   0000006A   0x.... 0x....      BL       CPU_SR_Save
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStart
    607              p_pend_list = &p_q->PendList;
   \   00000074   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000078   0x0007             MOVS     R7,R0
    608              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on queue?                             */
   \   0000007A   0x8938             LDRH     R0,[R7, #+8]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD109             BNE.N    ??OSQPendAbort_7
    609                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    610                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   0000008A   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000008E   0x8030             STRH     R0,[R6, #+0]
    611                  return ((OS_OBJ_QTY)0u);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE042             B.N      ??OSQPendAbort_1
    612              }
    613          
    614              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSQPendAbort_7: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable10_3
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x1C40             ADDS     R0,R0,#+1
   \   0000009A   0x....             LDR.N    R1,??DataTable10_3
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   \   0000009E   0x....             LDR.N    R0,??DataTable10_3
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD101             BNE.N    ??OSQPendAbort_8
   \   000000A6   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSQPendAbort_8: (+1)
   \   000000AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AE   0x4658             MOV      R0,R11
   \   000000B0   0x.... 0x....      BL       CPU_SR_Restore
    615              nbr_tasks = 0u;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x4682             MOV      R10,R0
    616              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
   \   000000B8   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000BC   0x4681             MOV      R9,R0
    617              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSQPendAbort_9: (+1)
   \   000000BE   0x8938             LDRH     R0,[R7, #+8]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD00D             BEQ.N    ??OSQPendAbort_10
    618                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
   \   000000C4   0x6838             LDR      R0,[R7, #+0]
   \   000000C6   0x6880             LDR      R0,[R0, #+8]
   \   000000C8   0x4680             MOV      R8,R0
    619                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_q),
    620                               p_tcb,
    621                               ts);
   \   000000CA   0x464A             MOV      R2,R9
   \   000000CC   0x4641             MOV      R1,R8
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       OS_PendAbort
    622                  nbr_tasks++;
   \   000000D4   0xF11A 0x0A01      ADDS     R10,R10,#+1
    623                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000D8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000DA   0xF5B5 0x7F80      CMP      R5,#+256
   \   000000DE   0xD0EE             BEQ.N    ??OSQPendAbort_9
    624                      break;                                          /* No                                                     */
    625                  }
    626              }
    627              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSQPendAbort_10: (+1)
   \   000000E0   0x.... 0x....      BL       CPU_SR_Save
   \   000000E4   0x4683             MOV      R11,R0
   \   000000E6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000EA   0x....             LDR.N    R0,??DataTable10_3
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x1E40             SUBS     R0,R0,#+1
   \   000000F0   0x....             LDR.N    R1,??DataTable10_3
   \   000000F2   0x7008             STRB     R0,[R1, #+0]
   \   000000F4   0x....             LDR.N    R0,??DataTable10_3
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD101             BNE.N    ??OSQPendAbort_11
   \   000000FC   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSQPendAbort_11: (+1)
   \   00000100   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000104   0x4658             MOV      R0,R11
   \   00000106   0x.... 0x....      BL       CPU_SR_Restore
    628          
    629              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   0000010A   0x0428             LSLS     R0,R5,#+16
   \   0000010C   0xD401             BMI.N    ??OSQPendAbort_12
    630                  OSSched();                                          /* Run the scheduler                                      */
   \   0000010E   0x.... 0x....      BL       OSSched
    631              }
    632          
    633             *p_err = OS_ERR_NONE;
   \                     ??OSQPendAbort_12: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x8030             STRH     R0,[R6, #+0]
    634              return (nbr_tasks);
   \   00000116   0x4650             MOV      R0,R10
   \   00000118   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQPendAbort_1: (+1)
   \   0000011A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    635          }
    636          #endif
    637          
    638          /*$PAGE*/
    639          /*
    640          ************************************************************************************************************************
    641          *                                               POST MESSAGE TO A QUEUE
    642          *
    643          * Description: This function sends a message to a queue.  With the 'opt' argument, you can specify whether the message
    644          *              is broadcast to all waiting tasks and/or whether you post the message to the front of the queue (LIFO)
    645          *              or normally (FIFO) at the end of the queue.
    646          *
    647          * Arguments  : p_q           is a pointer to a message queue that must have been created by OSQCreate().
    648          *
    649          *              p_void        is a pointer to the message to send.
    650          *
    651          *              msg_size      specifies the size of the message (in bytes)
    652          *
    653          *              opt           determines the type of POST performed:
    654          *
    655          *                                OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the queue.  This option
    656          *                                                         can be added to either OS_OPT_POST_FIFO or OS_OPT_POST_LIFO
    657          *                                OS_OPT_POST_FIFO         POST message to end of queue (FIFO) and wake up a single
    658          *                                                         waiting task.
    659          *                                OS_OPT_POST_LIFO         POST message to the front of the queue (LIFO) and wake up
    660          *                                                         a single waiting task.
    661          *                                OS_OPT_POST_NO_SCHED     Do not call the scheduler
    662          *
    663          *                            Note(s): 1) OS_OPT_POST_NO_SCHED can be added (or OR'd) with one of the other options.
    664          *                                     2) OS_OPT_POST_ALL      can be added (or OR'd) with one of the other options.
    665          *                                     3) Possible combination of options are:
    666          *
    667          *                                        OS_OPT_POST_FIFO
    668          *                                        OS_OPT_POST_LIFO
    669          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL
    670          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL
    671          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_NO_SCHED
    672          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_NO_SCHED
    673          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    674          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    675          *
    676          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    677          *
    678          *                                OS_ERR_NONE            The call was successful and the message was sent
    679          *                                OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs to use to place the message into
    680          *                                OS_ERR_OBJ_PTR_NULL    If 'p_q' is a NULL pointer
    681          *                                OS_ERR_OBJ_TYPE        If the message queue was not initialized
    682          *                                OS_ERR_Q_MAX           If the queue is full
    683          *
    684          * Returns    : None
    685          ************************************************************************************************************************
    686          */
    687          

   \                                 In section .text, align 2, keep-with-next
    688          void  OSQPost (OS_Q         *p_q,
    689                         void         *p_void,
    690                         OS_MSG_SIZE   msg_size,
    691                         OS_OPT        opt,
    692                         OS_ERR       *p_err)
    693          {
   \                     OSQPost: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    694              CPU_TS  ts;
    695          
    696          
    697          
    698          #ifdef OS_SAFETY_CRITICAL
    699              if (p_err == (OS_ERR *)0) {
    700                  OS_SAFETY_CRITICAL_EXCEPTION();
    701                  return;
    702              }
    703          #endif
    704          
    705          #if OS_CFG_ARG_CHK_EN > 0u
    706              if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD104             BNE.N    ??OSQPost_0
    707                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000016   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000001A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    708                  return;
   \   0000001E   0xE04C             B.N      ??OSQPost_1
    709              }
    710              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSQPost_0: (+1)
   \   00000020   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD015             BEQ.N    ??OSQPost_2
   \   00000028   0x2810             CMP      R0,#+16
   \   0000002A   0xD013             BEQ.N    ??OSQPost_2
   \   0000002C   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000030   0xD010             BEQ.N    ??OSQPost_2
   \   00000032   0xF5B0 0x7F04      CMP      R0,#+528
   \   00000036   0xD00D             BEQ.N    ??OSQPost_2
   \   00000038   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003C   0xD00A             BEQ.N    ??OSQPost_2
   \   0000003E   0xF248 0x0110      MOVW     R1,#+32784
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD006             BEQ.N    ??OSQPost_2
   \   00000046   0xF5B0 0x4F02      CMP      R0,#+33280
   \   0000004A   0xD003             BEQ.N    ??OSQPost_2
   \   0000004C   0xF248 0x2110      MOVW     R1,#+33296
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD104             BNE.N    ??OSQPost_3
    711                  case OS_OPT_POST_FIFO:
    712                  case OS_OPT_POST_LIFO:
    713                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL:
    714                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL:
    715                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
    716                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
    717                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    718                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    719                       break;
    720          
    721                  default:
    722                      *p_err =  OS_ERR_OPT_INVALID;
    723                       return;
    724              }
    725          #endif
    726          
    727          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    728              if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
   \                     ??OSQPost_2: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x....             LDR.N    R1,??DataTable10_4  ;; 0x55455551
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD105             BNE.N    ??OSQPost_4
   \   0000005C   0xE009             B.N      ??OSQPost_5
   \                     ??OSQPost_3: (+1)
   \   0000005E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000062   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000066   0xE028             B.N      ??OSQPost_1
    729                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSQPost_4: (+1)
   \   00000068   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000006C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    730                  return;
   \   00000070   0xE023             B.N      ??OSQPost_1
    731              }
    732          #endif
    733          
    734              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSQPost_5: (+1)
   \   00000072   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000076   0x4681             MOV      R9,R0
    735          
    736          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    737              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
   \   00000078   0x....             LDR.N    R0,??DataTable10_2
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD010             BEQ.N    ??OSQPost_6
    738                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_Q,             /* Post to ISR queue                                      */
    739                              (void      *)p_q,
    740                              (void      *)p_void,
    741                              (OS_MSG_SIZE)msg_size,
    742                              (OS_FLAGS   )0,
    743                              (OS_OPT     )opt,
    744                              (CPU_TS     )ts,
    745                              (OS_ERR    *)p_err);
   \   00000080   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \   00000084   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0x0033             MOVS     R3,R6
   \   00000094   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000096   0x002A             MOVS     R2,R5
   \   00000098   0x0021             MOVS     R1,R4
   \   0000009A   0x....             LDR.N    R0,??DataTable10_4  ;; 0x55455551
   \   0000009C   0x.... 0x....      BL       OS_IntQPost
    746                  return;
   \   000000A0   0xE00B             B.N      ??OSQPost_1
    747              }
    748          #endif
    749          
    750              OS_QPost(p_q,
    751                       p_void,
    752                       msg_size,
    753                       opt,
    754                       ts,
    755                       p_err);
   \                     ??OSQPost_6: (+1)
   \   000000A2   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000A6   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000AA   0x003B             MOVS     R3,R7
   \   000000AC   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000AE   0x0032             MOVS     R2,R6
   \   000000B0   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000B2   0x0029             MOVS     R1,R5
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       OS_QPost
    756          }
   \                     ??OSQPost_1: (+1)
   \   000000BA   0xB005             ADD      SP,SP,#+20
   \   000000BC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    757          
    758          /*$PAGE*/
    759          /*
    760          ************************************************************************************************************************
    761          *                                        CLEAR THE CONTENTS OF A MESSAGE QUEUE
    762          *
    763          * Description: This function is called by OSQDel() to clear the contents of a message queue
    764          *
    765          
    766          * Argument(s): p_q      is a pointer to the queue to clear
    767          *              ---
    768          *
    769          * Returns    : none
    770          *
    771          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    772          ************************************************************************************************************************
    773          */
    774          

   \                                 In section .text, align 2, keep-with-next
    775          void  OS_QClr (OS_Q  *p_q)
    776          {
   \                     OS_QClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    777              (void)OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the free list                    */
   \   00000004   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000008   0x.... 0x....      BL       OS_MsgQFreeAll
    778              p_q->Type    =  OS_OBJ_TYPE_NONE;                       /* Mark the data structure as a NONE                      */
   \   0000000C   0x....             LDR.N    R0,??DataTable10_8  ;; 0x454e4f4e
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    779              p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
   \   00000010   0x....             ADR.N    R0,??DataTable10  ;; 0x3F, 0x51, 0x00, 0x00
   \   00000012   0x6060             STR      R0,[R4, #+4]
    780              OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the list of OS_MSGs                         */
    781                          0u);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000001A   0x.... 0x....      BL       OS_MsgQInit
    782              OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
   \   0000001E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000022   0x.... 0x....      BL       OS_PendListInit
    783          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    784          
    785          /*$PAGE*/
    786          /*
    787          ************************************************************************************************************************
    788          *                                      ADD/REMOVE MESSAGE QUEUE TO/FROM DEBUG LIST
    789          *
    790          * Description: These functions are called by uC/OS-III to add or remove a message queue to/from a message queue debug
    791          *              list.
    792          *
    793          * Arguments  : p_q     is a pointer to the message queue to add/remove
    794          *
    795          * Returns    : none
    796          *
    797          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    798          ************************************************************************************************************************
    799          */
    800          
    801          
    802          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    803          void  OS_QDbgListAdd (OS_Q  *p_q)
    804          {
    805              p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_QDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable10_1  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    806              p_q->DbgPrevPtr               = (OS_Q     *)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    807              if (OSQDbgListPtr == (OS_Q *)0) {
   \   00000008   0x....             LDR.N    R1,??DataTable10_9
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_QDbgListAdd_0
    808                  p_q->DbgNextPtr           = (OS_Q     *)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_QDbgListAdd_1
    809              } else {
    810                  p_q->DbgNextPtr           =  OSQDbgListPtr;
   \                     ??OS_QDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable10_9
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    811                  OSQDbgListPtr->DbgPrevPtr =  p_q;
   \   0000001C   0x....             LDR.N    R1,??DataTable10_9
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    812              }
    813              OSQDbgListPtr                 =  p_q;
   \                     ??OS_QDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable10_9
   \   00000024   0x6008             STR      R0,[R1, #+0]
    814          }
   \   00000026   0x4770             BX       LR               ;; return
    815          
    816          
    817          

   \                                 In section .text, align 2, keep-with-next
    818          void  OS_QDbgListRemove (OS_Q  *p_q)
    819          {
    820              OS_Q  *p_q_next;
    821              OS_Q  *p_q_prev;
    822          
    823          
    824              p_q_prev = p_q->DbgPrevPtr;
   \                     OS_QDbgListRemove: (+1)
   \   00000000   0x6943             LDR      R3,[R0, #+20]
   \   00000002   0x001A             MOVS     R2,R3
    825              p_q_next = p_q->DbgNextPtr;
   \   00000004   0x6983             LDR      R3,[R0, #+24]
   \   00000006   0x0019             MOVS     R1,R3
    826          
    827              if (p_q_prev == (OS_Q *)0) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??OS_QDbgListRemove_0
    828                  OSQDbgListPtr = p_q_next;
   \   0000000C   0x....             LDR.N    R3,??DataTable10_9
   \   0000000E   0x6019             STR      R1,[R3, #+0]
    829                  if (p_q_next != (OS_Q *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??OS_QDbgListRemove_1
    830                      p_q_next->DbgPrevPtr = (OS_Q *)0;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x614B             STR      R3,[R1, #+20]
    831                  }
    832                  p_q->DbgNextPtr = (OS_Q *)0;
   \                     ??OS_QDbgListRemove_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6183             STR      R3,[R0, #+24]
   \   0000001C   0xE00C             B.N      ??OS_QDbgListRemove_2
    833          
    834              } else if (p_q_next == (OS_Q *)0) {
   \                     ??OS_QDbgListRemove_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_QDbgListRemove_3
    835                  p_q_prev->DbgNextPtr = (OS_Q *)0;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x6193             STR      R3,[R2, #+24]
    836                  p_q->DbgPrevPtr      = (OS_Q *)0;
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x6143             STR      R3,[R0, #+20]
   \   0000002A   0xE005             B.N      ??OS_QDbgListRemove_2
    837          
    838              } else {
    839                  p_q_prev->DbgNextPtr =  p_q_next;
   \                     ??OS_QDbgListRemove_3: (+1)
   \   0000002C   0x6191             STR      R1,[R2, #+24]
    840                  p_q_next->DbgPrevPtr =  p_q_prev;
   \   0000002E   0x614A             STR      R2,[R1, #+20]
    841                  p_q->DbgNextPtr      = (OS_Q *)0;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x6183             STR      R3,[R0, #+24]
    842                  p_q->DbgPrevPtr      = (OS_Q *)0;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x6143             STR      R3,[R0, #+20]
    843              }
    844          }
   \                     ??OS_QDbgListRemove_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    845          #endif
    846          
    847          /*$PAGE*/
    848          /*
    849          ************************************************************************************************************************
    850          *                                              MESSAGE QUEUE INITIALIZATION
    851          *
    852          * Description: This function is called by OSInit() to initialize the message queue management.
    853          *
    854          
    855          * Arguments  : p_err         is a pointer to a variable that will receive an error code.
    856          *
    857          *                                OS_ERR_NONE     the call was successful
    858          *
    859          * Returns    : none
    860          *
    861          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    862          ************************************************************************************************************************
    863          */
    864          

   \                                 In section .text, align 2, keep-with-next
    865          void  OS_QInit (OS_ERR  *p_err)
    866          {
    867          #ifdef OS_SAFETY_CRITICAL
    868              if (p_err == (OS_ERR *)0) {
    869                  OS_SAFETY_CRITICAL_EXCEPTION();
    870                  return;
    871              }
    872          #endif
    873          
    874          #if OS_CFG_DBG_EN > 0u
    875              OSQDbgListPtr = (OS_Q *)0;
   \                     OS_QInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable10_9
   \   00000004   0x6011             STR      R1,[R2, #+0]
    876          #endif
    877          
    878              OSQQty        = (OS_OBJ_QTY)0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable10_5
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    879             *p_err         = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    880          }
   \   00000010   0x4770             BX       LR               ;; return
    881          
    882          /*$PAGE*/
    883          /*
    884          ************************************************************************************************************************
    885          *                                               POST MESSAGE TO A QUEUE
    886          *
    887          * Description: This function sends a message to a queue.  With the 'opt' argument, you can specify whether the message
    888          *              is broadcast to all waiting tasks and/or whether you post the message to the front of the queue (LIFO)
    889          *              or normally (FIFO) at the end of the queue.
    890          *
    891          * Arguments  : p_q           is a pointer to a message queue that must have been created by OSQCreate().
    892          *
    893          *              p_void        is a pointer to the message to send.
    894          *
    895          *              msg_size      specifies the size of the message (in bytes)
    896          *
    897          *              opt           determines the type of POST performed:
    898          *
    899          *                                OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the queue
    900          *
    901          *                                OS_OPT_POST_FIFO         POST as FIFO and wake up single waiting task
    902          *                                OS_OPT_POST_LIFO         POST as LIFO and wake up single waiting task
    903          *
    904          *                                OS_OPT_POST_NO_SCHED     Do not call the scheduler
    905          *
    906          *              ts            is the timestamp of the post
    907          *
    908          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    909          *
    910          *                                OS_ERR_NONE            The call was successful and the message was sent
    911          *                                OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs to use to place the message into
    912          *                                OS_ERR_OBJ_PTR_NULL    If 'p_q' is a NULL pointer
    913          *                                OS_ERR_OBJ_TYPE        If the message queue was not initialized
    914          *                                OS_ERR_Q_MAX           If the queue is full
    915          *
    916          * Returns    : None
    917          *
    918          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    919          ************************************************************************************************************************
    920          */
    921          

   \                                 In section .text, align 2, keep-with-next
    922          void  OS_QPost (OS_Q         *p_q,
    923                          void         *p_void,
    924                          OS_MSG_SIZE   msg_size,
    925                          OS_OPT        opt,
    926                          CPU_TS        ts,
    927                          OS_ERR       *p_err)
    928          {
   \                     OS_QPost: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8040      LDR      R8,[SP, #+64]
   \   00000012   0xF8DD 0x9044      LDR      R9,[SP, #+68]
    929              OS_OBJ_QTY     cnt;
    930              OS_OPT         post_type;
    931              OS_PEND_LIST  *p_pend_list;
    932              OS_PEND_DATA  *p_pend_data;
    933              OS_PEND_DATA  *p_pend_data_next;
    934              OS_TCB        *p_tcb;
    935              CPU_SR_ALLOC();
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
    936          
    937          
    938          
    939              OS_CRITICAL_ENTER();
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x4683             MOV      R11,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000024   0x....             LDR.N    R0,??DataTable10_3
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable10_3
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   \   0000002E   0x....             LDR.N    R0,??DataTable10_3
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD101             BNE.N    ??OS_QPost_0
   \   00000036   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_QPost_0: (+1)
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x4658             MOV      R0,R11
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    940              p_pend_list = &p_q->PendList;
   \   00000044   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000048   0x9004             STR      R0,[SP, #+16]
    941              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on message queue?                     */
   \   0000004A   0x9804             LDR      R0,[SP, #+16]
   \   0000004C   0x8900             LDRH     R0,[R0, #+8]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD13D             BNE.N    ??OS_QPost_1
    942                  if ((opt & OS_OPT_POST_LIFO) == (OS_OPT)0) {        /* Determine whether we post FIFO or LIFO                 */
   \   00000052   0x06F8             LSLS     R0,R7,#+27
   \   00000054   0xD403             BMI.N    ??OS_QPost_2
    943                      post_type = OS_OPT_POST_FIFO;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   0000005C   0xE002             B.N      ??OS_QPost_3
    944                  } else {
    945                      post_type = OS_OPT_POST_LIFO;
   \                     ??OS_QPost_2: (+1)
   \   0000005E   0x2010             MOVS     R0,#+16
   \   00000060   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    946                  }
    947                  OS_MsgQPut(&p_q->MsgQ,                              /* Place message in the message queue                     */
    948                             p_void,
    949                             msg_size,
    950                             post_type,
    951                             ts,
    952                             p_err);
   \                     ??OS_QPost_3: (+1)
   \   00000064   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000068   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000006C   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \   00000070   0x0032             MOVS     R2,R6
   \   00000072   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000074   0x0029             MOVS     R1,R5
   \   00000076   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000007A   0x.... 0x....      BL       OS_MsgQPut
    953                  OS_CRITICAL_EXIT();
   \   0000007E   0x.... 0x....      BL       CPU_SR_Save
   \   00000082   0x4683             MOV      R11,R0
   \   00000084   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000088   0x....             LDR.N    R0,??DataTable10_3
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x....             LDR.N    R1,??DataTable10_3
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   \   00000092   0x....             LDR.N    R0,??DataTable10_3
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD113             BNE.N    ??OS_QPost_4
   \   0000009A   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000009E   0x....             LDR.N    R0,??DataTable10_6
   \   000000A0   0x8800             LDRH     R0,[R0, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD007             BEQ.N    ??OS_QPost_5
   \   000000A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AA   0x4658             MOV      R0,R11
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
   \   000000B0   0x.... 0x....      BL       OS_Sched0
   \   000000B4   0xE00A             B.N      ??OS_QPost_6
   \                     ??OS_QPost_5: (+1)
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BA   0x4658             MOV      R0,R11
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
   \   000000C0   0xE004             B.N      ??OS_QPost_6
   \                     ??OS_QPost_4: (+1)
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x4658             MOV      R0,R11
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    954                  return;
   \                     ??OS_QPost_6: (+1)
   \   000000CC   0xE03F             B.N      ??OS_QPost_7
    955              }
    956          
    957              if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
   \                     ??OS_QPost_1: (+1)
   \   000000CE   0x05B8             LSLS     R0,R7,#+22
   \   000000D0   0xD503             BPL.N    ??OS_QPost_8
    958                  cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
   \   000000D2   0x9804             LDR      R0,[SP, #+16]
   \   000000D4   0x8900             LDRH     R0,[R0, #+8]
   \   000000D6   0x4682             MOV      R10,R0
   \   000000D8   0xE001             B.N      ??OS_QPost_9
    959              } else {
    960                  cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
   \                     ??OS_QPost_8: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x4682             MOV      R10,R0
    961              }
    962              p_pend_data = p_pend_list->HeadPtr;
   \                     ??OS_QPost_9: (+1)
   \   000000DE   0x9804             LDR      R0,[SP, #+16]
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x9003             STR      R0,[SP, #+12]
    963              while (cnt > 0u) {
   \                     ??OS_QPost_10: (+1)
   \   000000E4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000E8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000EC   0xD013             BEQ.N    ??OS_QPost_11
    964                  p_tcb            = p_pend_data->TCBPtr;
   \   000000EE   0x9803             LDR      R0,[SP, #+12]
   \   000000F0   0x6880             LDR      R0,[R0, #+8]
   \   000000F2   0x9005             STR      R0,[SP, #+20]
    965                  p_pend_data_next = p_pend_data->NextPtr;
   \   000000F4   0x9803             LDR      R0,[SP, #+12]
   \   000000F6   0x6840             LDR      R0,[R0, #+4]
   \   000000F8   0x9006             STR      R0,[SP, #+24]
    966                  OS_Post((OS_PEND_OBJ *)((void *)p_q),
    967                          p_tcb,
    968                          p_void,
    969                          msg_size,
    970                          ts);
   \   000000FA   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000FE   0x0033             MOVS     R3,R6
   \   00000100   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000102   0x002A             MOVS     R2,R5
   \   00000104   0x9905             LDR      R1,[SP, #+20]
   \   00000106   0x0020             MOVS     R0,R4
   \   00000108   0x.... 0x....      BL       OS_Post
    971                  p_pend_data = p_pend_data_next;
   \   0000010C   0x9806             LDR      R0,[SP, #+24]
   \   0000010E   0x9003             STR      R0,[SP, #+12]
    972                  cnt--;
   \   00000110   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000114   0xE7E6             B.N      ??OS_QPost_10
    973              }
    974              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OS_QPost_11: (+1)
   \   00000116   0x.... 0x....      BL       CPU_SR_Save
   \   0000011A   0x4683             MOV      R11,R0
   \   0000011C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000120   0x....             LDR.N    R0,??DataTable10_3
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x1E40             SUBS     R0,R0,#+1
   \   00000126   0x....             LDR.N    R1,??DataTable10_3
   \   00000128   0x7008             STRB     R0,[R1, #+0]
   \   0000012A   0x....             LDR.N    R0,??DataTable10_3
   \   0000012C   0x7800             LDRB     R0,[R0, #+0]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD101             BNE.N    ??OS_QPost_12
   \   00000132   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_QPost_12: (+1)
   \   00000136   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000013A   0x4658             MOV      R0,R11
   \   0000013C   0x.... 0x....      BL       CPU_SR_Restore
    975              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   00000140   0x0438             LSLS     R0,R7,#+16
   \   00000142   0xD401             BMI.N    ??OS_QPost_13
    976                  OSSched();                                          /* Run the scheduler                                      */
   \   00000144   0x.... 0x....      BL       OSSched
    977              }
    978             *p_err = OS_ERR_NONE;
   \                     ??OS_QPost_13: (+1)
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    979          }
   \                     ??OS_QPost_7: (+1)
   \   0000014E   0xB007             ADD      SP,SP,#+28
   \   00000150   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x3F 0x51          DC8      0x3F, 0x51, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x55455551         DC32     0x55455551

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OSQQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     OSQDbgListPtr

   \                                 In section .rodata, align 4
   \   00000000   0x3F 0x51          DC8 "?Q"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
    980          
    981          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSQCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQInit
        24   -> OS_PendListInit
        24   -> OS_QDbgListAdd
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      48   OSQDel
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_TS_TmrRd
        48   -> OSSched
        48   -> OS_PendObjDel
        48   -> OS_QClr
        48   -> OS_QDbgListRemove
        48   -> OS_SchedLockTimeMeasStart
        48   -> OS_SchedLockTimeMeasStop
      24   OSQFlush
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQFreeAll
        24   -> OS_Sched0
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      72   OSQPend
        72   -> CPU_IntDisMeasStart
        72   -> CPU_IntDisMeasStop
        72   -> CPU_SR_Restore
        72   -> CPU_SR_Save
        72   -> OSSched
        72   -> OS_MsgQGet
        72   -> OS_Pend
        72   -> OS_SchedLockTimeMeasStart
        72   -> OS_SchedLockTimeMeasStop
      40   OSQPendAbort
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_PendAbort
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
      48   OSQPost
        48   -> CPU_TS_TmrRd
        48   -> OS_IntQPost
        48   -> OS_QPost
       8   OS_QClr
         8   -> OS_MsgQFreeAll
         8   -> OS_MsgQInit
         8   -> OS_PendListInit
       0   OS_QDbgListAdd
       0   OS_QDbgListRemove
       0   OS_QInit
      64   OS_QPost
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OS_MsgQPut
        64   -> OS_Post
        64   -> OS_Sched0
        64   -> OS_SchedLockTimeMeasStart
        64   -> OS_SchedLockTimeMeasStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ?_0
       2  ?_1
     212  OSQCreate
     382  OSQDel
     216  OSQFlush
     570  OSQPend
     286  OSQPendAbort
     192  OSQPost
      40  OS_QClr
      40  OS_QDbgListAdd
      58  OS_QDbgListRemove
      18  OS_QInit
     340  OS_QPost

 
     6 bytes in section .rodata
 2 394 bytes in section .text
 
 2 394 bytes of CODE  memory
     6 bytes of CONST memory

Errors: none
Warnings: none
