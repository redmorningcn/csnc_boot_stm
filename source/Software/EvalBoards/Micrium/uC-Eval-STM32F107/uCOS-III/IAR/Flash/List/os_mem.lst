###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_mem.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_mem.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_mem.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_mem.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_mem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                             MEMORY PARTITION MANAGEMENT
     10          *
     11          * File    : OS_MEM.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define   MICRIUM_SOURCE
     34          #include  <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_mem__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_MEM_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                               CREATE A MEMORY PARTITION
     45          *
     46          * Description : Create a fixed-sized memory partition that will be managed by uC/OS-III.
     47          *
     48          * Arguments   : p_mem    is a pointer to a memory partition control block which is allocated in user memory space.
     49          *
     50          *               p_name   is a pointer to an ASCII string to provide a name to the memory partition.
     51          *
     52          *               p_addr   is the starting address of the memory partition
     53          *
     54          *               n_blks   is the number of memory blocks to create from the partition.
     55          *
     56          *               blk_size is the size (in bytes) of each block in the memory partition.
     57          *
     58          *               p_err    is a pointer to a variable containing an error message which will be set by this function to
     59          *                        either:
     60          *
     61          *                            OS_ERR_NONE                    if the memory partition has been created correctly.
     62          *                            OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the memory partition after you
     63          *                                                             called OSSafetyCriticalStart().
     64          *                            OS_ERR_MEM_INVALID_BLKS        user specified an invalid number of blocks (must be >= 2)
     65          *                            OS_ERR_MEM_INVALID_P_ADDR      if you are specifying an invalid address for the memory
     66          *                                                           storage of the partition or, the block does not align on a
     67          *                                                           pointer boundary
     68          *                            OS_ERR_MEM_INVALID_SIZE        user specified an invalid block size
     69          *                                                             - must be greater than the size of a pointer
     70          *                                                             - must be able to hold an integral number of pointers
     71          * Returns    : none
     72          ************************************************************************************************************************
     73          */
     74          

   \                                 In section .text, align 2, keep-with-next
     75          void  OSMemCreate (OS_MEM       *p_mem,
     76                             CPU_CHAR     *p_name,
     77                             void         *p_addr,
     78                             OS_MEM_QTY    n_blks,
     79                             OS_MEM_SIZE   blk_size,
     80                             OS_ERR       *p_err)
     81          {
   \                     OSMemCreate: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x469B             MOV      R11,R3
   \   0000000C   0x9C0E             LDR      R4,[SP, #+56]
   \   0000000E   0x9F0F             LDR      R7,[SP, #+60]
     82          #if OS_CFG_ARG_CHK_EN > 0u
     83              CPU_DATA       align_msk;
     84          #endif
     85              OS_MEM_QTY     i;
     86              OS_MEM_QTY     loops;
     87              CPU_INT08U    *p_blk;
     88              void         **p_link;
     89              CPU_SR_ALLOC();
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
     90          
     91          
     92          
     93          #ifdef OS_SAFETY_CRITICAL
     94              if (p_err == (OS_ERR *)0) {
     95                  OS_SAFETY_CRITICAL_EXCEPTION();
     96                  return;
     97              }
     98          #endif
     99          
    100          #ifdef OS_SAFETY_CRITICAL_IEC61508
    101              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    102                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    103                  return;
    104              }
    105          #endif
    106          
    107          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    108              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \   00000014   0x....             LDR.N    R0,??DataTable2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD003             BEQ.N    ??OSMemCreate_0
    109                 *p_err = OS_ERR_MEM_CREATE_ISR;
   \   0000001C   0xF245 0x60B9      MOVW     R0,#+22201
   \   00000020   0x8038             STRH     R0,[R7, #+0]
    110                  return;
   \   00000022   0xE085             B.N      ??OSMemCreate_1
    111              }
    112          #endif
    113          
    114          #if OS_CFG_ARG_CHK_EN > 0u
    115              if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
   \                     ??OSMemCreate_0: (+1)
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD103             BNE.N    ??OSMemCreate_2
    116                 *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
   \   00000028   0xF245 0x60BB      MOVW     R0,#+22203
   \   0000002C   0x8038             STRH     R0,[R7, #+0]
    117                  return;
   \   0000002E   0xE07F             B.N      ??OSMemCreate_1
    118              }
    119              if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
   \                     ??OSMemCreate_2: (+1)
   \   00000030   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   00000034   0xF1BB 0x0F02      CMP      R11,#+2
   \   00000038   0xDA03             BGE.N    ??OSMemCreate_3
    120                 *p_err = OS_ERR_MEM_INVALID_BLKS;
   \   0000003A   0xF245 0x60BC      MOVW     R0,#+22204
   \   0000003E   0x8038             STRH     R0,[R7, #+0]
    121                  return;
   \   00000040   0xE076             B.N      ??OSMemCreate_1
    122              }
    123              if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
   \                     ??OSMemCreate_3: (+1)
   \   00000042   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000044   0x2C04             CMP      R4,#+4
   \   00000046   0xD203             BCS.N    ??OSMemCreate_4
    124                 *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   00000048   0xF245 0x60C1      MOVW     R0,#+22209
   \   0000004C   0x8038             STRH     R0,[R7, #+0]
    125                  return;
   \   0000004E   0xE06F             B.N      ??OSMemCreate_1
    126              }
    127              align_msk = sizeof(void *) - 1u;
   \                     ??OSMemCreate_4: (+1)
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0x9001             STR      R0,[SP, #+4]
    128              if (align_msk > 0u) {
   \   00000054   0x9801             LDR      R0,[SP, #+4]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00F             BEQ.N    ??OSMemCreate_5
    129                  if (((CPU_ADDR)p_addr & align_msk) != 0u){          /* Must be pointer size aligned                           */
   \   0000005A   0x9801             LDR      R0,[SP, #+4]
   \   0000005C   0x4206             TST      R6,R0
   \   0000005E   0xD003             BEQ.N    ??OSMemCreate_6
    130                     *p_err = OS_ERR_MEM_INVALID_P_ADDR;
   \   00000060   0xF245 0x60BB      MOVW     R0,#+22203
   \   00000064   0x8038             STRH     R0,[R7, #+0]
    131                      return;
   \   00000066   0xE063             B.N      ??OSMemCreate_1
    132                  }
    133                  if ((blk_size & align_msk) != 0u) {                 /* Block size must be a multiple address size             */
   \                     ??OSMemCreate_6: (+1)
   \   00000068   0x9901             LDR      R1,[SP, #+4]
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006E   0x4208             TST      R0,R1
   \   00000070   0xD003             BEQ.N    ??OSMemCreate_5
    134                     *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   00000072   0xF245 0x60C1      MOVW     R0,#+22209
   \   00000076   0x8038             STRH     R0,[R7, #+0]
    135                      return;
   \   00000078   0xE05A             B.N      ??OSMemCreate_1
    136                  }
    137              }
    138          #endif
    139          
    140              p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
   \                     ??OSMemCreate_5: (+1)
   \   0000007A   0x9600             STR      R6,[SP, #+0]
    141              p_blk  = (CPU_INT08U *)p_addr;
   \   0000007C   0x46B1             MOV      R9,R6
    142              loops  = n_blks - 1u;
   \   0000007E   0xF1BB 0x0001      SUBS     R0,R11,#+1
   \   00000082   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    143              for (i = 0u; i < loops; i++) {
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x4680             MOV      R8,R0
   \                     ??OSMemCreate_7: (+1)
   \   0000008A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000008E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000092   0x4580             CMP      R8,R0
   \   00000094   0xD20A             BCS.N    ??OSMemCreate_8
    144                  p_blk +=  blk_size;
   \   00000096   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000098   0xEB14 0x0909      ADDS     R9,R4,R9
    145                 *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0xF8C0 0x9000      STR      R9,[R0, #+0]
    146                  p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
   \   000000A2   0xF8CD 0x9000      STR      R9,[SP, #+0]
    147              }
   \   000000A6   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000AA   0xE7EE             B.N      ??OSMemCreate_7
    148             *p_link             = (void *)0;                         /* Last memory block points to NULL                       */
   \                     ??OSMemCreate_8: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x9900             LDR      R1,[SP, #+0]
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    149          
    150              OS_CRITICAL_ENTER();
   \   000000B2   0x.... 0x....      BL       CPU_SR_Save
   \   000000B6   0x4682             MOV      R10,R0
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000BC   0x....             LDR.N    R0,??DataTable2_1
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0x....             LDR.N    R1,??DataTable2_1
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   \   000000C6   0x....             LDR.N    R0,??DataTable2_1
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x2801             CMP      R0,#+1
   \   000000CC   0xD101             BNE.N    ??OSMemCreate_9
   \   000000CE   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSMemCreate_9: (+1)
   \   000000D2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D6   0x4650             MOV      R0,R10
   \   000000D8   0x.... 0x....      BL       CPU_SR_Restore
    151              p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
   \   000000DC   0x....             LDR.N    R0,??DataTable2_2  ;; 0x204d454d
   \   000000DE   0x6028             STR      R0,[R5, #+0]
    152              p_mem->NamePtr     = p_name;                            /* Save name of memory partition                          */
   \   000000E0   0x9804             LDR      R0,[SP, #+16]
   \   000000E2   0x60A8             STR      R0,[R5, #+8]
    153              p_mem->AddrPtr     = p_addr;                            /* Store start address of memory partition                */
   \   000000E4   0x606E             STR      R6,[R5, #+4]
    154              p_mem->FreeListPtr = p_addr;                            /* Initialize pointer to pool of free blocks              */
   \   000000E6   0x60EE             STR      R6,[R5, #+12]
    155              p_mem->NbrFree     = n_blks;                            /* Store number of free blocks in MCB                     */
   \   000000E8   0xF8A5 0xB014      STRH     R11,[R5, #+20]
    156              p_mem->NbrMax      = n_blks;
   \   000000EC   0xF8A5 0xB012      STRH     R11,[R5, #+18]
    157              p_mem->BlkSize     = blk_size;                          /* Store block size of each memory blocks                 */
   \   000000F0   0x822C             STRH     R4,[R5, #+16]
    158          
    159          #if OS_CFG_DBG_EN > 0u
    160              OS_MemDbgListAdd(p_mem);
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0x.... 0x....      BL       OS_MemDbgListAdd
    161          #endif
    162          
    163              OSMemQty++;
   \   000000F8   0x....             LDR.N    R0,??DataTable2_3
   \   000000FA   0x8800             LDRH     R0,[R0, #+0]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x....             LDR.N    R1,??DataTable2_3
   \   00000100   0x8008             STRH     R0,[R1, #+0]
    164          
    165              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000102   0x.... 0x....      BL       CPU_SR_Save
   \   00000106   0x4682             MOV      R10,R0
   \   00000108   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000010C   0x....             LDR.N    R0,??DataTable2_1
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x1E40             SUBS     R0,R0,#+1
   \   00000112   0x....             LDR.N    R1,??DataTable2_1
   \   00000114   0x7008             STRB     R0,[R1, #+0]
   \   00000116   0x....             LDR.N    R0,??DataTable2_1
   \   00000118   0x7800             LDRB     R0,[R0, #+0]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD101             BNE.N    ??OSMemCreate_10
   \   0000011E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSMemCreate_10: (+1)
   \   00000122   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000126   0x4650             MOV      R0,R10
   \   00000128   0x.... 0x....      BL       CPU_SR_Restore
    166             *p_err = OS_ERR_NONE;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x8038             STRH     R0,[R7, #+0]
    167          }
   \                     ??OSMemCreate_1: (+1)
   \   00000130   0xB005             ADD      SP,SP,#+20
   \   00000132   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    168          
    169          /*$PAGE*/
    170          /*
    171          ************************************************************************************************************************
    172          *                                                  GET A MEMORY BLOCK
    173          *
    174          * Description : Get a memory block from a partition
    175          *
    176          * Arguments   : p_mem   is a pointer to the memory partition control block
    177          *
    178          *               p_err   is a pointer to a variable containing an error message which will be set by this function to
    179          *                       either:
    180          *
    181          *                       OS_ERR_NONE               if the memory partition has been created correctly.
    182          *                       OS_ERR_MEM_INVALID_P_MEM  if you passed a NULL pointer for 'p_mem'
    183          *                       OS_ERR_MEM_NO_FREE_BLKS   if there are no more free memory blocks to allocate to the caller
    184          *
    185          * Returns     : A pointer to a memory block if no error is detected
    186          *               A pointer to NULL if an error is detected
    187          ************************************************************************************************************************
    188          */
    189          

   \                                 In section .text, align 2, keep-with-next
    190          void  *OSMemGet (OS_MEM  *p_mem,
    191                           OS_ERR  *p_err)
    192          {
   \                     OSMemGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    193              void    *p_blk;
    194              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    195          
    196          
    197          
    198          #ifdef OS_SAFETY_CRITICAL
    199              if (p_err == (OS_ERR *)0) {
    200                  OS_SAFETY_CRITICAL_EXCEPTION();
    201                  return ((void *)0);
    202              }
    203          #endif
    204          
    205          #if OS_CFG_ARG_CHK_EN > 0u
    206              if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??OSMemGet_0
    207                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000C   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000010   0x8028             STRH     R0,[R5, #+0]
    208                  return ((void *)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE020             B.N      ??OSMemGet_1
    209              }
    210          #endif
    211          
    212              CPU_CRITICAL_ENTER();
   \                     ??OSMemGet_0: (+1)
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   \   0000001A   0x0007             MOVS     R7,R0
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStart
    213              if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
   \   00000020   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD109             BNE.N    ??OSMemGet_2
    214                  CPU_CRITICAL_EXIT();
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x.... 0x....      BL       CPU_SR_Restore
    215                 *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
   \   00000030   0xF245 0x60C2      MOVW     R0,#+22210
   \   00000034   0x8028             STRH     R0,[R5, #+0]
    216                  return ((void *)0);                                 /*      Return NULL pointer to caller                     */
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE00E             B.N      ??OSMemGet_1
    217              }
    218              p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
   \                     ??OSMemGet_2: (+1)
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x0006             MOVS     R6,R0
    219              p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
   \   0000003E   0x6830             LDR      R0,[R6, #+0]
   \   00000040   0x60E0             STR      R0,[R4, #+12]
    220              p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
   \   00000042   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x82A0             STRH     R0,[R4, #+20]
    221              CPU_CRITICAL_EXIT();
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0x.... 0x....      BL       CPU_SR_Restore
    222             *p_err = OS_ERR_NONE;                                    /*      No error                                          */
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x8028             STRH     R0,[R5, #+0]
    223              return (p_blk);                                         /*      Return memory block to caller                     */
   \   00000056   0x0030             MOVS     R0,R6
   \                     ??OSMemGet_1: (+1)
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    224          }
    225          
    226          /*$PAGE*/
    227          /*
    228          ************************************************************************************************************************
    229          *                                                 RELEASE A MEMORY BLOCK
    230          *
    231          * Description : Returns a memory block to a partition
    232          *
    233          * Arguments   : p_mem    is a pointer to the memory partition control block
    234          *
    235          *               p_blk    is a pointer to the memory block being released.
    236          *
    237          *               p_err    is a pointer to a variable that will contain an error code returned by this function.
    238          *
    239          *                            OS_ERR_NONE               if the memory block was inserted into the partition
    240          *                            OS_ERR_MEM_FULL           if you are returning a memory block to an already FULL memory
    241          *                                                      partition (You freed more blocks than you allocated!)
    242          *                            OS_ERR_MEM_INVALID_P_BLK  if you passed a NULL pointer for the block to release.
    243          *                            OS_ERR_MEM_INVALID_P_MEM  if you passed a NULL pointer for 'p_mem'
    244          ************************************************************************************************************************
    245          */
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void  OSMemPut (OS_MEM  *p_mem,
    248                          void    *p_blk,
    249                          OS_ERR  *p_err)
    250          {
   \                     OSMemPut: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    251              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    252          
    253          
    254          
    255          #ifdef OS_SAFETY_CRITICAL
    256              if (p_err == (OS_ERR *)0) {
    257                  OS_SAFETY_CRITICAL_EXCEPTION();
    258                  return;
    259              }
    260          #endif
    261          
    262          #if OS_CFG_ARG_CHK_EN > 0u
    263              if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD103             BNE.N    ??OSMemPut_0
    264                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000E   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000012   0x8030             STRH     R0,[R6, #+0]
    265                  return;
   \   00000014   0xE024             B.N      ??OSMemPut_1
    266              }
    267              if (p_blk == (void *)0) {                               /* Must release a valid block                             */
   \                     ??OSMemPut_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD103             BNE.N    ??OSMemPut_2
    268                 *p_err  = OS_ERR_MEM_INVALID_P_BLK;
   \   0000001A   0xF245 0x60BE      MOVW     R0,#+22206
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    269                  return;
   \   00000020   0xE01E             B.N      ??OSMemPut_1
    270              }
    271          #endif
    272          
    273              CPU_CRITICAL_ENTER();
   \                     ??OSMemPut_2: (+1)
   \   00000022   0x.... 0x....      BL       CPU_SR_Save
   \   00000026   0x0007             MOVS     R7,R0
   \   00000028   0x.... 0x....      BL       CPU_IntDisMeasStart
    274              if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
   \   0000002C   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000002E   0x8A61             LDRH     R1,[R4, #+18]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD308             BCC.N    ??OSMemPut_3
    275                  CPU_CRITICAL_EXIT();
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x.... 0x....      BL       CPU_SR_Restore
    276                 *p_err = OS_ERR_MEM_FULL;
   \   0000003E   0xF245 0x60BA      MOVW     R0,#+22202
   \   00000042   0x8030             STRH     R0,[R6, #+0]
    277                  return;
   \   00000044   0xE00C             B.N      ??OSMemPut_1
    278              }
    279              *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
   \                     ??OSMemPut_3: (+1)
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x6028             STR      R0,[R5, #+0]
    280              p_mem->FreeListPtr = p_blk;
   \   0000004A   0x60E5             STR      R5,[R4, #+12]
    281              p_mem->NbrFree++;                                       /* One more memory block in this partition                */
   \   0000004C   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x82A0             STRH     R0,[R4, #+20]
    282              CPU_CRITICAL_EXIT();
   \   00000052   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    283             *p_err              = OS_ERR_NONE;                       /* Notify caller that memory block was released           */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8030             STRH     R0,[R6, #+0]
    284          }
   \                     ??OSMemPut_1: (+1)
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    285          
    286          /*$PAGE*/
    287          /*
    288          ************************************************************************************************************************
    289          *                                           ADD MEMORY PARTITION TO DEBUG LIST
    290          *
    291          * Description : This function is called by OSMemCreate() to add the memory partition to the debug table.
    292          *
    293          * Arguments   : p_mem    Is a pointer to the memory partition
    294          *
    295          * Returns     : none
    296          *
    297          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    298          ************************************************************************************************************************
    299          */
    300          
    301          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    302          void  OS_MemDbgListAdd (OS_MEM  *p_mem)
    303          {
    304              p_mem->DbgPrevPtr               = (OS_MEM *)0;
   \                     OS_MemDbgListAdd: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6181             STR      R1,[R0, #+24]
    305              if (OSMemDbgListPtr == (OS_MEM *)0) {
   \   00000004   0x....             LDR.N    R1,??DataTable2_4
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD102             BNE.N    ??OS_MemDbgListAdd_0
    306                  p_mem->DbgNextPtr           = (OS_MEM *)0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
   \   00000010   0xE005             B.N      ??OS_MemDbgListAdd_1
    307              } else {
    308                  p_mem->DbgNextPtr           =  OSMemDbgListPtr;
   \                     ??OS_MemDbgListAdd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable2_4
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    309                  OSMemDbgListPtr->DbgPrevPtr =  p_mem;
   \   00000018   0x....             LDR.N    R1,??DataTable2_4
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6188             STR      R0,[R1, #+24]
    310              }
    311              OSMemDbgListPtr                 =  p_mem;
   \                     ??OS_MemDbgListAdd_1: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable2_4
   \   00000020   0x6008             STR      R0,[R1, #+0]
    312          }
   \   00000022   0x4770             BX       LR               ;; return
    313          #endif
    314          
    315          /*$PAGE*/
    316          /*
    317          ************************************************************************************************************************
    318          *                                           INITIALIZE MEMORY PARTITION MANAGER
    319          *
    320          * Description : This function is called by uC/OS-III to initialize the memory partition manager.  Your
    321          *               application MUST NOT call this function.
    322          *
    323          * Arguments   : none
    324          *
    325          * Returns     : none
    326          *
    327          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    328          ************************************************************************************************************************
    329          */
    330          

   \                                 In section .text, align 2, keep-with-next
    331          void  OS_MemInit (OS_ERR  *p_err)
    332          {
    333          #ifdef OS_SAFETY_CRITICAL
    334              if (p_err == (OS_ERR *)0) {
    335                  OS_SAFETY_CRITICAL_EXCEPTION();
    336                  return;
    337              }
    338          #endif
    339          
    340          #if OS_CFG_DBG_EN > 0u
    341              OSMemDbgListPtr = (OS_MEM   *)0;
   \                     OS_MemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable2_4
   \   00000004   0x6011             STR      R1,[R2, #+0]
    342          #endif
    343          
    344              OSMemQty        = (OS_OBJ_QTY)0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable2_3
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    345             *p_err           = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    346          }
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x204D454D         DC32     0x204d454d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     OSMemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     OSMemDbgListPtr
    347          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   OSMemCreate
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> OS_MemDbgListAdd
        56   -> OS_SchedLockTimeMeasStart
        56   -> OS_SchedLockTimeMeasStop
      24   OSMemGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSMemPut
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   OS_MemDbgListAdd
       0   OS_MemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
     310  OSMemCreate
      90  OSMemGet
      98  OSMemPut
      36  OS_MemDbgListAdd
      18  OS_MemInit

 
 572 bytes in section .text
 
 572 bytes of CODE memory

Errors: none
Warnings: none
