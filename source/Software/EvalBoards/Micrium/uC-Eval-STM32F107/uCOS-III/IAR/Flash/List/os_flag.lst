###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/May/2018  08:55:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_flag.c
#    Command line =  
#        "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_flag.c"
#        -D USE_STDPERIPH_DRIVER -lCN "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List"
#        -o "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\uCOS-III\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\ST\STM32\inc\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\List\os_flag.lst
#    Object file  =  
#        F:\iar\001
#        backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\EvalBoards\Micrium\uC-Eval-STM32F107\uCOS-III\IAR\Flash\Obj\os_flag.o
#
###############################################################################

F:\iar\001 backup\Micrium_uC-Eval-STM32F107_uCOS-III\Micrium\Software\uCOS-III\Source\os_flag.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                EVENT FLAG MANAGEMENT
     10          *
     11          * File    : OS_FLAG.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_flag__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_FLAG_EN > 0u
     42          
     43          /*$PAGE*/
     44          /*
     45          ************************************************************************************************************************
     46          *                                                 CREATE AN EVENT FLAG
     47          *
     48          * Description: This function is called to create an event flag group.
     49          *
     50          * Arguments  : p_grp          is a pointer to the event flag group to create
     51          *
     52          *              p_name         is the name of the event flag group
     53          *
     54          *              flags          contains the initial value to store in the event flag group (typically 0).
     55          *
     56          *              p_err          is a pointer to an error code which will be returned to your application:
     57          *
     58          *                                 OS_ERR_NONE                    if the call was successful.
     59          *                                 OS_ERR_CREATE_ISR              if you attempted to create an Event Flag from an ISR.
     60          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the Event Flag after you
     61          *                                                                   called OSSafetyCriticalStart().
     62          *                                 OS_ERR_NAME                    if 'p_name' is a NULL pointer
     63          *                                 OS_ERR_OBJ_CREATED             if the event flag group has already been created
     64          *                                 OS_ERR_OBJ_PTR_NULL            if 'p_grp' is a NULL pointer
     65          *
     66          * Returns    : none
     67          ************************************************************************************************************************
     68          */
     69          

   \                                 In section .text, align 2, keep-with-next
     70          void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
     71                              CPU_CHAR     *p_name,
     72                              OS_FLAGS      flags,
     73                              OS_ERR       *p_err)
     74          {
   \                     OSFlagCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     75              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
     76          
     77          
     78          
     79          #ifdef OS_SAFETY_CRITICAL
     80              if (p_err == (OS_ERR *)0) {
     81                  OS_SAFETY_CRITICAL_EXCEPTION();
     82                  return;
     83              }
     84          #endif
     85          
     86          #ifdef OS_SAFETY_CRITICAL_IEC61508
     87              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     88                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     89                  return;
     90              }
     91          #endif
     92          
     93          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     94              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??OSFlagCreate_0
     95                 *p_err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE from an ISR                           */
   \   0000001A   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
     96                  return;
   \   00000020   0xE04C             B.N      ??OSFlagCreate_1
     97              }
     98          #endif
     99          
    100          #if OS_CFG_ARG_CHK_EN > 0u
    101              if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
   \                     ??OSFlagCreate_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??OSFlagCreate_2
    102                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8038             STRH     R0,[R7, #+0]
    103                  return;
   \   0000002C   0xE046             B.N      ??OSFlagCreate_1
    104              }
    105          #endif
    106          
    107              OS_CRITICAL_ENTER();
   \                     ??OSFlagCreate_2: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x4680             MOV      R8,R0
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD101             BNE.N    ??OSFlagCreate_3
   \   00000050   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagCreate_3: (+1)
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    108              p_grp->Type    = OS_OBJ_TYPE_FLAG;                      /* Set to event flag group type                           */
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable10_2  ;; 0x47414c46
   \   00000062   0x6020             STR      R0,[R4, #+0]
    109              p_grp->NamePtr = p_name;
   \   00000064   0x6065             STR      R5,[R4, #+4]
    110              p_grp->Flags   = flags;                                 /* Set to desired initial value                           */
   \   00000066   0x6226             STR      R6,[R4, #+32]
    111              p_grp->TS      = (CPU_TS)0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x6260             STR      R0,[R4, #+36]
    112              OS_PendListInit(&p_grp->PendList);
   \   0000006C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000070   0x.... 0x....      BL       OS_PendListInit
    113          
    114          #if OS_CFG_DBG_EN > 0u
    115              OS_FlagDbgListAdd(p_grp);
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       OS_FlagDbgListAdd
    116          #endif
    117              OSFlagQty++;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   0000007E   0x8800             LDRH     R0,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000086   0x8008             STRH     R0,[R1, #+0]
    118          
    119              OS_CRITICAL_EXIT_NO_SCHED();
   \   00000088   0x.... 0x....      BL       CPU_SR_Save
   \   0000008C   0x4680             MOV      R8,R0
   \   0000008E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x1E40             SUBS     R0,R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD101             BNE.N    ??OSFlagCreate_4
   \   000000AA   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagCreate_4: (+1)
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
    120             *p_err = OS_ERR_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x8038             STRH     R0,[R7, #+0]
    121          }
   \                     ??OSFlagCreate_1: (+1)
   \   000000BC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    122          
    123          /*$PAGE*/
    124          /*
    125          ************************************************************************************************************************
    126          *                                             DELETE AN EVENT FLAG GROUP
    127          *
    128          * Description: This function deletes an event flag group and readies all tasks pending on the event flag group.
    129          *
    130          * Arguments  : p_grp     is a pointer to the desired event flag group.
    131          *
    132          *              opt       determines delete options as follows:
    133          *
    134          *                            OS_OPT_DEL_NO_PEND           Deletes the event flag group ONLY if no task pending
    135          *                            OS_OPT_DEL_ALWAYS            Deletes the event flag group even if tasks are waiting.
    136          *                                                         In this case, all the tasks pending will be readied.
    137          *
    138          *              p_err     is a pointer to an error code that can contain one of the following values:
    139          *
    140          *                            OS_ERR_NONE                  The call was successful and the event flag group was deleted
    141          *                            OS_ERR_DEL_ISR               If you attempted to delete the event flag group from an ISR
    142          *                            OS_ERR_OBJ_PTR_NULL          If 'p_grp' is a NULL pointer.
    143          *                            OS_ERR_OBJ_TYPE              If you didn't pass a pointer to an event flag group
    144          *                            OS_ERR_OPT_INVALID           An invalid option was specified
    145          *                            OS_ERR_TASK_WAITING          One or more tasks were waiting on the event flag group.
    146          *
    147          * Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
    148          *              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
    149          *
    150          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the event flag
    151          *                 group MUST check the return code of OSFlagPost and OSFlagPend().
    152          ************************************************************************************************************************
    153          */
    154          
    155          #if OS_CFG_FLAG_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    156          OS_OBJ_QTY  OSFlagDel (OS_FLAG_GRP  *p_grp,
    157                                 OS_OPT        opt,
    158                                 OS_ERR       *p_err)
    159          {
   \                     OSFlagDel: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    160              OS_OBJ_QTY        cnt;
    161              OS_OBJ_QTY        nbr_tasks;
    162              OS_PEND_DATA     *p_pend_data;
    163              OS_PEND_LIST     *p_pend_list;
    164              OS_TCB           *p_tcb;
    165              CPU_TS            ts;
    166              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    167          
    168          
    169          
    170          #ifdef OS_SAFETY_CRITICAL
    171              if (p_err == (OS_ERR *)0) {
    172                  OS_SAFETY_CRITICAL_EXCEPTION();
    173                  return ((OS_OBJ_QTY)0);
    174              }
    175          #endif
    176          
    177          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    178              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSFlagDel_0
    179                 *p_err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR                           */
   \   0000001A   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    180                  return ((OS_OBJ_QTY)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE11C             B.N      ??OSFlagDel_1
    181              }
    182          #endif
    183          
    184          #if OS_CFG_ARG_CHK_EN > 0u
    185              if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
   \                     ??OSFlagDel_0: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD104             BNE.N    ??OSFlagDel_2
    186                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
    187                  return ((OS_OBJ_QTY)0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE115             B.N      ??OSFlagDel_1
    188              }
    189              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSFlagDel_2: (+1)
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD805             BHI.N    ??OSFlagDel_3
    190                  case OS_OPT_DEL_NO_PEND:
    191                  case OS_OPT_DEL_ALWAYS:
    192                       break;
    193          
    194                  default:
    195                      *p_err = OS_ERR_OPT_INVALID;
    196                       return ((OS_OBJ_QTY)0);
    197              }
    198          #endif
    199          
    200          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    201              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate event group object                            */
   \                     ??OSFlagDel_4: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x47414c46
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD105             BNE.N    ??OSFlagDel_5
   \   00000046   0xE009             B.N      ??OSFlagDel_6
   \                     ??OSFlagDel_3: (+1)
   \   00000048   0xF645 0x6025      MOVW     R0,#+24101
   \   0000004C   0x8030             STRH     R0,[R6, #+0]
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE105             B.N      ??OSFlagDel_1
    202                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSFlagDel_5: (+1)
   \   00000052   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    203                  return ((OS_OBJ_QTY)0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE100             B.N      ??OSFlagDel_1
    204              }
    205          #endif
    206              OS_CRITICAL_ENTER();
   \                     ??OSFlagDel_6: (+1)
   \   0000005C   0x.... 0x....      BL       CPU_SR_Save
   \   00000060   0x4683             MOV      R11,R0
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000072   0x7008             STRB     R0,[R1, #+0]
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD101             BNE.N    ??OSFlagDel_7
   \   0000007E   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagDel_7: (+1)
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000086   0x4658             MOV      R0,R11
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
    207              p_pend_list = &p_grp->PendList;
   \   0000008C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000090   0x4681             MOV      R9,R0
    208              cnt         = p_pend_list->NbrEntries;
   \   00000092   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   00000096   0x0007             MOVS     R7,R0
    209              nbr_tasks   = cnt;
   \   00000098   0x46B8             MOV      R8,R7
    210              switch (opt) {
   \   0000009A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009C   0x2D00             CMP      R5,#+0
   \   0000009E   0xD002             BEQ.N    ??OSFlagDel_8
   \   000000A0   0x2D01             CMP      R5,#+1
   \   000000A2   0xD06F             BEQ.N    ??OSFlagDel_9
   \   000000A4   0xE0AB             B.N      ??OSFlagDel_10
    211                  case OS_OPT_DEL_NO_PEND:                            /* Delete group if no task waiting                        */
    212                       if (nbr_tasks == (OS_OBJ_QTY)0) {
   \                     ??OSFlagDel_8: (+1)
   \   000000A6   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000AA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AE   0xD13A             BNE.N    ??OSFlagDel_11
    213          #if OS_CFG_DBG_EN > 0u
    214                           OS_FlagDbgListRemove(p_grp);
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       OS_FlagDbgListRemove
    215          #endif
    216                           OSFlagQty--;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000000BA   0x8800             LDRH     R0,[R0, #+0]
   \   000000BC   0x1E40             SUBS     R0,R0,#+1
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000C2   0x8008             STRH     R0,[R1, #+0]
    217                           OS_FlagClr(p_grp);
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       OS_FlagClr
    218          
    219                           OS_CRITICAL_EXIT();
   \   000000CA   0x.... 0x....      BL       CPU_SR_Save
   \   000000CE   0x4683             MOV      R11,R0
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x1E40             SUBS     R0,R0,#+1
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD114             BNE.N    ??OSFlagDel_12
   \   000000EC   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   000000F4   0x8800             LDRH     R0,[R0, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD007             BEQ.N    ??OSFlagDel_13
   \   000000FA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FE   0x4658             MOV      R0,R11
   \   00000100   0x.... 0x....      BL       CPU_SR_Restore
   \   00000104   0x.... 0x....      BL       OS_Sched0
   \   00000108   0xE00A             B.N      ??OSFlagDel_14
   \                     ??OSFlagDel_13: (+1)
   \   0000010A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010E   0x4658             MOV      R0,R11
   \   00000110   0x.... 0x....      BL       CPU_SR_Restore
   \   00000114   0xE004             B.N      ??OSFlagDel_14
   \                     ??OSFlagDel_12: (+1)
   \   00000116   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000011A   0x4658             MOV      R0,R11
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
    220                          *p_err = OS_ERR_NONE;
   \                     ??OSFlagDel_14: (+1)
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x8030             STRH     R0,[R6, #+0]
   \   00000124   0xE02D             B.N      ??OSFlagDel_15
    221                       } else {
    222                           OS_CRITICAL_EXIT();
   \                     ??OSFlagDel_11: (+1)
   \   00000126   0x.... 0x....      BL       CPU_SR_Save
   \   0000012A   0x4683             MOV      R11,R0
   \   0000012C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x1E40             SUBS     R0,R0,#+1
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000013C   0x7008             STRB     R0,[R1, #+0]
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD114             BNE.N    ??OSFlagDel_16
   \   00000148   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000150   0x8800             LDRH     R0,[R0, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD007             BEQ.N    ??OSFlagDel_17
   \   00000156   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000015A   0x4658             MOV      R0,R11
   \   0000015C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000160   0x.... 0x....      BL       OS_Sched0
   \   00000164   0xE00A             B.N      ??OSFlagDel_18
   \                     ??OSFlagDel_17: (+1)
   \   00000166   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016A   0x4658             MOV      R0,R11
   \   0000016C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000170   0xE004             B.N      ??OSFlagDel_18
   \                     ??OSFlagDel_16: (+1)
   \   00000172   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000176   0x4658             MOV      R0,R11
   \   00000178   0x.... 0x....      BL       CPU_SR_Restore
    223                          *p_err = OS_ERR_TASK_WAITING;
   \                     ??OSFlagDel_18: (+1)
   \   0000017C   0xF247 0x105F      MOVW     R0,#+29023
   \   00000180   0x8030             STRH     R0,[R6, #+0]
    224                       }
    225                       break;
   \                     ??OSFlagDel_15: (+1)
   \   00000182   0xE06A             B.N      ??OSFlagDel_19
    226          
    227                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the event flag group                     */
    228                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
   \                     ??OSFlagDel_9: (+1)
   \   00000184   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000188   0x9000             STR      R0,[SP, #+0]
    229                       while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
   \                     ??OSFlagDel_20: (+1)
   \   0000018A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000018C   0x2F00             CMP      R7,#+0
   \   0000018E   0xD00C             BEQ.N    ??OSFlagDel_21
    230                           p_pend_data = p_pend_list->HeadPtr;
   \   00000190   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000194   0x9001             STR      R0,[SP, #+4]
    231                           p_tcb       = p_pend_data->TCBPtr;
   \   00000196   0x9801             LDR      R0,[SP, #+4]
   \   00000198   0x6880             LDR      R0,[R0, #+8]
   \   0000019A   0x4682             MOV      R10,R0
    232                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_grp),
    233                                         p_tcb,
    234                                         ts);
   \   0000019C   0x9A00             LDR      R2,[SP, #+0]
   \   0000019E   0x4651             MOV      R1,R10
   \   000001A0   0x0020             MOVS     R0,R4
   \   000001A2   0x.... 0x....      BL       OS_PendObjDel
    235                           cnt--;
   \   000001A6   0x1E7F             SUBS     R7,R7,#+1
   \   000001A8   0xE7EF             B.N      ??OSFlagDel_20
    236                       }
    237          #if OS_CFG_DBG_EN > 0u
    238                       OS_FlagDbgListRemove(p_grp);
   \                     ??OSFlagDel_21: (+1)
   \   000001AA   0x0020             MOVS     R0,R4
   \   000001AC   0x.... 0x....      BL       OS_FlagDbgListRemove
    239          #endif
    240                       OSFlagQty--;
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   000001B4   0x8800             LDRH     R0,[R0, #+0]
   \   000001B6   0x1E40             SUBS     R0,R0,#+1
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000001BC   0x8008             STRH     R0,[R1, #+0]
    241                       OS_FlagClr(p_grp);
   \   000001BE   0x0020             MOVS     R0,R4
   \   000001C0   0x.... 0x....      BL       OS_FlagClr
    242                       OS_CRITICAL_EXIT_NO_SCHED();
   \   000001C4   0x.... 0x....      BL       CPU_SR_Save
   \   000001C8   0x4683             MOV      R11,R0
   \   000001CA   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000001D2   0x7800             LDRB     R0,[R0, #+0]
   \   000001D4   0x1E40             SUBS     R0,R0,#+1
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000001DA   0x7008             STRB     R0,[R1, #+0]
   \   000001DC   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000001E0   0x7800             LDRB     R0,[R0, #+0]
   \   000001E2   0x2800             CMP      R0,#+0
   \   000001E4   0xD101             BNE.N    ??OSFlagDel_22
   \   000001E6   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagDel_22: (+1)
   \   000001EA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001EE   0x4658             MOV      R0,R11
   \   000001F0   0x.... 0x....      BL       CPU_SR_Restore
    243                       OSSched();                                     /* Find highest priority task ready to run                */
   \   000001F4   0x.... 0x....      BL       OSSched
    244                      *p_err = OS_ERR_NONE;
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x8030             STRH     R0,[R6, #+0]
    245                       break;
   \   000001FC   0xE02D             B.N      ??OSFlagDel_19
    246          
    247                  default:
    248                       OS_CRITICAL_EXIT();
   \                     ??OSFlagDel_10: (+1)
   \   000001FE   0x.... 0x....      BL       CPU_SR_Save
   \   00000202   0x4683             MOV      R11,R0
   \   00000204   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000020C   0x7800             LDRB     R0,[R0, #+0]
   \   0000020E   0x1E40             SUBS     R0,R0,#+1
   \   00000210   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000214   0x7008             STRB     R0,[R1, #+0]
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000021A   0x7800             LDRB     R0,[R0, #+0]
   \   0000021C   0x2800             CMP      R0,#+0
   \   0000021E   0xD114             BNE.N    ??OSFlagDel_23
   \   00000220   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000224   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000228   0x8800             LDRH     R0,[R0, #+0]
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD007             BEQ.N    ??OSFlagDel_24
   \   0000022E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000232   0x4658             MOV      R0,R11
   \   00000234   0x.... 0x....      BL       CPU_SR_Restore
   \   00000238   0x.... 0x....      BL       OS_Sched0
   \   0000023C   0xE00A             B.N      ??OSFlagDel_25
   \                     ??OSFlagDel_24: (+1)
   \   0000023E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000242   0x4658             MOV      R0,R11
   \   00000244   0x.... 0x....      BL       CPU_SR_Restore
   \   00000248   0xE004             B.N      ??OSFlagDel_25
   \                     ??OSFlagDel_23: (+1)
   \   0000024A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000024E   0x4658             MOV      R0,R11
   \   00000250   0x.... 0x....      BL       CPU_SR_Restore
    249                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSFlagDel_25: (+1)
   \   00000254   0xF645 0x6025      MOVW     R0,#+24101
   \   00000258   0x8030             STRH     R0,[R6, #+0]
    250                       break;
    251              }
    252              return (nbr_tasks);
   \                     ??OSFlagDel_19: (+1)
   \   0000025A   0x4640             MOV      R0,R8
   \   0000025C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagDel_1: (+1)
   \   0000025E   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    253          }
    254          #endif
    255          
    256          /*
    257          ************************************************************************************************************************
    258          *                                             WAIT ON AN EVENT FLAG GROUP
    259          *
    260          * Description: This function is called to wait for a combination of bits to be set in an event flag group.  Your
    261          *              application can wait for ANY bit to be set or ALL bits to be set.
    262          *
    263          * Arguments  : p_grp         is a pointer to the desired event flag group.
    264          *
    265          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    266          *                            The bits you want are specified by setting the corresponding bits in 'flags'.
    267          *                            e.g. if your application wants to wait for bits 0 and 1 then 'flags' would contain 0x03.
    268          *
    269          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    270          *                            desired bit combination.  If you specify 0, however, your task will wait
    271          *                            forever at the specified event flag group or, until a message arrives.
    272          *
    273          *              opt           specifies whether you want ALL bits to be set or ANY of the bits to be set.
    274          *                            You can specify the 'ONE' of the following arguments:
    275          *
    276          *                                OS_OPT_PEND_FLAG_CLR_ALL   You will wait for ALL bits in 'flags' to be clear (0)
    277          *                                OS_OPT_PEND_FLAG_CLR_ANY   You will wait for ANY bit  in 'flags' to be clear (0)
    278          *                                OS_OPT_PEND_FLAG_SET_ALL   You will wait for ALL bits in 'flags' to be set   (1)
    279          *                                OS_OPT_PEND_FLAG_SET_ANY   You will wait for ANY bit  in 'flags' to be set   (1)
    280          *
    281          *                            You can 'ADD' OS_OPT_PEND_FLAG_CONSUME if you want the event flag to be 'consumed' by
    282          *                                      the call.  Example, to wait for any flag in a group AND then clear
    283          *                                      the flags that are present, set 'wait_opt' to:
    284          *
    285          *                                      OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME
    286          *
    287          *                            You can also 'ADD' the type of pend with 'ONE' of the two option:
    288          *
    289          *                                OS_OPT_PEND_NON_BLOCKING   Task will NOT block if flags are not available
    290          *                                OS_OPT_PEND_BLOCKING       Task will     block if flags are not available
    291          *
    292          *              p_ts          is a pointer to a variable that will receive the timestamp of when the event flag group was
    293          *                            posted, aborted or the event flag group deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0)
    294          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid and
    295          *                            indicates that you don't need the timestamp.
    296          *
    297          *              p_err         is a pointer to an error code and can be:
    298          *
    299          *                                OS_ERR_NONE                The desired bits have been set within the specified 'timeout'
    300          *                                OS_ERR_OBJ_PTR_NULL        If 'p_grp' is a NULL pointer.
    301          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
    302          *                                OS_ERR_OPT_INVALID         You didn't specify a proper 'opt' argument.
    303          *                                OS_ERR_PEND_ABORT          The wait on the flag was aborted.
    304          *                                OS_ERR_PEND_ISR            If you tried to PEND from an ISR
    305          *                                OS_ERR_PEND_WOULD_BLOCK    If you specified non-blocking but the flags were not
    306          *                                                           available.
    307          *                                OS_ERR_SCHED_LOCKED        If you called this function when the scheduler is locked
    308          *                                OS_ERR_TIMEOUT             The bit(s) have not been set in the specified 'timeout'.
    309          *
    310          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    311          *              occurred.
    312          ************************************************************************************************************************
    313          */
    314          

   \                                 In section .text, align 2, keep-with-next
    315          OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
    316                                OS_FLAGS      flags,
    317                                OS_TICK       timeout,
    318                                OS_OPT        opt,
    319                                CPU_TS       *p_ts,
    320                                OS_ERR       *p_err)
    321          {
   \                     OSFlagPend: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8050      LDR      R8,[SP, #+80]
   \   00000012   0xF8DD 0x9054      LDR      R9,[SP, #+84]
    322              CPU_BOOLEAN   consume;
    323              OS_FLAGS      flags_rdy;
    324              OS_OPT        mode;
    325              OS_PEND_DATA  pend_data;
    326              CPU_SR_ALLOC();
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
    327          
    328          
    329          
    330          #ifdef OS_SAFETY_CRITICAL
    331              if (p_err == (OS_ERR *)0) {
    332                  OS_SAFETY_CRITICAL_EXCEPTION();
    333                  return ((OS_FLAGS)0);
    334              }
    335          #endif
    336          
    337          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    338              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD005             BEQ.N    ??OSFlagPend_0
    339                 *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                             */
   \   00000024   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000028   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    340                  return ((OS_FLAGS)0);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE2D1             B.N      ??OSFlagPend_1
    341              }
    342          #endif
    343          
    344          #if OS_CFG_ARG_CHK_EN > 0u
    345              if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
   \                     ??OSFlagPend_0: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD105             BNE.N    ??OSFlagPend_2
    346                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    347                  return ((OS_FLAGS)0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE2C9             B.N      ??OSFlagPend_1
    348              }
    349              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSFlagPend_2: (+1)
   \   00000040   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD91A             BLS.N    ??OSFlagPend_3
   \   0000004A   0x1EC0             SUBS     R0,R0,#+3
   \   0000004C   0xD018             BEQ.N    ??OSFlagPend_3
   \   0000004E   0x1F00             SUBS     R0,R0,#+4
   \   00000050   0xD016             BEQ.N    ??OSFlagPend_3
   \   00000052   0x38F9             SUBS     R0,R0,#+249
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD913             BLS.N    ??OSFlagPend_3
   \   00000058   0x1EC0             SUBS     R0,R0,#+3
   \   0000005A   0xD011             BEQ.N    ??OSFlagPend_3
   \   0000005C   0x1F00             SUBS     R0,R0,#+4
   \   0000005E   0xD00F             BEQ.N    ??OSFlagPend_3
   \   00000060   0xF647 0x61F9      MOVW     R1,#+32505
   \   00000064   0x1A40             SUBS     R0,R0,R1
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD90A             BLS.N    ??OSFlagPend_3
   \   0000006A   0x1EC0             SUBS     R0,R0,#+3
   \   0000006C   0xD008             BEQ.N    ??OSFlagPend_3
   \   0000006E   0x1F00             SUBS     R0,R0,#+4
   \   00000070   0xD006             BEQ.N    ??OSFlagPend_3
   \   00000072   0x38F9             SUBS     R0,R0,#+249
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD903             BLS.N    ??OSFlagPend_3
   \   00000078   0x1EC0             SUBS     R0,R0,#+3
   \   0000007A   0xD001             BEQ.N    ??OSFlagPend_3
   \   0000007C   0x1F00             SUBS     R0,R0,#+4
   \   0000007E   0xD105             BNE.N    ??OSFlagPend_4
    350                  case OS_OPT_PEND_FLAG_CLR_ALL:
    351                  case OS_OPT_PEND_FLAG_CLR_ANY:
    352                  case OS_OPT_PEND_FLAG_SET_ALL:
    353                  case OS_OPT_PEND_FLAG_SET_ANY:
    354                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
    355                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
    356                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
    357                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
    358                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
    359                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
    360                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
    361                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
    362                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    363                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    364                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    365                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
    366                       break;
    367          
    368                  default:
    369                      *p_err = OS_ERR_OPT_INVALID;
    370                       return ((OS_OBJ_QTY)0);
    371              }
    372          #endif
    373          
    374          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    375              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate that we are pointing at an event flag         */
   \                     ??OSFlagPend_3: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x47414c46
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD106             BNE.N    ??OSFlagPend_5
   \   0000008A   0xE00B             B.N      ??OSFlagPend_6
   \                     ??OSFlagPend_4: (+1)
   \   0000008C   0xF645 0x6025      MOVW     R0,#+24101
   \   00000090   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE29D             B.N      ??OSFlagPend_1
    376                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSFlagPend_5: (+1)
   \   00000098   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000009C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    377                  return ((OS_FLAGS)0);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE297             B.N      ??OSFlagPend_1
    378              }
    379          #endif
    380          
    381              if ((opt & OS_OPT_PEND_FLAG_CONSUME) != (OS_OPT)0) {    /* See if we need to consume the flags                    */
   \                     ??OSFlagPend_6: (+1)
   \   000000A4   0x05F8             LSLS     R0,R7,#+23
   \   000000A6   0xD503             BPL.N    ??OSFlagPend_7
    382                  consume = DEF_TRUE;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   000000AE   0xE002             B.N      ??OSFlagPend_8
    383              } else {
    384                  consume = DEF_FALSE;
   \                     ??OSFlagPend_7: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF88D 0x0004      STRB     R0,[SP, #+4]
    385              }
    386          
    387              if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_8: (+1)
   \   000000B6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000BA   0xD002             BEQ.N    ??OSFlagPend_9
    388                 *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF8C8 0x0000      STR      R0,[R8, #+0]
    389              }
    390          
    391              mode = opt & OS_OPT_PEND_FLAG_MASK;
   \                     ??OSFlagPend_9: (+1)
   \   000000C2   0xF017 0x000F      ANDS     R0,R7,#0xF
   \   000000C6   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    392              CPU_CRITICAL_ENTER();
   \   000000CA   0x.... 0x....      BL       CPU_SR_Save
   \   000000CE   0x4683             MOV      R11,R0
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStart
    393              switch (mode) {
   \   000000D4   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xF000 0x80EF      BEQ.W    ??OSFlagPend_10
   \   000000DE   0x2802             CMP      R0,#+2
   \   000000E0   0xF000 0x8160      BEQ.W    ??OSFlagPend_11
   \   000000E4   0x2804             CMP      R0,#+4
   \   000000E6   0xD002             BEQ.N    ??OSFlagPend_12
   \   000000E8   0x2808             CMP      R0,#+8
   \   000000EA   0xD073             BEQ.N    ??OSFlagPend_13
   \   000000EC   0xE1CF             B.N      ??OSFlagPend_14
    394                  case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
    395                       flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
   \                     ??OSFlagPend_12: (+1)
   \   000000EE   0x6A20             LDR      R0,[R4, #+32]
   \   000000F0   0x4028             ANDS     R0,R5,R0
   \   000000F2   0x4682             MOV      R10,R0
    396                       if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
   \   000000F4   0x45AA             CMP      R10,R5
   \   000000F6   0xD11C             BNE.N    ??OSFlagPend_15
    397                           if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
   \   000000F8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD103             BNE.N    ??OSFlagPend_16
    398                               p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
   \   00000100   0x6A20             LDR      R0,[R4, #+32]
   \   00000102   0xEA30 0x000A      BICS     R0,R0,R10
   \   00000106   0x6220             STR      R0,[R4, #+32]
    399                           }
    400                           OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
   \                     ??OSFlagPend_16: (+1)
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF8C0 0xA084      STR      R10,[R0, #+132]
    401                           if (p_ts != (CPU_TS *)0) {
   \   00000112   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000116   0xD002             BEQ.N    ??OSFlagPend_17
    402                              *p_ts  = p_grp->TS;
   \   00000118   0x6A60             LDR      R0,[R4, #+36]
   \   0000011A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    403                           }
    404                           CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
   \                     ??OSFlagPend_17: (+1)
   \   0000011E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000122   0x4658             MOV      R0,R11
   \   00000124   0x.... 0x....      BL       CPU_SR_Restore
    405                          *p_err = OS_ERR_NONE;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    406                           return (flags_rdy);
   \   0000012E   0x4650             MOV      R0,R10
   \   00000130   0xE250             B.N      ??OSFlagPend_1
    407                       } else {                                       /* Block task until events occur or timeout               */
    408                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
   \                     ??OSFlagPend_15: (+1)
   \   00000132   0x0438             LSLS     R0,R7,#+16
   \   00000134   0xD50A             BPL.N    ??OSFlagPend_18
    409                               CPU_CRITICAL_EXIT();
   \   00000136   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000013A   0x4658             MOV      R0,R11
   \   0000013C   0x.... 0x....      BL       CPU_SR_Restore
    410                              *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
   \   00000140   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000144   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    411                               return ((OS_FLAGS)0);
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0xE243             B.N      ??OSFlagPend_1
    412                           } else {                                   /* Specified blocking so check is scheduler is locked     */
    413                               if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
   \                     ??OSFlagPend_18: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD00A             BEQ.N    ??OSFlagPend_19
    414                                   CPU_CRITICAL_EXIT();
   \   00000156   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000015A   0x4658             MOV      R0,R11
   \   0000015C   0x.... 0x....      BL       CPU_SR_Restore
    415                                  *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
   \   00000160   0xF646 0x5063      MOVW     R0,#+28003
   \   00000164   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    416                                   return ((OS_FLAGS)0);
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0xE233             B.N      ??OSFlagPend_1
    417                               }
    418                           }
    419                                                                      /* Lock the scheduler/re-enable interrupts                */
    420                           OS_CRITICAL_ENTER_CPU_EXIT();              
   \                     ??OSFlagPend_19: (+1)
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0x1C40             ADDS     R0,R0,#+1
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000178   0x7008             STRB     R0,[R1, #+0]
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000017E   0x7800             LDRB     R0,[R0, #+0]
   \   00000180   0x2801             CMP      R0,#+1
   \   00000182   0xD101             BNE.N    ??OSFlagPend_20
   \   00000184   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagPend_20: (+1)
   \   00000188   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000018C   0x4658             MOV      R0,R11
   \   0000018E   0x.... 0x....      BL       CPU_SR_Restore
    421                           OS_FlagBlock(&pend_data,
    422                                        p_grp,
    423                                        flags,
    424                                        opt,
    425                                        timeout);
   \   00000192   0x9600             STR      R6,[SP, #+0]
   \   00000194   0x003B             MOVS     R3,R7
   \   00000196   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000198   0x002A             MOVS     R2,R5
   \   0000019A   0x0021             MOVS     R1,R4
   \   0000019C   0xA802             ADD      R0,SP,#+8
   \   0000019E   0x.... 0x....      BL       OS_FlagBlock
    426                           OS_CRITICAL_EXIT_NO_SCHED();
   \   000001A2   0x.... 0x....      BL       CPU_SR_Save
   \   000001A6   0x4683             MOV      R11,R0
   \   000001A8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0x1E40             SUBS     R0,R0,#+1
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000001B8   0x7008             STRB     R0,[R1, #+0]
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000001BE   0x7800             LDRB     R0,[R0, #+0]
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xD101             BNE.N    ??OSFlagPend_21
   \   000001C4   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagPend_21: (+1)
   \   000001C8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001CC   0x4658             MOV      R0,R11
   \   000001CE   0x.... 0x....      BL       CPU_SR_Restore
    427                       }
    428                       break;
   \   000001D2   0xE167             B.N      ??OSFlagPend_22
    429          
    430                  case OS_OPT_PEND_FLAG_SET_ANY:
    431                       flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
   \                     ??OSFlagPend_13: (+1)
   \   000001D4   0x6A20             LDR      R0,[R4, #+32]
   \   000001D6   0x4028             ANDS     R0,R5,R0
   \   000001D8   0x4682             MOV      R10,R0
    432                       if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
   \   000001DA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001DE   0xD01C             BEQ.N    ??OSFlagPend_23
    433                           if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
   \   000001E0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001E4   0x2801             CMP      R0,#+1
   \   000001E6   0xD103             BNE.N    ??OSFlagPend_24
    434                               p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
   \   000001E8   0x6A20             LDR      R0,[R4, #+32]
   \   000001EA   0xEA30 0x000A      BICS     R0,R0,R10
   \   000001EE   0x6220             STR      R0,[R4, #+32]
    435                           }
    436                           OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
   \                     ??OSFlagPend_24: (+1)
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000001F4   0x6800             LDR      R0,[R0, #+0]
   \   000001F6   0xF8C0 0xA084      STR      R10,[R0, #+132]
    437                           if (p_ts != (CPU_TS *)0) {
   \   000001FA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001FE   0xD002             BEQ.N    ??OSFlagPend_25
    438                              *p_ts  = p_grp->TS;
   \   00000200   0x6A60             LDR      R0,[R4, #+36]
   \   00000202   0xF8C8 0x0000      STR      R0,[R8, #+0]
    439                           }
    440                           CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
   \                     ??OSFlagPend_25: (+1)
   \   00000206   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000020A   0x4658             MOV      R0,R11
   \   0000020C   0x.... 0x....      BL       CPU_SR_Restore
    441                          *p_err = OS_ERR_NONE;
   \   00000210   0x2000             MOVS     R0,#+0
   \   00000212   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    442                           return (flags_rdy);
   \   00000216   0x4650             MOV      R0,R10
   \   00000218   0xE1DC             B.N      ??OSFlagPend_1
    443                       } else {                                       /* Block task until events occur or timeout               */
    444                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
   \                     ??OSFlagPend_23: (+1)
   \   0000021A   0x0438             LSLS     R0,R7,#+16
   \   0000021C   0xD50A             BPL.N    ??OSFlagPend_26
    445                               CPU_CRITICAL_EXIT();
   \   0000021E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000222   0x4658             MOV      R0,R11
   \   00000224   0x.... 0x....      BL       CPU_SR_Restore
    446                              *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
   \   00000228   0xF246 0x10B0      MOVW     R0,#+25008
   \   0000022C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    447                               return ((OS_FLAGS)0);
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0xE1CF             B.N      ??OSFlagPend_1
    448                           } else {                                   /* Specified blocking so check is scheduler is locked     */
    449                               if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
   \                     ??OSFlagPend_26: (+1)
   \   00000234   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000238   0x7800             LDRB     R0,[R0, #+0]
   \   0000023A   0x2800             CMP      R0,#+0
   \   0000023C   0xD00A             BEQ.N    ??OSFlagPend_27
    450                                   CPU_CRITICAL_EXIT();
   \   0000023E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000242   0x4658             MOV      R0,R11
   \   00000244   0x.... 0x....      BL       CPU_SR_Restore
    451                                  *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
   \   00000248   0xF646 0x5063      MOVW     R0,#+28003
   \   0000024C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    452                                   return ((OS_FLAGS)0);
   \   00000250   0x2000             MOVS     R0,#+0
   \   00000252   0xE1BF             B.N      ??OSFlagPend_1
    453                               }
    454                           }
    455                                                                      /* Lock the scheduler/re-enable interrupts                */
    456                           OS_CRITICAL_ENTER_CPU_EXIT();              
   \                     ??OSFlagPend_27: (+1)
   \   00000254   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000258   0x7800             LDRB     R0,[R0, #+0]
   \   0000025A   0x1C40             ADDS     R0,R0,#+1
   \   0000025C   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000260   0x7008             STRB     R0,[R1, #+0]
   \   00000262   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000266   0x7800             LDRB     R0,[R0, #+0]
   \   00000268   0x2801             CMP      R0,#+1
   \   0000026A   0xD101             BNE.N    ??OSFlagPend_28
   \   0000026C   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagPend_28: (+1)
   \   00000270   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000274   0x4658             MOV      R0,R11
   \   00000276   0x.... 0x....      BL       CPU_SR_Restore
    457                           OS_FlagBlock(&pend_data,
    458                                        p_grp,
    459                                        flags,
    460                                        opt,
    461                                        timeout);
   \   0000027A   0x9600             STR      R6,[SP, #+0]
   \   0000027C   0x003B             MOVS     R3,R7
   \   0000027E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000280   0x002A             MOVS     R2,R5
   \   00000282   0x0021             MOVS     R1,R4
   \   00000284   0xA802             ADD      R0,SP,#+8
   \   00000286   0x.... 0x....      BL       OS_FlagBlock
    462                           OS_CRITICAL_EXIT_NO_SCHED();
   \   0000028A   0x.... 0x....      BL       CPU_SR_Save
   \   0000028E   0x4683             MOV      R11,R0
   \   00000290   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000298   0x7800             LDRB     R0,[R0, #+0]
   \   0000029A   0x1E40             SUBS     R0,R0,#+1
   \   0000029C   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   000002A0   0x7008             STRB     R0,[R1, #+0]
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   000002A6   0x7800             LDRB     R0,[R0, #+0]
   \   000002A8   0x2800             CMP      R0,#+0
   \   000002AA   0xD101             BNE.N    ??OSFlagPend_29
   \   000002AC   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagPend_29: (+1)
   \   000002B0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002B4   0x4658             MOV      R0,R11
   \   000002B6   0x.... 0x....      BL       CPU_SR_Restore
    463                       }
    464                       break;
   \   000002BA   0xE0F3             B.N      ??OSFlagPend_22
    465          
    466          #if OS_CFG_FLAG_MODE_CLR_EN > 0u
    467                  case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all required flags are cleared                  */
    468                       flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
   \                     ??OSFlagPend_10: (+1)
   \   000002BC   0x6A20             LDR      R0,[R4, #+32]
   \   000002BE   0xEA35 0x0000      BICS     R0,R5,R0
   \   000002C2   0x4682             MOV      R10,R0
    469                       if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
   \   000002C4   0x45AA             CMP      R10,R5
   \   000002C6   0xD11C             BNE.N    ??OSFlagPend_30
    470                           if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
   \   000002C8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000002CC   0x2801             CMP      R0,#+1
   \   000002CE   0xD103             BNE.N    ??OSFlagPend_31
    471                               p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we wanted                      */
   \   000002D0   0x6A20             LDR      R0,[R4, #+32]
   \   000002D2   0xEA5A 0x0000      ORRS     R0,R10,R0
   \   000002D6   0x6220             STR      R0,[R4, #+32]
    472                           }
    473                           OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
   \                     ??OSFlagPend_31: (+1)
   \   000002D8   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000002DC   0x6800             LDR      R0,[R0, #+0]
   \   000002DE   0xF8C0 0xA084      STR      R10,[R0, #+132]
    474                           if (p_ts != (CPU_TS *)0) {
   \   000002E2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000002E6   0xD002             BEQ.N    ??OSFlagPend_32
    475                              *p_ts  = p_grp->TS;
   \   000002E8   0x6A60             LDR      R0,[R4, #+36]
   \   000002EA   0xF8C8 0x0000      STR      R0,[R8, #+0]
    476                           }
    477                           CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
   \                     ??OSFlagPend_32: (+1)
   \   000002EE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002F2   0x4658             MOV      R0,R11
   \   000002F4   0x.... 0x....      BL       CPU_SR_Restore
    478                          *p_err = OS_ERR_NONE;
   \   000002F8   0x2000             MOVS     R0,#+0
   \   000002FA   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    479                           return (flags_rdy);
   \   000002FE   0x4650             MOV      R0,R10
   \   00000300   0xE168             B.N      ??OSFlagPend_1
    480                       } else {                                       /* Block task until events occur or timeout               */
    481                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
   \                     ??OSFlagPend_30: (+1)
   \   00000302   0x0438             LSLS     R0,R7,#+16
   \   00000304   0xD50A             BPL.N    ??OSFlagPend_33
    482                               CPU_CRITICAL_EXIT();
   \   00000306   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000030A   0x4658             MOV      R0,R11
   \   0000030C   0x.... 0x....      BL       CPU_SR_Restore
    483                              *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
   \   00000310   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000314   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    484                               return ((OS_FLAGS)0);
   \   00000318   0x2000             MOVS     R0,#+0
   \   0000031A   0xE15B             B.N      ??OSFlagPend_1
    485                           } else {                                   /* Specified blocking so check is scheduler is locked     */
    486                               if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
   \                     ??OSFlagPend_33: (+1)
   \   0000031C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000320   0x7800             LDRB     R0,[R0, #+0]
   \   00000322   0x2800             CMP      R0,#+0
   \   00000324   0xD00A             BEQ.N    ??OSFlagPend_34
    487                                   CPU_CRITICAL_EXIT();
   \   00000326   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000032A   0x4658             MOV      R0,R11
   \   0000032C   0x.... 0x....      BL       CPU_SR_Restore
    488                                  *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
   \   00000330   0xF646 0x5063      MOVW     R0,#+28003
   \   00000334   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    489                                   return ((OS_FLAGS)0);
   \   00000338   0x2000             MOVS     R0,#+0
   \   0000033A   0xE14B             B.N      ??OSFlagPend_1
    490                               }
    491                           }
    492                                                                      
    493                           OS_CRITICAL_ENTER_CPU_EXIT();              /* Lock the scheduler/re-enable interrupts                */
   \                     ??OSFlagPend_34: (+1)
   \   0000033C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000340   0x7800             LDRB     R0,[R0, #+0]
   \   00000342   0x1C40             ADDS     R0,R0,#+1
   \   00000344   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000348   0x7008             STRB     R0,[R1, #+0]
   \   0000034A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000034E   0x7800             LDRB     R0,[R0, #+0]
   \   00000350   0x2801             CMP      R0,#+1
   \   00000352   0xD101             BNE.N    ??OSFlagPend_35
   \   00000354   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagPend_35: (+1)
   \   00000358   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000035C   0x4658             MOV      R0,R11
   \   0000035E   0x.... 0x....      BL       CPU_SR_Restore
    494                           OS_FlagBlock(&pend_data,
    495                                        p_grp,
    496                                        flags,
    497                                        opt,
    498                                        timeout);
   \   00000362   0x9600             STR      R6,[SP, #+0]
   \   00000364   0x003B             MOVS     R3,R7
   \   00000366   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000368   0x002A             MOVS     R2,R5
   \   0000036A   0x0021             MOVS     R1,R4
   \   0000036C   0xA802             ADD      R0,SP,#+8
   \   0000036E   0x.... 0x....      BL       OS_FlagBlock
    499                           OS_CRITICAL_EXIT_NO_SCHED();
   \   00000372   0x.... 0x....      BL       CPU_SR_Save
   \   00000376   0x4683             MOV      R11,R0
   \   00000378   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000037C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000380   0x7800             LDRB     R0,[R0, #+0]
   \   00000382   0x1E40             SUBS     R0,R0,#+1
   \   00000384   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000388   0x7008             STRB     R0,[R1, #+0]
   \   0000038A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000038E   0x7800             LDRB     R0,[R0, #+0]
   \   00000390   0x2800             CMP      R0,#+0
   \   00000392   0xD101             BNE.N    ??OSFlagPend_36
   \   00000394   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagPend_36: (+1)
   \   00000398   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000039C   0x4658             MOV      R0,R11
   \   0000039E   0x.... 0x....      BL       CPU_SR_Restore
    500                       }
    501                       break;
   \   000003A2   0xE07F             B.N      ??OSFlagPend_22
    502          
    503                  case OS_OPT_PEND_FLAG_CLR_ANY:
    504                       flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
   \                     ??OSFlagPend_11: (+1)
   \   000003A4   0x6A20             LDR      R0,[R4, #+32]
   \   000003A6   0xEA35 0x0000      BICS     R0,R5,R0
   \   000003AA   0x4682             MOV      R10,R0
    505                       if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag cleared                                */
   \   000003AC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000003B0   0xD01C             BEQ.N    ??OSFlagPend_37
    506                           if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
   \   000003B2   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000003B6   0x2801             CMP      R0,#+1
   \   000003B8   0xD103             BNE.N    ??OSFlagPend_38
    507                               p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we got                         */
   \   000003BA   0x6A20             LDR      R0,[R4, #+32]
   \   000003BC   0xEA5A 0x0000      ORRS     R0,R10,R0
   \   000003C0   0x6220             STR      R0,[R4, #+32]
    508                           }
    509                           OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
   \                     ??OSFlagPend_38: (+1)
   \   000003C2   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000003C6   0x6800             LDR      R0,[R0, #+0]
   \   000003C8   0xF8C0 0xA084      STR      R10,[R0, #+132]
    510                           if (p_ts != (CPU_TS *)0) {
   \   000003CC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000003D0   0xD002             BEQ.N    ??OSFlagPend_39
    511                              *p_ts  = p_grp->TS;
   \   000003D2   0x6A60             LDR      R0,[R4, #+36]
   \   000003D4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    512                           }
    513                           CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
   \                     ??OSFlagPend_39: (+1)
   \   000003D8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003DC   0x4658             MOV      R0,R11
   \   000003DE   0x.... 0x....      BL       CPU_SR_Restore
    514                          *p_err = OS_ERR_NONE;
   \   000003E2   0x2000             MOVS     R0,#+0
   \   000003E4   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    515                           return (flags_rdy);
   \   000003E8   0x4650             MOV      R0,R10
   \   000003EA   0xE0F3             B.N      ??OSFlagPend_1
    516                       } else {                                       /* Block task until events occur or timeout               */
    517                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
   \                     ??OSFlagPend_37: (+1)
   \   000003EC   0x0438             LSLS     R0,R7,#+16
   \   000003EE   0xD50A             BPL.N    ??OSFlagPend_40
    518                               CPU_CRITICAL_EXIT();
   \   000003F0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003F4   0x4658             MOV      R0,R11
   \   000003F6   0x.... 0x....      BL       CPU_SR_Restore
    519                              *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
   \   000003FA   0xF246 0x10B0      MOVW     R0,#+25008
   \   000003FE   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    520                               return ((OS_FLAGS)0);
   \   00000402   0x2000             MOVS     R0,#+0
   \   00000404   0xE0E6             B.N      ??OSFlagPend_1
    521                           } else {                                   /* Specified blocking so check is scheduler is locked     */
    522                               if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
   \                     ??OSFlagPend_40: (+1)
   \   00000406   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000040A   0x7800             LDRB     R0,[R0, #+0]
   \   0000040C   0x2800             CMP      R0,#+0
   \   0000040E   0xD00A             BEQ.N    ??OSFlagPend_41
    523                                   CPU_CRITICAL_EXIT();
   \   00000410   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000414   0x4658             MOV      R0,R11
   \   00000416   0x.... 0x....      BL       CPU_SR_Restore
    524                                  *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
   \   0000041A   0xF646 0x5063      MOVW     R0,#+28003
   \   0000041E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    525                                   return ((OS_FLAGS)0);
   \   00000422   0x2000             MOVS     R0,#+0
   \   00000424   0xE0D6             B.N      ??OSFlagPend_1
    526                               }
    527                           }
    528                                                                      
    529                           OS_CRITICAL_ENTER_CPU_EXIT();              /* Lock the scheduler/re-enable interrupts                */
   \                     ??OSFlagPend_41: (+1)
   \   00000426   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000042A   0x7800             LDRB     R0,[R0, #+0]
   \   0000042C   0x1C40             ADDS     R0,R0,#+1
   \   0000042E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000432   0x7008             STRB     R0,[R1, #+0]
   \   00000434   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000438   0x7800             LDRB     R0,[R0, #+0]
   \   0000043A   0x2801             CMP      R0,#+1
   \   0000043C   0xD101             BNE.N    ??OSFlagPend_42
   \   0000043E   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagPend_42: (+1)
   \   00000442   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000446   0x4658             MOV      R0,R11
   \   00000448   0x.... 0x....      BL       CPU_SR_Restore
    530                           OS_FlagBlock(&pend_data,              
    531                                        p_grp,
    532                                        flags,
    533                                        opt,
    534                                        timeout);
   \   0000044C   0x9600             STR      R6,[SP, #+0]
   \   0000044E   0x003B             MOVS     R3,R7
   \   00000450   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000452   0x002A             MOVS     R2,R5
   \   00000454   0x0021             MOVS     R1,R4
   \   00000456   0xA802             ADD      R0,SP,#+8
   \   00000458   0x.... 0x....      BL       OS_FlagBlock
    535                           OS_CRITICAL_EXIT_NO_SCHED();
   \   0000045C   0x.... 0x....      BL       CPU_SR_Save
   \   00000460   0x4683             MOV      R11,R0
   \   00000462   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000466   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000046A   0x7800             LDRB     R0,[R0, #+0]
   \   0000046C   0x1E40             SUBS     R0,R0,#+1
   \   0000046E   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000472   0x7008             STRB     R0,[R1, #+0]
   \   00000474   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000478   0x7800             LDRB     R0,[R0, #+0]
   \   0000047A   0x2800             CMP      R0,#+0
   \   0000047C   0xD101             BNE.N    ??OSFlagPend_43
   \   0000047E   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagPend_43: (+1)
   \   00000482   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000486   0x4658             MOV      R0,R11
   \   00000488   0x.... 0x....      BL       CPU_SR_Restore
    536                       }
    537                       break;
   \   0000048C   0xE00A             B.N      ??OSFlagPend_22
    538          #endif
    539          
    540                  default:
    541                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_14: (+1)
   \   0000048E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000492   0x4658             MOV      R0,R11
   \   00000494   0x.... 0x....      BL       CPU_SR_Restore
    542                      *p_err = OS_ERR_OPT_INVALID;
   \   00000498   0xF645 0x6025      MOVW     R0,#+24101
   \   0000049C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    543                       return ((OS_FLAGS)0);
   \   000004A0   0x2000             MOVS     R0,#+0
   \   000004A2   0xE097             B.N      ??OSFlagPend_1
    544              }
    545          
    546              OSSched();                                              /* Find next HPT ready to run                             */
   \                     ??OSFlagPend_22: (+1)
   \   000004A4   0x.... 0x....      BL       OSSched
    547          
    548              CPU_CRITICAL_ENTER();
   \   000004A8   0x.... 0x....      BL       CPU_SR_Save
   \   000004AC   0x4683             MOV      R11,R0
   \   000004AE   0x.... 0x....      BL       CPU_IntDisMeasStart
    549              switch (OSTCBCurPtr->PendStatus) {
   \   000004B2   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000004B6   0x6800             LDR      R0,[R0, #+0]
   \   000004B8   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   000004BC   0x2800             CMP      R0,#+0
   \   000004BE   0xD005             BEQ.N    ??OSFlagPend_44
   \   000004C0   0x2802             CMP      R0,#+2
   \   000004C2   0xD033             BEQ.N    ??OSFlagPend_45
   \   000004C4   0xD30F             BCC.N    ??OSFlagPend_46
   \   000004C6   0x2803             CMP      R0,#+3
   \   000004C8   0xD020             BEQ.N    ??OSFlagPend_47
   \   000004CA   0xE042             B.N      ??OSFlagPend_48
    550                  case OS_STATUS_PEND_OK:                             /* We got the vent flags                                  */
    551                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_44: (+1)
   \   000004CC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000004D0   0xD005             BEQ.N    ??OSFlagPend_49
    552                          *p_ts  = OSTCBCurPtr->TS;
   \   000004D2   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000004D6   0x6800             LDR      R0,[R0, #+0]
   \   000004D8   0x6C00             LDR      R0,[R0, #+64]
   \   000004DA   0xF8C8 0x0000      STR      R0,[R8, #+0]
    553                       }
    554                      *p_err = OS_ERR_NONE;
   \                     ??OSFlagPend_49: (+1)
   \   000004DE   0x2000             MOVS     R0,#+0
   \   000004E0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    555                       break;
   \   000004E4   0xE03E             B.N      ??OSFlagPend_50
    556          
    557                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    558                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_46: (+1)
   \   000004E6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000004EA   0xD005             BEQ.N    ??OSFlagPend_51
    559                          *p_ts  = OSTCBCurPtr->TS;
   \   000004EC   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   000004F0   0x6800             LDR      R0,[R0, #+0]
   \   000004F2   0x6C00             LDR      R0,[R0, #+64]
   \   000004F4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    560                       }
    561                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_51: (+1)
   \   000004F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000004FC   0x4658             MOV      R0,R11
   \   000004FE   0x.... 0x....      BL       CPU_SR_Restore
    562                      *p_err = OS_ERR_PEND_ABORT;
   \   00000502   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000506   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    563                       break;
   \   0000050A   0xE02B             B.N      ??OSFlagPend_50
    564          
    565                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
    566                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_47: (+1)
   \   0000050C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000510   0xD002             BEQ.N    ??OSFlagPend_52
    567                          *p_ts  = (CPU_TS  )0;
   \   00000512   0x2000             MOVS     R0,#+0
   \   00000514   0xF8C8 0x0000      STR      R0,[R8, #+0]
    568                       }
    569                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_52: (+1)
   \   00000518   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000051C   0x4658             MOV      R0,R11
   \   0000051E   0x.... 0x....      BL       CPU_SR_Restore
    570                      *p_err = OS_ERR_TIMEOUT;
   \   00000522   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000526   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    571                       break;
   \   0000052A   0xE01B             B.N      ??OSFlagPend_50
    572          
    573                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    574                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_45: (+1)
   \   0000052C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000530   0xD005             BEQ.N    ??OSFlagPend_53
    575                          *p_ts  = OSTCBCurPtr->TS;
   \   00000532   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000536   0x6800             LDR      R0,[R0, #+0]
   \   00000538   0x6C00             LDR      R0,[R0, #+64]
   \   0000053A   0xF8C8 0x0000      STR      R0,[R8, #+0]
    576                       }
    577                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_53: (+1)
   \   0000053E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000542   0x4658             MOV      R0,R11
   \   00000544   0x.... 0x....      BL       CPU_SR_Restore
    578                      *p_err = OS_ERR_OBJ_DEL;
   \   00000548   0xF645 0x50C2      MOVW     R0,#+24002
   \   0000054C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    579                       break;
   \   00000550   0xE008             B.N      ??OSFlagPend_50
    580          
    581                  default:
    582                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_48: (+1)
   \   00000552   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000556   0x4658             MOV      R0,R11
   \   00000558   0x.... 0x....      BL       CPU_SR_Restore
    583                      *p_err = OS_ERR_STATUS_INVALID;
   \   0000055C   0xF646 0x602E      MOVW     R0,#+28206
   \   00000560   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    584                       break;
    585              }
    586              if (*p_err != OS_ERR_NONE) {
   \                     ??OSFlagPend_50: (+1)
   \   00000564   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   00000568   0x2800             CMP      R0,#+0
   \   0000056A   0xD001             BEQ.N    ??OSFlagPend_54
    587                  return ((OS_FLAGS)0);
   \   0000056C   0x2000             MOVS     R0,#+0
   \   0000056E   0xE031             B.N      ??OSFlagPend_1
    588              }
    589          
    590              flags_rdy = OSTCBCurPtr->FlagsRdy;
   \                     ??OSFlagPend_54: (+1)
   \   00000570   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000574   0x6800             LDR      R0,[R0, #+0]
   \   00000576   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000057A   0x4682             MOV      R10,R0
    591              if (consume == DEF_TRUE) {                              /* See if we need to consume the flags                    */
   \   0000057C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000580   0x2801             CMP      R0,#+1
   \   00000582   0xD11E             BNE.N    ??OSFlagPend_55
    592                  switch (mode) {
   \   00000584   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000588   0x2801             CMP      R0,#+1
   \   0000058A   0xD00A             BEQ.N    ??OSFlagPend_56
   \   0000058C   0x2802             CMP      R0,#+2
   \   0000058E   0xD008             BEQ.N    ??OSFlagPend_56
   \   00000590   0x2804             CMP      R0,#+4
   \   00000592   0xD001             BEQ.N    ??OSFlagPend_57
   \   00000594   0x2808             CMP      R0,#+8
   \   00000596   0xD109             BNE.N    ??OSFlagPend_58
    593                      case OS_OPT_PEND_FLAG_SET_ALL:
    594                      case OS_OPT_PEND_FLAG_SET_ANY:                  /* Clear ONLY the flags we got                            */
    595                           p_grp->Flags &= ~flags_rdy;
   \                     ??OSFlagPend_57: (+1)
   \   00000598   0x6A20             LDR      R0,[R4, #+32]
   \   0000059A   0xEA30 0x000A      BICS     R0,R0,R10
   \   0000059E   0x6220             STR      R0,[R4, #+32]
    596                           break;
   \   000005A0   0xE00F             B.N      ??OSFlagPend_55
    597          
    598          #if OS_CFG_FLAG_MODE_CLR_EN > 0u
    599                      case OS_OPT_PEND_FLAG_CLR_ALL:
    600                      case OS_OPT_PEND_FLAG_CLR_ANY:                  /* Set   ONLY the flags we got                            */
    601                           p_grp->Flags |=  flags_rdy;
   \                     ??OSFlagPend_56: (+1)
   \   000005A2   0x6A20             LDR      R0,[R4, #+32]
   \   000005A4   0xEA5A 0x0000      ORRS     R0,R10,R0
   \   000005A8   0x6220             STR      R0,[R4, #+32]
    602                           break;
   \   000005AA   0xE00A             B.N      ??OSFlagPend_55
    603          #endif
    604                      default:
    605                           CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_58: (+1)
   \   000005AC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000005B0   0x4658             MOV      R0,R11
   \   000005B2   0x.... 0x....      BL       CPU_SR_Restore
    606                          *p_err = OS_ERR_OPT_INVALID;
   \   000005B6   0xF645 0x6025      MOVW     R0,#+24101
   \   000005BA   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    607                           return ((OS_FLAGS)0);
   \   000005BE   0x2000             MOVS     R0,#+0
   \   000005C0   0xE008             B.N      ??OSFlagPend_1
    608                  }
    609              }
    610              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_55: (+1)
   \   000005C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000005C6   0x4658             MOV      R0,R11
   \   000005C8   0x.... 0x....      BL       CPU_SR_Restore
    611             *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
   \   000005CC   0x2000             MOVS     R0,#+0
   \   000005CE   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    612              return (flags_rdy);
   \   000005D2   0x4650             MOV      R0,R10
   \                     ??OSFlagPend_1: (+1)
   \   000005D4   0xB00B             ADD      SP,SP,#+44
   \   000005D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    613          }
    614          
    615          /*$PAGE*/
    616          /*
    617          ************************************************************************************************************************
    618          *                                          ABORT WAITING ON AN EVENT FLAG GROUP
    619          *
    620          * Description: This function aborts & readies any tasks currently waiting on an event flag group.  This function should
    621          *              be used to fault-abort the wait on the event flag group, rather than to normally post to the event flag
    622          *              group OSFlagPost().
    623          *
    624          * Arguments  : p_grp     is a pointer to the event flag group
    625          *
    626          *              opt       determines the type of ABORT performed:
    627          *
    628          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the event flag
    629          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the event flag
    630          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    631          *
    632          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    633          *
    634          *                            OS_ERR_NONE                  At least one task waiting on the event flag group and was
    635          *                                                         readied and informed of the aborted wait; check return value
    636          *                                                         for the number of tasks whose wait on the event flag group
    637          *                                                         was aborted.
    638          *                            OS_ERR_OBJ_PTR_NULL          If 'p_grp' is a NULL pointer.
    639          *                            OS_ERR_OBJ_TYPE              If 'p_grp' is not pointing at an event flag group
    640          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    641          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    642          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    643          *
    644          * Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
    645          *              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
    646          ************************************************************************************************************************
    647          */
    648          
    649          #if OS_CFG_FLAG_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    650          OS_OBJ_QTY  OSFlagPendAbort (OS_FLAG_GRP  *p_grp,
    651                                       OS_OPT        opt,
    652                                       OS_ERR       *p_err)
    653          {
   \                     OSFlagPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    654              OS_PEND_LIST  *p_pend_list;
    655              OS_TCB        *p_tcb;
    656              CPU_TS         ts;
    657              OS_OBJ_QTY     nbr_tasks;
    658              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    659          
    660          
    661          
    662          #ifdef OS_SAFETY_CRITICAL
    663              if (p_err == (OS_ERR *)0) {
    664                  OS_SAFETY_CRITICAL_EXCEPTION();
    665                  return ((OS_OBJ_QTY)0u);
    666              }
    667          #endif
    668          
    669          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    670              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \   0000000E   0x....             LDR.N    R0,??DataTable10
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSFlagPendAbort_0
    671                 *p_err = OS_ERR_PEND_ABORT_ISR;
   \   00000016   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    672                  return ((OS_OBJ_QTY)0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE080             B.N      ??OSFlagPendAbort_1
    673              }
    674          #endif
    675          
    676          #if OS_CFG_ARG_CHK_EN > 0u
    677              if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
   \                     ??OSFlagPendAbort_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSFlagPendAbort_2
    678                 *p_err  =  OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8030             STRH     R0,[R6, #+0]
    679                  return ((OS_OBJ_QTY)0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE079             B.N      ??OSFlagPendAbort_1
    680              }
    681              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSFlagPendAbort_2: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD008             BEQ.N    ??OSFlagPendAbort_3
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD005             BEQ.N    ??OSFlagPendAbort_3
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD002             BEQ.N    ??OSFlagPendAbort_3
   \   00000042   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000046   0xD104             BNE.N    ??OSFlagPendAbort_4
    682                  case OS_OPT_PEND_ABORT_1:
    683                  case OS_OPT_PEND_ABORT_ALL:
    684                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    685                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    686                       break;
    687          
    688                  default:
    689                      *p_err = OS_ERR_OPT_INVALID;
    690                       return ((OS_OBJ_QTY)0u);
    691              }
    692          #endif
    693          
    694          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    695              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure event flag group was created                 */
   \                     ??OSFlagPendAbort_3: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x....             LDR.N    R1,??DataTable10_2  ;; 0x47414c46
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD105             BNE.N    ??OSFlagPendAbort_5
   \   00000050   0xE009             B.N      ??OSFlagPendAbort_6
   \                     ??OSFlagPendAbort_4: (+1)
   \   00000052   0xF645 0x6025      MOVW     R0,#+24101
   \   00000056   0x8030             STRH     R0,[R6, #+0]
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE062             B.N      ??OSFlagPendAbort_1
    696                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSFlagPendAbort_5: (+1)
   \   0000005C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000060   0x8030             STRH     R0,[R6, #+0]
    697                  return ((OS_OBJ_QTY)0u);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE05D             B.N      ??OSFlagPendAbort_1
    698              }
    699          #endif
    700          
    701              CPU_CRITICAL_ENTER();
   \                     ??OSFlagPendAbort_6: (+1)
   \   00000066   0x.... 0x....      BL       CPU_SR_Save
   \   0000006A   0x4683             MOV      R11,R0
   \   0000006C   0x.... 0x....      BL       CPU_IntDisMeasStart
    702              p_pend_list = &p_grp->PendList;
   \   00000070   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000074   0x0007             MOVS     R7,R0
    703              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on flag group?                        */
   \   00000076   0x8938             LDRH     R0,[R7, #+8]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD109             BNE.N    ??OSFlagPendAbort_7
    704                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000080   0x4658             MOV      R0,R11
   \   00000082   0x.... 0x....      BL       CPU_SR_Restore
    705                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   00000086   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000008A   0x8030             STRH     R0,[R6, #+0]
    706                  return ((OS_OBJ_QTY)0u);
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE048             B.N      ??OSFlagPendAbort_1
    707              }
    708          
    709              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSFlagPendAbort_7: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD101             BNE.N    ??OSFlagPendAbort_8
   \   000000A8   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OSFlagPendAbort_8: (+1)
   \   000000AC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B0   0x4658             MOV      R0,R11
   \   000000B2   0x.... 0x....      BL       CPU_SR_Restore
    710              nbr_tasks = 0u;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x4682             MOV      R10,R0
    711              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
   \   000000BA   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000BE   0x4681             MOV      R9,R0
    712              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSFlagPendAbort_9: (+1)
   \   000000C0   0x8938             LDRH     R0,[R7, #+8]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD00D             BEQ.N    ??OSFlagPendAbort_10
    713                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
   \   000000C6   0x6838             LDR      R0,[R7, #+0]
   \   000000C8   0x6880             LDR      R0,[R0, #+8]
   \   000000CA   0x4680             MOV      R8,R0
    714                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_grp),
    715                               p_tcb,
    716                               ts);
   \   000000CC   0x464A             MOV      R2,R9
   \   000000CE   0x4641             MOV      R1,R8
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       OS_PendAbort
    717                  nbr_tasks++;
   \   000000D6   0xF11A 0x0A01      ADDS     R10,R10,#+1
    718                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \   000000DA   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000DC   0xF5B5 0x7F80      CMP      R5,#+256
   \   000000E0   0xD0EE             BEQ.N    ??OSFlagPendAbort_9
    719                      break;                                          /* No                                                     */
    720                  }
    721              }
    722              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSFlagPendAbort_10: (+1)
   \   000000E2   0x.... 0x....      BL       CPU_SR_Save
   \   000000E6   0x4683             MOV      R11,R0
   \   000000E8   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x1E40             SUBS     R0,R0,#+1
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000F8   0x7008             STRB     R0,[R1, #+0]
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD101             BNE.N    ??OSFlagPendAbort_11
   \   00000104   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OSFlagPendAbort_11: (+1)
   \   00000108   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010C   0x4658             MOV      R0,R11
   \   0000010E   0x.... 0x....      BL       CPU_SR_Restore
    723          
    724              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \   00000112   0x0428             LSLS     R0,R5,#+16
   \   00000114   0xD401             BMI.N    ??OSFlagPendAbort_12
    725                  OSSched();                                          /* Run the scheduler                                      */
   \   00000116   0x.... 0x....      BL       OSSched
    726              }
    727          
    728             *p_err = OS_ERR_NONE;
   \                     ??OSFlagPendAbort_12: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x8030             STRH     R0,[R6, #+0]
    729              return (nbr_tasks);
   \   0000011E   0x4650             MOV      R0,R10
   \   00000120   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPendAbort_1: (+1)
   \   00000122   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    730          }
    731          #endif
    732          
    733          /*$PAGE*/
    734          /*
    735          ************************************************************************************************************************
    736          *                                       GET FLAGS WHO CAUSED TASK TO BECOME READY
    737          *
    738          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    739          *              In other words, this function allows you to tell "Who done it!".
    740          *
    741          * Arguments  : p_err     is a pointer to an error code
    742          *
    743          *                            OS_ERR_NONE       if the call was successful
    744          *                            OS_ERR_PEND_ISR   if called from an ISR
    745          *
    746          * Returns    : The flags that caused the task to be ready.
    747          ************************************************************************************************************************
    748          */
    749          

   \                                 In section .text, align 2, keep-with-next
    750          OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
    751          {
   \                     OSFlagPendGetFlagsRdy: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    752              OS_FLAGS   flags;
    753              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    754          
    755          
    756          
    757          #ifdef OS_SAFETY_CRITICAL
    758              if (p_err == (OS_ERR *)0) {
    759                  OS_SAFETY_CRITICAL_EXCEPTION();
    760                  return ((OS_FLAGS)0);
    761              }
    762          #endif
    763          
    764          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    765              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \   00000006   0x....             LDR.N    R0,??DataTable10
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??OSFlagPendGetFlagsRdy_0
    766                 *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
   \   0000000E   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    767                  return ((OS_FLAGS)0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE012             B.N      ??OSFlagPendGetFlagsRdy_1
    768              }
    769          #endif
    770          
    771              CPU_CRITICAL_ENTER();
   \                     ??OSFlagPendGetFlagsRdy_0: (+1)
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x0006             MOVS     R6,R0
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStart
    772              flags = OSTCBCurPtr->FlagsRdy;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000002C   0x0005             MOVS     R5,R0
    773              CPU_CRITICAL_EXIT();
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
    774             *p_err = OS_ERR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x8020             STRH     R0,[R4, #+0]
    775              return (flags);
   \   0000003C   0x0028             MOVS     R0,R5
   \                     ??OSFlagPendGetFlagsRdy_1: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    776          }
    777          
    778          /*$PAGE*/
    779          /*
    780          ************************************************************************************************************************
    781          *                                                POST EVENT FLAG BIT(S)
    782          *
    783          * Description: This function is called to set or clear some bits in an event flag group.  The bits to set or clear are
    784          *              specified by a 'bit mask'.
    785          *
    786          * Arguments  : p_grp         is a pointer to the desired event flag group.
    787          *
    788          *              flags         If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit that is set in 'flags' will
    789          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    790          *                            and 5 you would set 'flags' to:
    791          *
    792          *                                0x31     (note, bit 0 is least significant bit)
    793          *
    794          *                            If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit that is set in 'flags' will
    795          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    796          *                            4 and 5 you would specify 'flags' as:
    797          *
    798          *                                0x31     (note, bit 0 is least significant bit)
    799          *
    800          *              opt           indicates whether the flags will be:
    801          *
    802          *                                OS_OPT_POST_FLAG_SET       set
    803          *                                OS_OPT_POST_FLAG_CLR       cleared
    804          *
    805          *                            you can also 'add' OS_OPT_POST_NO_SCHED to prevent the scheduler from being called.
    806          *
    807          *              p_err         is a pointer to an error code and can be:
    808          *
    809          *                                OS_ERR_NONE                The call was successful
    810          *                                OS_ERR_OBJ_PTR_NULL        You passed a NULL pointer
    811          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
    812          *                                OS_ERR_OPT_INVALID         You specified an invalid option
    813          *
    814          * Returns    : the new value of the event flags bits that are still set.
    815          *
    816          * Note(s)    : 1) The execution time of this function depends on the number of tasks waiting on the event flag group.
    817          ************************************************************************************************************************
    818          */
    819          

   \                                 In section .text, align 2, keep-with-next
    820          OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
    821                                OS_FLAGS      flags,
    822                                OS_OPT        opt,
    823                                OS_ERR       *p_err)
    824          {
   \                     OSFlagPost: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    825              OS_FLAGS  flags_cur;
    826              CPU_TS    ts;
    827          
    828          
    829          
    830          #ifdef OS_SAFETY_CRITICAL
    831              if (p_err == (OS_ERR *)0) {
    832                  OS_SAFETY_CRITICAL_EXCEPTION();
    833                  return ((OS_FLAGS)0);
    834              }
    835          #endif
    836          
    837          #if OS_CFG_ARG_CHK_EN > 0u
    838              if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??OSFlagPost_0
    839                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000012   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000016   0x8038             STRH     R0,[R7, #+0]
    840                  return ((OS_FLAGS)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE038             B.N      ??OSFlagPost_1
    841              }
    842              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSFlagPost_0: (+1)
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD904             BLS.N    ??OSFlagPost_2
   \   00000026   0xF44F 0x4100      MOV      R1,#+32768
   \   0000002A   0x1A40             SUBS     R0,R0,R1
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD804             BHI.N    ??OSFlagPost_3
    843                  case OS_OPT_POST_FLAG_SET:
    844                  case OS_OPT_POST_FLAG_CLR:
    845                  case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
    846                  case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
    847                       break;
    848          
    849                  default:
    850                      *p_err = OS_ERR_OPT_INVALID;
    851                       return ((OS_FLAGS)0);
    852              }
    853          #endif
    854          
    855          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    856              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure we are pointing to an event flag grp         */
   \                     ??OSFlagPost_2: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable10_2  ;; 0x47414c46
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD105             BNE.N    ??OSFlagPost_4
   \   00000038   0xE009             B.N      ??OSFlagPost_5
   \                     ??OSFlagPost_3: (+1)
   \   0000003A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000003E   0x8038             STRH     R0,[R7, #+0]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE024             B.N      ??OSFlagPost_1
    857                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSFlagPost_4: (+1)
   \   00000044   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000048   0x8038             STRH     R0,[R7, #+0]
    858                  return ((OS_FLAGS)0);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE01F             B.N      ??OSFlagPost_1
    859              }
    860          #endif
    861          
    862              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSFlagPost_5: (+1)
   \   0000004E   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000052   0x4681             MOV      R9,R0
    863          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    864              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \   00000054   0x....             LDR.N    R0,??DataTable10
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD00E             BEQ.N    ??OSFlagPost_6
    865                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_FLAG,          /* Post to ISR queue                                      */
    866                              (void      *)p_grp,
    867                              (void      *)0,
    868                              (OS_MSG_SIZE)0,
    869                              (OS_FLAGS   )flags,
    870                              (OS_OPT     )opt,
    871                              (CPU_TS     )ts,
    872                              (OS_ERR    *)p_err);
   \   0000005C   0x9703             STR      R7,[SP, #+12]
   \   0000005E   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x9001             STR      R0,[SP, #+4]
   \   00000068   0x9500             STR      R5,[SP, #+0]
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0x....             LDR.N    R0,??DataTable10_2  ;; 0x47414c46
   \   00000072   0x.... 0x....      BL       OS_IntQPost
    873                  return ((OS_FLAGS)0);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE009             B.N      ??OSFlagPost_1
    874              }
    875          #endif
    876          
    877              flags_cur = OS_FlagPost(p_grp,
    878                                      flags,
    879                                      opt,
    880                                      ts,
    881                                      p_err);
   \                     ??OSFlagPost_6: (+1)
   \   0000007A   0x9700             STR      R7,[SP, #+0]
   \   0000007C   0x464B             MOV      R3,R9
   \   0000007E   0x0032             MOVS     R2,R6
   \   00000080   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       OS_FlagPost
   \   0000008A   0x4680             MOV      R8,R0
    882          
    883              return (flags_cur);
   \   0000008C   0x4640             MOV      R0,R8
   \                     ??OSFlagPost_1: (+1)
   \   0000008E   0xB005             ADD      SP,SP,#+20
   \   00000090   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    884          }
    885          
    886          /*$PAGE*/
    887          /*
    888          ************************************************************************************************************************
    889          *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
    890          *
    891          * Description: This function is internal to uC/OS-III and is used to put a task to sleep until the desired
    892          *              event flag bit(s) are set.
    893          *
    894          * Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
    895          *              -----------    pending on the desired event flag group.
    896          *
    897          *              p_grp         is a pointer to the desired event flag group.
    898          *              -----
    899          *
    900          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
    901          *                            The bits you want are specified by setting the corresponding bits in
    902          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    903          *                            'flags' would contain 0x03.
    904          *
    905          *              opt           specifies whether you want ALL bits to be set/cleared or ANY of the bits
    906          *                            to be set/cleared.
    907          *                            You can specify the following argument:
    908          *
    909          *                                OS_OPT_PEND_FLAG_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
    910          *                                OS_OPT_PEND_FLAG_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
    911          *                                OS_OPT_PEND_FLAG_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
    912          *                                OS_OPT_PEND_FLAG_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
    913          *
    914          *              timeout       is the desired amount of time that the task will wait for the event flag
    915          *                            bit(s) to be set.
    916          *
    917          * Returns    : none
    918          *
    919          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    920          ************************************************************************************************************************
    921          */
    922          

   \                                 In section .text, align 2, keep-with-next
    923          void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
    924                              OS_FLAG_GRP   *p_grp,
    925                              OS_FLAGS       flags,
    926                              OS_OPT         opt,
    927                              OS_TICK        timeout)
    928          {
   \                     OS_FlagBlock: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
    929              OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
   \   00000010   0x....             LDR.N    R0,??DataTable11_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF8C0 0x6080      STR      R6,[R0, #+128]
    930              OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
   \   00000018   0x....             LDR.N    R0,??DataTable11_2
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF8A0 0x7088      STRH     R7,[R0, #+136]
    931              OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable11_2
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0xF8C1 0x0084      STR      R0,[R1, #+132]
    932          
    933              OS_Pend(p_pend_data,
    934                      (OS_PEND_OBJ *)((void *)p_grp),
    935                       OS_TASK_PEND_ON_FLAG,
    936                       timeout);
   \   0000002A   0x4643             MOV      R3,R8
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       OS_Pend
    937          }
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    938          
    939          /*$PAGE*/
    940          /*
    941          ************************************************************************************************************************
    942          *                                      CLEAR THE CONTENTS OF AN EVENT FLAG GROUP
    943          *
    944          * Description: This function is called by OSFlagDel() to clear the contents of an event flag group
    945          *
    946          
    947          * Argument(s): p_grp     is a pointer to the event flag group to clear
    948          *              -----
    949          *
    950          * Returns    : none
    951          *
    952          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    953          ************************************************************************************************************************
    954          */
    955          

   \                                 In section .text, align 2, keep-with-next
    956          void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
    957          {
   \                     OS_FlagClr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    958              OS_PEND_LIST  *p_pend_list;
    959          
    960          
    961          
    962              p_grp->Type             = OS_OBJ_TYPE_NONE;
   \   00000004   0x....             LDR.N    R0,??DataTable11_4  ;; 0x454e4f4e
   \   00000006   0x6020             STR      R0,[R4, #+0]
    963              p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                       */
   \   00000008   0x....             LDR.N    R0,??DataTable11_5
   \   0000000A   0x6060             STR      R0,[R4, #+4]
    964              p_grp->Flags            = (OS_FLAGS )0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6220             STR      R0,[R4, #+32]
    965              p_pend_list             = &p_grp->PendList;
   \   00000010   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000014   0x0005             MOVS     R5,R0
    966              OS_PendListInit(p_pend_list);
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       OS_PendListInit
    967          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    968          
    969          /*$PAGE*/
    970          /*
    971          ************************************************************************************************************************
    972          *                                          INITIALIZE THE EVENT FLAG MODULE
    973          *
    974          * Description: This function is called by uC/OS-III to initialize the event flag module.  Your application MUST NOT call
    975          *              this function.  In other words, this function is internal to uC/OS-III.
    976          *
    977          * Arguments  : p_err     is a pointer to an error code that can contain one of the following values:
    978          *
    979          *                            OS_ERR_NONE   The call was successful.
    980          *
    981          * Returns    : none
    982          *
    983          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    984          ************************************************************************************************************************
    985          */
    986          

   \                                 In section .text, align 2, keep-with-next
    987          void  OS_FlagInit (OS_ERR  *p_err)
    988          {
    989          #ifdef OS_SAFETY_CRITICAL
    990              if (p_err == (OS_ERR *)0) {
    991                  OS_SAFETY_CRITICAL_EXCEPTION();
    992                  return;
    993              }
    994          #endif
    995          
    996          #if OS_CFG_DBG_EN > 0u
    997              OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
   \                     OS_FlagInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable11_6
   \   00000004   0x6011             STR      R1,[R2, #+0]
    998          #endif
    999          
   1000              OSFlagQty        = (OS_OBJ_QTY   )0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable10_3
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
   1001             *p_err            = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   1002          }
   \   00000010   0x4770             BX       LR               ;; return
   1003          
   1004          /*$PAGE*/
   1005          /*
   1006          ************************************************************************************************************************
   1007          *                                    ADD/REMOVE EVENT FLAG GROUP TO/FROM DEBUG LIST
   1008          *
   1009          * Description: These functions are called by uC/OS-III to add or remove an event flag group from the event flag debug
   1010          *              list.
   1011          *
   1012          * Arguments  : p_grp     is a pointer to the event flag group to add/remove
   1013          *
   1014          * Returns    : none
   1015          *
   1016          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1017          ************************************************************************************************************************
   1018          */
   1019          
   1020          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1021          void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
   1022          {
   1023              p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
   \                     OS_FlagDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable11  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
   1024              p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
   1025              if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
   \   00000008   0x....             LDR.N    R1,??DataTable11_6
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_FlagDbgListAdd_0
   1026                  p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_FlagDbgListAdd_1
   1027              } else {
   1028                  p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
   \                     ??OS_FlagDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable11_6
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
   1029                  OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
   \   0000001C   0x....             LDR.N    R1,??DataTable11_6
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
   1030              }
   1031              OSFlagDbgListPtr                 =  p_grp;
   \                     ??OS_FlagDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable11_6
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1032          }
   \   00000026   0x4770             BX       LR               ;; return
   1033          
   1034          
   1035          

   \                                 In section .text, align 2, keep-with-next
   1036          void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
   1037          {
   1038              OS_FLAG_GRP  *p_grp_next;
   1039              OS_FLAG_GRP  *p_grp_prev;
   1040          
   1041          
   1042              p_grp_prev = p_grp->DbgPrevPtr;
   \                     OS_FlagDbgListRemove: (+1)
   \   00000000   0x6943             LDR      R3,[R0, #+20]
   \   00000002   0x001A             MOVS     R2,R3
   1043              p_grp_next = p_grp->DbgNextPtr;
   \   00000004   0x6983             LDR      R3,[R0, #+24]
   \   00000006   0x0019             MOVS     R1,R3
   1044          
   1045              if (p_grp_prev == (OS_FLAG_GRP *)0) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??OS_FlagDbgListRemove_0
   1046                  OSFlagDbgListPtr = p_grp_next;
   \   0000000C   0x....             LDR.N    R3,??DataTable11_6
   \   0000000E   0x6019             STR      R1,[R3, #+0]
   1047                  if (p_grp_next != (OS_FLAG_GRP *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??OS_FlagDbgListRemove_1
   1048                      p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x614B             STR      R3,[R1, #+20]
   1049                  }
   1050                  p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;
   \                     ??OS_FlagDbgListRemove_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6183             STR      R3,[R0, #+24]
   \   0000001C   0xE00C             B.N      ??OS_FlagDbgListRemove_2
   1051          
   1052              } else if (p_grp_next == (OS_FLAG_GRP *)0) {
   \                     ??OS_FlagDbgListRemove_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_FlagDbgListRemove_3
   1053                  p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x6193             STR      R3,[R2, #+24]
   1054                  p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x6143             STR      R3,[R0, #+20]
   \   0000002A   0xE005             B.N      ??OS_FlagDbgListRemove_2
   1055          
   1056              } else {
   1057                  p_grp_prev->DbgNextPtr =  p_grp_next;
   \                     ??OS_FlagDbgListRemove_3: (+1)
   \   0000002C   0x6191             STR      R1,[R2, #+24]
   1058                  p_grp_next->DbgPrevPtr =  p_grp_prev;
   \   0000002E   0x614A             STR      R2,[R1, #+20]
   1059                  p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x6183             STR      R3,[R0, #+24]
   1060                  p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x6143             STR      R3,[R0, #+20]
   1061              }
   1062          }
   \                     ??OS_FlagDbgListRemove_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1063          #endif
   1064          
   1065          /*$PAGE*/
   1066          /*
   1067          ************************************************************************************************************************
   1068          *                                                POST EVENT FLAG BIT(S)
   1069          *
   1070          * Description: This function is called to set or clear some bits in an event flag group.  The bits to set or clear are
   1071          *              specified by a 'bit mask'.
   1072          *
   1073          * Arguments  : p_grp         is a pointer to the desired event flag group.
   1074          *
   1075          *              flags         If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit that is set in 'flags' will
   1076          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
   1077          *                            and 5 you would set 'flags' to:
   1078          *
   1079          *                                0x31     (note, bit 0 is least significant bit)
   1080          *
   1081          *                            If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit that is set in 'flags' will
   1082          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
   1083          *                            4 and 5 you would specify 'flags' as:
   1084          *
   1085          *                                0x31     (note, bit 0 is least significant bit)
   1086          *
   1087          *              opt           indicates whether the flags will be:
   1088          *
   1089          *                                OS_OPT_POST_FLAG_SET       set
   1090          *                                OS_OPT_POST_FLAG_CLR       cleared
   1091          *
   1092          *                            you can also 'add' OS_OPT_POST_NO_SCHED to prevent the scheduler from being called.
   1093          *
   1094          *              ts            is the timestamp of the post
   1095          *
   1096          *              p_err         is a pointer to an error code and can be:
   1097          *
   1098          *                                OS_ERR_NONE                The call was successful
   1099          *                                OS_ERR_OBJ_PTR_NULL        You passed a NULL pointer
   1100          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
   1101          *                                OS_ERR_OPT_INVALID         You specified an invalid option
   1102          *
   1103          * Returns    : the new value of the event flags bits that are still set.
   1104          *
   1105          * Note(s)    : 1) The execution time of this function depends on the number of tasks waiting on the event flag group.
   1106          ************************************************************************************************************************
   1107          */
   1108          

   \                                 In section .text, align 2, keep-with-next
   1109          OS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
   1110                                 OS_FLAGS      flags,
   1111                                 OS_OPT        opt,
   1112                                 CPU_TS        ts,
   1113                                 OS_ERR       *p_err)
   1114          {
   \                     OS_FlagPost: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4683             MOV      R11,R0
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
   \   0000000C   0x9E0E             LDR      R6,[SP, #+56]
   1115              OS_FLAGS        flags_cur;
   1116              OS_FLAGS        flags_rdy;
   1117              OS_OPT          mode;
   1118              OS_PEND_DATA   *p_pend_data;
   1119              OS_PEND_DATA   *p_pend_data_next;
   1120              OS_PEND_LIST   *p_pend_list;
   1121              OS_TCB         *p_tcb;
   1122              CPU_SR_ALLOC();
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
   1123          
   1124          
   1125          
   1126              CPU_CRITICAL_ENTER();
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   \   00000016   0x4682             MOV      R10,R0
   \   00000018   0x.... 0x....      BL       CPU_IntDisMeasStart
   1127              switch (opt) {
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD009             BEQ.N    ??OS_FlagPost_0
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD00E             BEQ.N    ??OS_FlagPost_1
   \   00000028   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002C   0xD004             BEQ.N    ??OS_FlagPost_0
   \   0000002E   0xF248 0x0101      MOVW     R1,#+32769
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD007             BEQ.N    ??OS_FlagPost_1
   \   00000036   0xE00D             B.N      ??OS_FlagPost_2
   1128                  case OS_OPT_POST_FLAG_SET:
   1129                  case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
   1130                       p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
   \                     ??OS_FlagPost_0: (+1)
   \   00000038   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   0000003C   0x9904             LDR      R1,[SP, #+16]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0xF8CB 0x0020      STR      R0,[R11, #+32]
   1131                       break;
   \   00000044   0xE010             B.N      ??OS_FlagPost_3
   1132          
   1133                  case OS_OPT_POST_FLAG_CLR:
   1134                  case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
   1135                       p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
   \                     ??OS_FlagPost_1: (+1)
   \   00000046   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   0000004A   0x9904             LDR      R1,[SP, #+16]
   \   0000004C   0x4388             BICS     R0,R0,R1
   \   0000004E   0xF8CB 0x0020      STR      R0,[R11, #+32]
   1136                       break;
   \   00000052   0xE009             B.N      ??OS_FlagPost_3
   1137          
   1138                  default:
   1139                       CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
   \                     ??OS_FlagPost_2: (+1)
   \   00000054   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000058   0x4650             MOV      R0,R10
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
   1140                      *p_err = OS_ERR_OPT_INVALID;
   \   0000005E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000062   0x8030             STRH     R0,[R6, #+0]
   1141                       return ((OS_FLAGS)0);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE0DF             B.N      ??OS_FlagPost_4
   1142              }
   1143              p_grp->TS   = ts;
   \                     ??OS_FlagPost_3: (+1)
   \   00000068   0xF8CB 0x5024      STR      R5,[R11, #+36]
   1144              p_pend_list = &p_grp->PendList;
   \   0000006C   0xF11B 0x0008      ADDS     R0,R11,#+8
   \   00000070   0x9000             STR      R0,[SP, #+0]
   1145              if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x8900             LDRH     R0,[R0, #+8]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD109             BNE.N    ??OS_FlagPost_5
   1146                  CPU_CRITICAL_EXIT();                                    /* No                                                 */
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007E   0x4650             MOV      R0,R10
   \   00000080   0x.... 0x....      BL       CPU_SR_Restore
   1147                 *p_err = OS_ERR_NONE;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x8030             STRH     R0,[R6, #+0]
   1148                  return (p_grp->Flags);
   \   00000088   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   0000008C   0xE0CC             B.N      ??OS_FlagPost_4
   1149              }
   1150          
   1151              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OS_FlagPost_5: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable11_3
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x....             LDR.N    R1,??DataTable11_3
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   \   00000098   0x....             LDR.N    R0,??DataTable11_3
   \   0000009A   0x7800             LDRB     R0,[R0, #+0]
   \   0000009C   0x2801             CMP      R0,#+1
   \   0000009E   0xD101             BNE.N    ??OS_FlagPost_6
   \   000000A0   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??OS_FlagPost_6: (+1)
   \   000000A4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A8   0x4650             MOV      R0,R10
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
   1152              p_pend_data = p_pend_list->HeadPtr;
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x4680             MOV      R8,R0
   1153              p_tcb       = p_pend_data->TCBPtr;
   \   000000B4   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   000000B8   0x4681             MOV      R9,R0
   1154              while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
   \                     ??OS_FlagPost_7: (+1)
   \   000000BA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BE   0xF000 0x808A      BEQ.W    ??OS_FlagPost_8
   1155                  p_pend_data_next = p_pend_data->NextPtr;
   \   000000C2   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   000000C6   0x9001             STR      R0,[SP, #+4]
   1156                  mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
   \   000000C8   0xF899 0x0088      LDRB     R0,[R9, #+136]
   \   000000CC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000D0   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1157                  switch (mode) {
   \   000000D4   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD024             BEQ.N    ??OS_FlagPost_9
   \   000000DC   0x2802             CMP      R0,#+2
   \   000000DE   0xD033             BEQ.N    ??OS_FlagPost_10
   \   000000E0   0x2804             CMP      R0,#+4
   \   000000E2   0xD002             BEQ.N    ??OS_FlagPost_11
   \   000000E4   0x2808             CMP      R0,#+8
   \   000000E6   0xD010             BEQ.N    ??OS_FlagPost_12
   \   000000E8   0xE03D             B.N      ??OS_FlagPost_13
   1158                      case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node     */
   1159                           flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OS_FlagPost_11: (+1)
   \   000000EA   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   000000EE   0xF8D9 0x1080      LDR      R1,[R9, #+128]
   \   000000F2   0x4008             ANDS     R0,R1,R0
   \   000000F4   0x0007             MOVS     R7,R0
   1160                           if (flags_rdy == p_tcb->FlagsPend) {
   \   000000F6   0xF8D9 0x0080      LDR      R0,[R9, #+128]
   \   000000FA   0x4287             CMP      R7,R0
   \   000000FC   0xD104             BNE.N    ??OS_FlagPost_14
   1161                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
   1162                                              flags_rdy,
   1163                                              ts);
   \   000000FE   0x002A             MOVS     R2,R5
   \   00000100   0x0039             MOVS     R1,R7
   \   00000102   0x4648             MOV      R0,R9
   \   00000104   0x.... 0x....      BL       OS_FlagTaskRdy
   1164                           }
   1165                           break;
   \                     ??OS_FlagPost_14: (+1)
   \   00000108   0xE059             B.N      ??OS_FlagPost_15
   1166          
   1167                      case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                */
   1168                           flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OS_FlagPost_12: (+1)
   \   0000010A   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   0000010E   0xF8D9 0x1080      LDR      R1,[R9, #+128]
   \   00000112   0x4008             ANDS     R0,R1,R0
   \   00000114   0x0007             MOVS     R7,R0
   1169                           if (flags_rdy != (OS_FLAGS)0) {
   \   00000116   0x2F00             CMP      R7,#+0
   \   00000118   0xD004             BEQ.N    ??OS_FlagPost_16
   1170                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
   1171                                              flags_rdy,
   1172                                              ts);
   \   0000011A   0x002A             MOVS     R2,R5
   \   0000011C   0x0039             MOVS     R1,R7
   \   0000011E   0x4648             MOV      R0,R9
   \   00000120   0x.... 0x....      BL       OS_FlagTaskRdy
   1173                           }
   1174                           break;
   \                     ??OS_FlagPost_16: (+1)
   \   00000124   0xE04B             B.N      ??OS_FlagPost_15
   1175          
   1176          #if OS_CFG_FLAG_MODE_CLR_EN > 0u
   1177                      case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node     */
   1178                           flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OS_FlagPost_9: (+1)
   \   00000126   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   0000012A   0xF8D9 0x1080      LDR      R1,[R9, #+128]
   \   0000012E   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000132   0x0007             MOVS     R7,R0
   1179                           if (flags_rdy == p_tcb->FlagsPend) {
   \   00000134   0xF8D9 0x0080      LDR      R0,[R9, #+128]
   \   00000138   0x4287             CMP      R7,R0
   \   0000013A   0xD104             BNE.N    ??OS_FlagPost_17
   1180                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
   1181                                              flags_rdy,
   1182                                              ts);
   \   0000013C   0x002A             MOVS     R2,R5
   \   0000013E   0x0039             MOVS     R1,R7
   \   00000140   0x4648             MOV      R0,R9
   \   00000142   0x.... 0x....      BL       OS_FlagTaskRdy
   1183                           }
   1184                           break;
   \                     ??OS_FlagPost_17: (+1)
   \   00000146   0xE03A             B.N      ??OS_FlagPost_15
   1185          
   1186                      case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                */
   1187                           flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OS_FlagPost_10: (+1)
   \   00000148   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   0000014C   0xF8D9 0x1080      LDR      R1,[R9, #+128]
   \   00000150   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000154   0x0007             MOVS     R7,R0
   1188                           if (flags_rdy != (OS_FLAGS)0) {
   \   00000156   0x2F00             CMP      R7,#+0
   \   00000158   0xD004             BEQ.N    ??OS_FlagPost_18
   1189                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
   1190                                              flags_rdy,
   1191                                              ts);
   \   0000015A   0x002A             MOVS     R2,R5
   \   0000015C   0x0039             MOVS     R1,R7
   \   0000015E   0x4648             MOV      R0,R9
   \   00000160   0x.... 0x....      BL       OS_FlagTaskRdy
   1192                           }
   1193                           break;
   \                     ??OS_FlagPost_18: (+1)
   \   00000164   0xE02B             B.N      ??OS_FlagPost_15
   1194          #endif
   1195                      default:
   1196                           OS_CRITICAL_EXIT();
   \                     ??OS_FlagPost_13: (+1)
   \   00000166   0x.... 0x....      BL       CPU_SR_Save
   \   0000016A   0x4682             MOV      R10,R0
   \   0000016C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000170   0x....             LDR.N    R0,??DataTable11_3
   \   00000172   0x7800             LDRB     R0,[R0, #+0]
   \   00000174   0x1E40             SUBS     R0,R0,#+1
   \   00000176   0x....             LDR.N    R1,??DataTable11_3
   \   00000178   0x7008             STRB     R0,[R1, #+0]
   \   0000017A   0x....             LDR.N    R0,??DataTable11_3
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD113             BNE.N    ??OS_FlagPost_19
   \   00000182   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000186   0x....             LDR.N    R0,??DataTable11_1
   \   00000188   0x8800             LDRH     R0,[R0, #+0]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD007             BEQ.N    ??OS_FlagPost_20
   \   0000018E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000192   0x4650             MOV      R0,R10
   \   00000194   0x.... 0x....      BL       CPU_SR_Restore
   \   00000198   0x.... 0x....      BL       OS_Sched0
   \   0000019C   0xE00A             B.N      ??OS_FlagPost_21
   \                     ??OS_FlagPost_20: (+1)
   \   0000019E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001A2   0x4650             MOV      R0,R10
   \   000001A4   0x.... 0x....      BL       CPU_SR_Restore
   \   000001A8   0xE004             B.N      ??OS_FlagPost_21
   \                     ??OS_FlagPost_19: (+1)
   \   000001AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001AE   0x4650             MOV      R0,R10
   \   000001B0   0x.... 0x....      BL       CPU_SR_Restore
   1197                          *p_err = OS_ERR_FLAG_PEND_OPT;
   \                     ??OS_FlagPost_21: (+1)
   \   000001B4   0xF643 0x20FF      MOVW     R0,#+15103
   \   000001B8   0x8030             STRH     R0,[R6, #+0]
   1198                           return ((OS_FLAGS)0);
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0xE034             B.N      ??OS_FlagPost_4
   1199                  }
   1200                  p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)       */
   \                     ??OS_FlagPost_15: (+1)
   \   000001BE   0x9801             LDR      R0,[SP, #+4]
   \   000001C0   0x4680             MOV      R8,R0
   1201                  if (p_pend_data != (OS_PEND_DATA *)0) {
   \   000001C2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001C6   0xD003             BEQ.N    ??OS_FlagPost_22
   1202                      p_tcb = p_pend_data->TCBPtr;
   \   000001C8   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   000001CC   0x4681             MOV      R9,R0
   \   000001CE   0xE774             B.N      ??OS_FlagPost_7
   1203                  } else {
   1204                      p_tcb = (OS_TCB *)0;
   \                     ??OS_FlagPost_22: (+1)
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0x4681             MOV      R9,R0
   \   000001D4   0xE771             B.N      ??OS_FlagPost_7
   1205                  }
   1206              }
   1207              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OS_FlagPost_8: (+1)
   \   000001D6   0x.... 0x....      BL       CPU_SR_Save
   \   000001DA   0x4682             MOV      R10,R0
   \   000001DC   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001E0   0x....             LDR.N    R0,??DataTable11_3
   \   000001E2   0x7800             LDRB     R0,[R0, #+0]
   \   000001E4   0x1E40             SUBS     R0,R0,#+1
   \   000001E6   0x....             LDR.N    R1,??DataTable11_3
   \   000001E8   0x7008             STRB     R0,[R1, #+0]
   \   000001EA   0x....             LDR.N    R0,??DataTable11_3
   \   000001EC   0x7800             LDRB     R0,[R0, #+0]
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD101             BNE.N    ??OS_FlagPost_23
   \   000001F2   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \                     ??OS_FlagPost_23: (+1)
   \   000001F6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001FA   0x4650             MOV      R0,R10
   \   000001FC   0x.... 0x....      BL       CPU_SR_Restore
   1208          
   1209              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \   00000200   0x0420             LSLS     R0,R4,#+16
   \   00000202   0xD401             BMI.N    ??OS_FlagPost_24
   1210                  OSSched();
   \   00000204   0x.... 0x....      BL       OSSched
   1211              }
   1212          
   1213              CPU_CRITICAL_ENTER();
   \                     ??OS_FlagPost_24: (+1)
   \   00000208   0x.... 0x....      BL       CPU_SR_Save
   \   0000020C   0x4682             MOV      R10,R0
   \   0000020E   0x.... 0x....      BL       CPU_IntDisMeasStart
   1214              flags_cur = p_grp->Flags;
   \   00000212   0xF8DB 0x0020      LDR      R0,[R11, #+32]
   \   00000216   0x9003             STR      R0,[SP, #+12]
   1215              CPU_CRITICAL_EXIT();
   \   00000218   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000021C   0x4650             MOV      R0,R10
   \   0000021E   0x.... 0x....      BL       CPU_SR_Restore
   1216             *p_err     = OS_ERR_NONE;
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0x8030             STRH     R0,[R6, #+0]
   1217              return (flags_cur);
   \   00000226   0x9803             LDR      R0,[SP, #+12]
   \                     ??OS_FlagPost_4: (+1)
   \   00000228   0xB005             ADD      SP,SP,#+20
   \   0000022A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1218          }
   1219          
   1220          /*$PAGE*/
   1221          /*
   1222          ************************************************************************************************************************
   1223          *                                        MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1224          *
   1225          * Description: This function is internal to uC/OS-III and is used to make a task ready-to-run because the desired event
   1226          *              flag bits have been set.
   1227          *
   1228          * Arguments  : p_tcb         is a pointer to the OS_TCB of the task to remove
   1229          *              -----
   1230          *
   1231          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become ready-to-run.
   1232          *
   1233          *              ts            is a timestamp associated with the post
   1234          *
   1235          * Returns    : none
   1236          *
   1237          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1238          ************************************************************************************************************************
   1239          */
   1240          

   \                                 In section .text, align 2, keep-with-next
   1241          void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
   1242                                 OS_FLAGS   flags_rdy,
   1243                                 CPU_TS     ts)
   1244          {
   \                     OS_FlagTaskRdy: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1245              p_tcb->FlagsRdy   = flags_rdy;
   \   00000008   0xF8C4 0x5084      STR      R5,[R4, #+132]
   1246              p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF884 0x0035      STRB     R0,[R4, #+53]
   1247              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF884 0x0034      STRB     R0,[R4, #+52]
   1248              p_tcb->TS         = ts;
   \   00000018   0x6426             STR      R6,[R4, #+64]
   1249              switch (p_tcb->TaskState) {
   \   0000001A   0xF894 0x0036      LDRB     R0,[R4, #+54]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00B             BEQ.N    ??OS_FlagTaskRdy_0
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD00A             BEQ.N    ??OS_FlagTaskRdy_1
   \   00000026   0xD308             BCC.N    ??OS_FlagTaskRdy_0
   \   00000028   0x2804             CMP      R0,#+4
   \   0000002A   0xD006             BEQ.N    ??OS_FlagTaskRdy_0
   \   0000002C   0xD306             BCC.N    ??OS_FlagTaskRdy_1
   \   0000002E   0x2806             CMP      R0,#+6
   \   00000030   0xD00B             BEQ.N    ??OS_FlagTaskRdy_2
   \   00000032   0xD302             BCC.N    ??OS_FlagTaskRdy_0
   \   00000034   0x2807             CMP      R0,#+7
   \   00000036   0xD008             BEQ.N    ??OS_FlagTaskRdy_2
   \   00000038   0xE00B             B.N      ??OS_FlagTaskRdy_3
   1250                  case OS_TASK_STATE_RDY:
   1251                  case OS_TASK_STATE_DLY:
   1252                  case OS_TASK_STATE_DLY_SUSPENDED:
   1253                  case OS_TASK_STATE_SUSPENDED:
   1254                       break;
   \                     ??OS_FlagTaskRdy_0: (+1)
   \   0000003A   0xE00A             B.N      ??OS_FlagTaskRdy_4
   1255          
   1256                  case OS_TASK_STATE_PEND:
   1257                  case OS_TASK_STATE_PEND_TIMEOUT:
   1258                       OS_TaskRdy(p_tcb);
   \                     ??OS_FlagTaskRdy_1: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       OS_TaskRdy
   1259                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x0036      STRB     R0,[R4, #+54]
   1260                       break;
   \   00000048   0xE003             B.N      ??OS_FlagTaskRdy_4
   1261          
   1262                  case OS_TASK_STATE_PEND_SUSPENDED:
   1263                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1264                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_FlagTaskRdy_2: (+1)
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0xF884 0x0036      STRB     R0,[R4, #+54]
   1265                       break;
   \   00000050   0xE7FF             B.N      ??OS_FlagTaskRdy_4
   1266          
   1267                  default:
   1268                       break;
   1269              }
   1270              OS_PendListRemove(p_tcb);
   \                     ??OS_FlagTaskRdy_3: (+1)
   \                     ??OS_FlagTaskRdy_4: (+1)
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       OS_PendListRemove
   1271          }
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x47414C46         DC32     0x47414c46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OSFlagQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     OSFlagDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x46          DC8 "?FLAG"
   \              0x4C 0x41    
   \              0x47 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
   1272          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSFlagCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_FlagDbgListAdd
        24   -> OS_PendListInit
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
      48   OSFlagDel
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_TS_TmrRd
        48   -> OSSched
        48   -> OS_FlagClr
        48   -> OS_FlagDbgListRemove
        48   -> OS_PendObjDel
        48   -> OS_Sched0
        48   -> OS_SchedLockTimeMeasStart
        48   -> OS_SchedLockTimeMeasStop
      80   OSFlagPend
        80   -> CPU_IntDisMeasStart
        80   -> CPU_IntDisMeasStop
        80   -> CPU_SR_Restore
        80   -> CPU_SR_Save
        80   -> OSSched
        80   -> OS_FlagBlock
        80   -> OS_SchedLockTimeMeasStart
        80   -> OS_SchedLockTimeMeasStop
      40   OSFlagPendAbort
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_PendAbort
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
      16   OSFlagPendGetFlagsRdy
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      48   OSFlagPost
        48   -> CPU_TS_TmrRd
        48   -> OS_FlagPost
        48   -> OS_IntQPost
      24   OS_FlagBlock
        24   -> OS_Pend
      16   OS_FlagClr
        16   -> OS_PendListInit
       0   OS_FlagDbgListAdd
       0   OS_FlagDbgListRemove
       0   OS_FlagInit
      56   OS_FlagPost
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> OSSched
        56   -> OS_FlagTaskRdy
        56   -> OS_Sched0
        56   -> OS_SchedLockTimeMeasStart
        56   -> OS_SchedLockTimeMeasStop
      16   OS_FlagTaskRdy
        16   -> OS_PendListRemove
        16   -> OS_TaskRdy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       8  ?_0
       2  ?_1
     192  OSFlagCreate
     610  OSFlagDel
    1498  OSFlagPend
     294  OSFlagPendAbort
      64  OSFlagPendGetFlagsRdy
     148  OSFlagPost
      58  OS_FlagBlock
      30  OS_FlagClr
      40  OS_FlagDbgListAdd
      58  OS_FlagDbgListRemove
      18  OS_FlagInit
     558  OS_FlagPost
      90  OS_FlagTaskRdy

 
    10 bytes in section .rodata
 3 702 bytes in section .text
 
 3 702 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
